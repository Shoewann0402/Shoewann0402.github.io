<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shoewann&#39;s Personal Blog</title>
  
  <subtitle>记录 &amp; 分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shoewann0402.github.io/"/>
  <updated>2020-03-09T06:38:05.728Z</updated>
  <id>https://shoewann0402.github.io/</id>
  
  <author>
    <name>Shoewann</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 11 (R) 之 Handler 相关变化</title>
    <link href="https://shoewann0402.github.io/2020/03/09/android-R-about-handler-change/"/>
    <id>https://shoewann0402.github.io/2020/03/09/android-R-about-handler-change/</id>
    <published>2020-03-09T06:18:37.000Z</published>
    <updated>2020-03-09T06:38:05.728Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvb3MvSGFuZGxl" title="https://developer.android.google.cn/reference/android/os/Handle">Handler<i class="fa fa-external-link"></i></span> 类，相信大家并不陌生，也应当耳熟能详，且铭记于心<br>几乎项目中使用频率较高，同时也是面试时常挂嘴边的必考知识点</p><p>今天我们来谈谈在Android 11/R 上 Handler 相关变化</p><hr><a id="more"></a><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p><em>Handler 可让您发送和处理 Message 和 Runnable 与线程的 MessageQueue 关联的对象。每个处理程序<br>实例与单个线程以及该线程的消息相关联排队。创建新的处理程序时，它会绑定到 Looper。它将消息和可运行消息传递到该 Looper 的消息排队并在该 Looper 的线程上执行它们。</em></p><p>Android DP1 的发布，参考以下的差异报告 官方对 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvb3MvSGFuZGxl" title="https://developer.android.google.cn/reference/android/os/Handle">Handler<i class="fa fa-external-link"></i></span> 类的两个构造函数进行了更改，一个是 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvb3MvSGFuZGxlciNIYW5kbGVyKCk=" title="https://developer.android.google.cn/reference/android/os/Handler#Handler()">Handler()<i class="fa fa-external-link"></i></span>，另一个是 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvb3MvSGFuZGxlciNIYW5kbGVyKGFuZHJvaWQub3MuSGFuZGxlci5DYWxsYmFjayk=" title="https://developer.android.google.cn/reference/android/os/Handler#Handler(android.os.Handler.Callback)">Handler(Handler.Callback callback)<i class="fa fa-external-link"></i></span></p><p>结果也就是将这两个方法 ——  <strong><del>废！弃！了！</del></strong></p><table><thead><tr><th>Changed Constructors</th><th></th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvb3MvSGFuZGxlci5odG1sI0hhbmRsZXIoKQ==" title="https://developer.android.com/reference/android/os/Handler.html#Handler()">Handler<i class="fa fa-external-link"></i></span>()</td><td><strong>Now deprecated</strong>.</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvb3MvSGFuZGxlci5odG1sI0hhbmRsZXIoYW5kcm9pZC5vcy5IYW5kbGVyLkNhbGxiYWNrKQ==" title="https://developer.android.com/reference/android/os/Handler.html#Handler(android.os.Handler.Callback)">Handler<i class="fa fa-external-link"></i></span>(Callback)</td><td><strong>Now deprecated</strong>.</td></tr></tbody></table><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc2RrL2FwaV9kaWZmL3ItZHAxL2NoYW5nZXMvYW5kcm9pZC5vcy5IYW5kbGVy" title="https://developer.android.com/sdk/api_diff/r-dp1/changes/android.os.Handler">Handler 差异报告<i class="fa fa-external-link"></i></span></li></ul></blockquote><hr><blockquote><p><strong><del>Handler()</del></strong> </p></blockquote><p>这个构造函数废弃了, 在Handler构造期间隐式选择Loooper会导致操作悄无声息的丢失(如果Handler不再期待新的任务并退出)，崩溃(如果Handler有时在没有激活Looper的主线程中被创建) 或者竞争条件下的bug,处理程序与之关联的线程不是作者预期的，而是使用 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2phdmEvdXRpbC9jb25jdXJyZW50L0V4ZWN1dG9y" title="https://developer.android.com/reference/java/util/concurrent/Executor">Executor<i class="fa fa-external-link"></i></span> 或者使用 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvb3MvTG9vcGVyI2dldE1haW5Mb29wZXIoKQ==" title="https://developer.android.com/reference/android/os/Looper#getMainLooper()">Looper#getMainLooper<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9WaWV3I2dldEhhbmRsZXIoKQ==" title="https://developer.android.com/reference/android/view/View#getHandler()">View#getHandler()<i class="fa fa-external-link"></i></span>, 或者类似方法显式指定Looper。如果为了兼容性需要隐式线程局部行为，使用 <strong>new Handler(Looper.myLooper())</strong> 让读者清楚知道。</p><blockquote><p><strong><del>Handler(Handler.Callback callback)</del></strong></p></blockquote><p>这个构造函数废弃了, 在Handler构造期间隐式选择Loooper会导致操作悄无声息的丢失(如果Handler不再期待新的任务并退出)，崩溃(如果Handler有时在没有激活Looper的主线程中被创建) 或者竞争条件下的bug,处理程序与之关联的线程不是作者预期的，而是使用 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2phdmEvdXRpbC9jb25jdXJyZW50L0V4ZWN1dG9y" title="https://developer.android.com/reference/java/util/concurrent/Executor">Executor<i class="fa fa-external-link"></i></span> 或者使用 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvb3MvTG9vcGVyI2dldE1haW5Mb29wZXIoKQ==" title="https://developer.android.com/reference/android/os/Looper#getMainLooper()">Looper#getMainLooper<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9WaWV3I2dldEhhbmRsZXIoKQ==" title="https://developer.android.com/reference/android/view/View#getHandler()">View#getHandler()<i class="fa fa-external-link"></i></span>, 或者类似方法显式指定Looper。如果为了兼容性需要隐式线程局部行为，使用 <strong>new Handler(Looper.myLooper(), callback)</strong> 让读者清楚知道。</p><hr><p>通过上面的官方文档介绍<br>那么在Android 11 /R 之后创建Handler构造函数</p><blockquote><ul><li><del>Handler()</del> 变更为 <strong>new Handler(Looper.myLooper())</strong></li><li><del>Handler(Handler.Callback callback)</del> 变更为 <strong>new Handler(Looper.myLooper(), callback)</strong></li></ul></blockquote><h2 id="相关示例"><a href="#相关示例" class="headerlink" title="相关示例"></a>相关示例</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoewann.androidrtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.os.Handler</span><br><span class="line"><span class="keyword">import</span> android.os.Looper</span><br><span class="line"><span class="keyword">import</span> android.os.Message</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handler()  --&gt; R 上已废弃</span></span><br><span class="line">        handler1 = <span class="keyword">object</span> : Handler() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">                Log.d(TAG, <span class="string">"handler1 handleMessage() called with: message = [<span class="variable">$msg</span>]"</span>)</span><br><span class="line">                <span class="keyword">if</span> (msg.what == <span class="number">100</span>) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"handler1 收到消息: <span class="subst">$&#123;msg.obj&#125;</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handler(Handler.Callback callback) --&gt; R 上已废弃</span></span><br><span class="line">        handler2 = Handler(Handler.Callback &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"handler 2 handleMessage() called with: message = [<span class="variable">$it</span>]"</span>)</span><br><span class="line">            <span class="keyword">if</span> (it.what == <span class="number">200</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"handler 2 收到消息: <span class="subst">$&#123;it.obj&#125;</span>"</span>)</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@Callback</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handler(Looper looper)  R 上替代 Handler()</span></span><br><span class="line">        handler3 = <span class="keyword">object</span> : Handler(Looper.myLooper()!!) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">                Log.d(TAG, <span class="string">"handler3 handleMessage() called with: msg = [<span class="variable">$msg</span>]"</span>)</span><br><span class="line">                <span class="keyword">if</span> (msg.what == <span class="number">300</span>) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"handler3 收到消息: <span class="subst">$&#123;msg.obj&#125;</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handler(Looper looper,Handler.Callback callback)  R 上替代 Handler(Handler.Callback callback)</span></span><br><span class="line">        handler4 = Handler(Looper.myLooper()!!, Handler.Callback &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"handler4 handleMessage() called with: msg = [<span class="variable">$it</span>]"</span>)</span><br><span class="line">            <span class="keyword">if</span> (it.what == <span class="number">400</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"handler4 收到消息: <span class="subst">$&#123;it.obj&#125;</span>"</span>)</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@Callback</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 弱引用 + 静态内部类 -- Handler()</span></span><br><span class="line">        handler5 = Handler5(<span class="keyword">this</span><span class="symbol">@MainActivity</span>)</span><br><span class="line">        <span class="comment">// 弱引用 + 静态内部类 -- Handler(Looper looper)</span></span><br><span class="line">        handler6 = Handler6(<span class="keyword">this</span><span class="symbol">@MainActivity</span>)</span><br><span class="line"></span><br><span class="line">        handler7 = Handler(Looper.myLooper()!!, WeakReference(Handler.Callback &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.what == <span class="number">700</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"handler7 收到消息: <span class="subst">$&#123;it.obj&#125;</span>"</span>)</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@Callback</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        &#125;).<span class="keyword">get</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//弱引用 + 静态内部类 ---&gt; Runnable</span></span><br><span class="line">        myRunnable = MyRunnable(<span class="keyword">this</span><span class="symbol">@MainActivity</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//子线程开始运行</span></span><br><span class="line">        <span class="comment">//如果这里直接new Runnble的方式会导致内存泄漏 (后面会说到)</span></span><br><span class="line">        Thread(myRunnable).start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">"MainActivity"</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> handler1: Handler? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> handler2: Handler? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> handler3: Handler? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> handler4: Handler? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> handler5: Handler? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> handler6: Handler? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> handler7: Handler? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> myRunnable: MyRunnable? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------------------ 弱引用 + 静态内部类 (开始)---------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span></span>(activity: MainActivity) : Runnable &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">var</span> activity: WeakReference&lt;MainActivity&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">init</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.activity = WeakReference(activity)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (activity?.<span class="keyword">get</span>() == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">                <span class="comment">//模拟网络请求数据---&gt; 耗时操作</span></span><br><span class="line">                Thread.sleep(<span class="number">10000</span>)</span><br><span class="line">                <span class="keyword">val</span> <span class="keyword">data</span> = <span class="string">"This is a json data from web server"</span></span><br><span class="line">                <span class="comment">//发送消息</span></span><br><span class="line">                sendMsg(handler1!!, <span class="number">100</span>, <span class="keyword">data</span>)</span><br><span class="line">                sendMsg(handler2!!, <span class="number">200</span>, <span class="keyword">data</span>)</span><br><span class="line">                sendMsg(handler3!!, <span class="number">300</span>, <span class="keyword">data</span>)</span><br><span class="line">                sendMsg(handler4!!, <span class="number">400</span>, <span class="keyword">data</span>)</span><br><span class="line">                sendMsg(handler5!!, <span class="number">500</span>, <span class="keyword">data</span>)</span><br><span class="line">                sendMsg(handler6!!, <span class="number">600</span>, <span class="keyword">data</span>)</span><br><span class="line">                sendMsg(handler7!!, <span class="number">700</span>, <span class="keyword">data</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handler() -- R 上已废弃</span></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler5</span></span>(activity: MainActivity) : Handler() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">var</span> activity: WeakReference&lt;MainActivity&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">init</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.activity = WeakReference(activity)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">                Log.d(TAG, <span class="string">"handler5 handleMessage() called with: message = [<span class="variable">$msg</span>]"</span>)</span><br><span class="line">                <span class="keyword">if</span> (activity?.<span class="keyword">get</span>() == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> (msg.what == <span class="number">500</span>) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"handler5 收到消息: <span class="subst">$&#123;msg.obj&#125;</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handler(Looper looper) -- R 上替代 Handler()</span></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler6</span></span>(activity: MainActivity) : Handler(Looper.myLooper()!!) &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">var</span> activity: WeakReference&lt;MainActivity&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">init</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.activity = WeakReference(activity)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">                Log.d(TAG, <span class="string">"handler6 handleMessage() called with: message = [<span class="variable">$msg</span>]"</span>)</span><br><span class="line">                <span class="keyword">if</span> (activity?.<span class="keyword">get</span>() == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> (msg.what == <span class="number">600</span>) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"handler6 收到消息: <span class="subst">$&#123;msg.obj&#125;</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ------------------------ 弱引用 + 静态内部类 (结束)---------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendMsg</span><span class="params">(handler: <span class="type">Handler</span>, what: <span class="type">Int</span>, obj: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"sendMsg() called with: handler = <span class="variable">$handler</span>, what = <span class="variable">$what</span>"</span>)</span><br><span class="line">            <span class="keyword">val</span> message = handler.obtainMessage()</span><br><span class="line">            message.what = what</span><br><span class="line">            message.obj = obj</span><br><span class="line">            handler.sendMessage(message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onBackPressed()</span><br><span class="line">        Log.d(TAG, <span class="string">"onBackPressed() called"</span>)</span><br><span class="line">        finish()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        Log.d(TAG, <span class="string">"onDestroy() called"</span>)</span><br><span class="line">        handler1?.removeCallbacksAndMessages(<span class="literal">null</span>)</span><br><span class="line">        handler2?.removeCallbacksAndMessages(<span class="literal">null</span>)</span><br><span class="line">        handler3?.removeCallbacksAndMessages(<span class="literal">null</span>)</span><br><span class="line">        handler4?.removeCallbacksAndMessages(<span class="literal">null</span>)</span><br><span class="line">        handler5?.removeCallbacksAndMessages(<span class="literal">null</span>)</span><br><span class="line">        handler6?.removeCallbacksAndMessages(<span class="literal">null</span>)</span><br><span class="line">        handler7?.removeCallbacksAndMessages(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h4 id="1-Handler"><a href="#1-Handler" class="headerlink" title="1. Handler"></a>1. Handler</h4><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = new Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void handleMessage(Message msg) &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            </span><br><span class="line">            Toast.makeText(......).show();</span><br><span class="line">            textview.setText(<span class="string">"xxxx"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>Handler允许我们发送延时消息，如果在延时消息未处理完，而此时Handler所在的Activity被关闭，但因为上述Handler用法则可能会导致内存泄漏。那么，在延时消息未处理完时，Handler无法释放外部类MainActivity的对象，从而导致内存泄漏产生。</p><h4 id="2-Runnable"><a href="#2-Runnable" class="headerlink" title="2. Runnable"></a>2. Runnable</h4><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable mRunnable = new Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>该使用方式是创建了一个内部类，内部类隐性持有外部类对象的引用，如果Activity结束，Runnable里面的任务没有处理完，则不会释放Activity的引用，则Activity无法被回收，造成内存泄漏。</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>Looper在android的消息机制充当消息循环的角色，它不停的充MessageQueue中拿出消息，并将消息交给Handler处理。</p><h3 id="prepareMainLooper"><a href="#prepareMainLooper" class="headerlink" title="prepareMainLooper()"></a><del>prepareMainLooper()</del></h3><p>在Android 11/ R中，<strong><code>Looper.prepareMainLooper()</code></strong> <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvb3MvTG9vcGVyI3ByZXBhcmVNYWluTG9vcGVyKCk=" title="https://developer.android.google.cn/reference/android/os/Looper#prepareMainLooper()">已废弃<i class="fa fa-external-link"></i></span></p><p><img alt="prepareMainLooper_deprecated.png" data-src="/images/prepareMainLooper_deprecated.png"></p><p><strong>方法作用</strong> : 将当前线程初始化为循环程序，将其标记为应用程序的主循环程序<br><strong>废弃原因</strong> : 应用程序的主循环程序是由Android环境创建的，因此您无需在自己应用里调用此函数。</p><p>【源码部分】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment">     * application's main looper. See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> The main looper for your application is created by the Android environment,</span></span><br><span class="line"><span class="comment">     *   so you should never need to call this function yourself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ActivityThread是android的主线程，android主线程在创建的时候会在main函数中调用Looper.prepareMainLooper()主动创建一个Looper。</p><p>从上面的信息我们可以知道，prepareMainLooper函数中有调用了Looper的prepare来创建Looper</p><p>在子线程中直接使用Looper.prepare()方法创建，确保在调用这个方法之后调用loop()方法，并使用quit()方法结束</p><p>【源码部分】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment">     * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment">     * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       prepare(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//一个线程中只能有一个Looper</span></span><br><span class="line">       <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//创建Looper</span></span><br><span class="line">       sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在线程中我们可以调用Looper.prepare，这个函数中 sThreadLocal.set()中创建一个Looper，该方法不仅创建了Looper，其实也创建了MessageQueue,以及将Looper将当前线程和Looper关联起来了。</p><p>【源码部分】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Looper的的Loop方法，主要是用来从MessageQueue消息队列里面拿出消息。</p><p>以上就是本文的全部内容，感谢您的阅读</p><blockquote><p>本文基于Android R DP1 post，如有不足, 欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.android.google.cn/reference/android/os/Handle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Handler&lt;/a&gt; 类，相信大家并不陌生，也应当耳熟能详，且铭记于心&lt;br&gt;几乎项目中使用频率较高，同时也是面试时常挂嘴边的必考知识点&lt;/p&gt;
&lt;p&gt;今天我们来谈谈在Android 11/R 上 Handler 相关变化&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android R" scheme="https://shoewann0402.github.io/categories/Android/Android-R/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android R" scheme="https://shoewann0402.github.io/tags/Android-R/"/>
    
      <category term="Handler" scheme="https://shoewann0402.github.io/tags/Handler/"/>
    
      <category term="Looper" scheme="https://shoewann0402.github.io/tags/Looper/"/>
    
      <category term="prepareMainLooper" scheme="https://shoewann0402.github.io/tags/prepareMainLooper/"/>
    
  </entry>
  
  <entry>
    <title>Android 11 (R) 之 AsyncTask 前世今生</title>
    <link href="https://shoewann0402.github.io/2020/03/06/android-R-AsyncTask-deprecated/"/>
    <id>https://shoewann0402.github.io/2020/03/06/android-R-AsyncTask-deprecated/</id>
    <published>2020-03-06T13:31:42.376Z</published>
    <updated>2020-03-06T13:31:42.392Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在过去的十年中，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2tvdGxpbi9hbmRyb2lkL29zL0FzeW5jVGFzaw==" title="https://developer.android.google.cn/reference/kotlin/android/os/AsyncTask">AsyncTask<i class="fa fa-external-link"></i></span>一直是用于在Android中编写并发代码的最广泛使用的解决方案之一<br>但是，从 Android 11 (R) 开始，官方正式弃用, 也标志着<strong>AsyncTask</strong> 的时代正式结束</p></blockquote><p>本文我们一起来回顾它的前世今生</p><hr><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img alt="async_task_deprecated.jpg" data-src="/images/async_task_deprecated.jpg"></p><p><strong>本名</strong>：AsyncTask<br><strong>中文名</strong>：异步任务<br><strong>出生日期</strong>：2009 年 Android 1.5 ( API Level 3 )<br><strong>去世日期</strong>：2020 年 Android 11  ( API Level R )<br><strong>所处位置</strong>：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2tvdGxpbi9hbmRyb2lkL29zL0FzeW5jVGFzaw==" title="https://developer.android.google.cn/reference/kotlin/android/os/AsyncTask">android.os.AsyncTask<i class="fa fa-external-link"></i></span></p><h2 id="前世"><a href="#前世" class="headerlink" title="前世"></a>前世</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2tvdGxpbi9hbmRyb2lkL29zL0FzeW5jVGFzaw==" title="https://developer.android.google.cn/reference/kotlin/android/os/AsyncTask">AsyncTask<i class="fa fa-external-link"></i></span> 是安卓开发中使用的一种轻量级异步任务类。其作用是在线程池中执行后台任务，并在执行过程中将执行进度传递给主线程，当任务执行完毕后，将最终结果传递给主线程。</p><h3 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h3><p>安卓系统线程分为主线程和子线程，主线程也叫UI线程。主线程主要负责与用户交互。为了更好的用户体验，保证系统不因主线程的阻塞而产生卡顿，安卓系统要求主线程中不能执行耗时任务。例如：IO操作、网络请求等必须在子线程中完成。<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2tvdGxpbi9hbmRyb2lkL29zL0FzeW5jVGFzaw==" title="https://developer.android.google.cn/reference/kotlin/android/os/AsyncTask">AsyncTask<i class="fa fa-external-link"></i></span>就是为了适应这种需要而产生。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>直接使用 AsyncTask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AsyncTask.execute &#123;</span><br><span class="line">           Log.d(TAG, &quot;###### AsyncTask execute #####&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p> — java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> &lt; <span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span> &gt;</span></span><br></pre></td></tr></table></figure><p>— kotlin </p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="type">Params : Any!, Progress : Any!, Result : Any!</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AsyncTask是一个泛型抽象类</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Params</td><td>执行后台任务所需参数类型</td></tr><tr><td>Progress</td><td>后台任务执行进度的类型</td></tr><tr><td>Result</td><td>台任务执行完毕后返回结果类型</td></tr></tbody></table><p>并非所有类型都总是由异步任务使用。要将类型标记为未使用，只需使用该类型 Void</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>AsyncTask提供4个核心方法：</p><ol><li><p>protected void <strong>onPreExecute</strong>()</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>执行线程</td><td>主线程</td></tr><tr><td>调用时间</td><td>异步任务执行之前</td></tr><tr><td>方法作用</td><td>异步任务执行前的初始化工作</td></tr></tbody></table></li><li><p>protected Result <strong>doInBackground</strong>(Params…params)</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>执行线程</td><td>线程池中执行</td></tr><tr><td>调用时间</td><td>任务开始后到任务结束之前</td></tr><tr><td>方法作用</td><td>用于执行异步任务</td></tr></tbody></table></li><li><p>protected void <strong>onProgressUpdate</strong>(Prgress…values)</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>执行线程</td><td>主线程</td></tr><tr><td>调用时间</td><td>任务开始后到任务结束之前</td></tr><tr><td>方法作用</td><td>用于更新任务进度</td></tr></tbody></table></li><li><p>protected void <strong>onPostExecute</strong>(Result result)</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>执行线程</td><td>主线程</td></tr><tr><td>调用时间</td><td>异步任务执行之后</td></tr><tr><td>方法作用</td><td>将异步任务的执行结果传递给主线程</td></tr></tbody></table></li></ol><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFilesTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">URL</span>, <span class="title">Integer</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> Long <span class="title">doInBackground</span><span class="params">(URL... urls)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = urls.length;</span><br><span class="line">         <span class="keyword">long</span> totalSize = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">             totalSize += Downloader.downloadFile(urls[i]);</span><br><span class="line">             publishProgress((<span class="keyword">int</span>) ((i / (<span class="keyword">float</span>) count) * <span class="number">100</span>));</span><br><span class="line">             <span class="comment">// Escape early if cancel() is called</span></span><br><span class="line">             <span class="keyword">if</span> (isCancelled()) <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> totalSize;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... progress)</span> </span>&#123;</span><br><span class="line">         setProgressPercent(progress[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Long result)</span> </span>&#123;</span><br><span class="line">         showDialog(<span class="string">"Downloaded "</span> + result + <span class="string">" bytes"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>DownloadFilesTask类模拟文件下载过程。传入的参数Params类型为URL(文件地址)，后台任务进程参数Progress类型为Integer(下载进度)，后台任务返回结果参数Result类型为Long(总文件大小)。</p><p>创建完成后，任务将非常简单地执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> DownloadFilesTask().execute(url1, url2, url3);</span><br></pre></td></tr></table></figure><h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><p>可以通过调用cancel（boolean）随时取消任务。 调用此方法将导致对isCancelled（）的后续调用返回true。 调用此方法后，在doInBackground（java.lang.Object []）返回之后，将调用onCancelled（java.lang.Object）而不是onPostExecute（java.lang.Object）。 为了确保尽快取消任务，如果可能的话（例如在循环内），应始终定期从doInBackground（java.lang.Object []）检查isCancelled（）的返回值。</p><h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><ol><li>AsyncTask类必须在主线程加载</li><li>AsyncTask对象必须在主线程创建</li><li>execute方法必须在主线程调用</li><li>不要在程序中直接调用AsyncTask提供的4个核心方法</li><li>一个AsyncTask对象只能执行一次，即只能调用一次execute</li></ol><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>问题描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This AsyncTask class should be static or leaks might occur (anonymous android.os.AsyncTask) less... (Ctrl+F1) </span><br><span class="line">A static field will leak contexts.  Non-static inner classes have an implicit reference to their outer class. If that outer class is for example a Fragment or Activity, then this reference means that the long-running handler/loader/task will hold a reference to the activity which prevents it from getting garbage collected.  Similarly, direct field references to activities and fragments from these longer running instances can cause leaks.  ViewModel classes should never point to Views or non-application Contexts</span><br></pre></td></tr></table></figure><p>解决方法 ： 静态内部类+弱引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;MyActivity&gt; activityReference;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只保留一个弱引用到Activity</span></span><br><span class="line">        MyTask(MyActivity context) &#123;</span><br><span class="line">            activityReference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"task finished"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//获取Activity的引用（如果仍存在）</span></span><br><span class="line">            MyActivity activity = activityReference.get();</span><br><span class="line">            <span class="keyword">if</span> (activity == <span class="keyword">null</span> || activity.isFinishing()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 验证Activity的UI</span></span><br><span class="line">            TextView textView = activity.findViewById(R.id.textview);</span><br><span class="line">            textView.setText(result);</span><br><span class="line">            <span class="comment">// 访问Activity成员变量</span></span><br><span class="line">            activity.mSomeMemberVariable = <span class="number">321</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="今生"><a href="#今生" class="headerlink" title="今生"></a>今生</h2><p><img alt="android_kotlin-1.jpg.png" data-src="/images/android_kotlin-1.jpg"></p><p>abstract class <del>AsyncTask</del> &lt; Params : Any!, Progress : Any!, Result : Any! &gt;</p><blockquote><p>这个类在API level R 被弃用<br>请使用标准的<strong>java.util.concurrent</strong>或<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9jb3JvdXRpbmVz" title="https://developer.android.google.cn/topic/libraries/architecture/coroutines">Kotlin并发实用程序<i class="fa fa-external-link"></i></span>代替。</p></blockquote><h3 id="弃用原因"><a href="#弃用原因" class="headerlink" title="弃用原因"></a>弃用原因</h3><p><img alt="asynctask-r-aosp.png" data-src="/images/asynctask-r-aosp.png"></p><blockquote><p>AsyncTask旨在启用和轻松使用UI线程。但是，最常见的用例是集成到UI中，这会导致Context泄漏，丢失的回调或配置更改崩溃。它还在平台的不同版本上具有不一致的行为，吞噬的异常doInBackground，并且不能提供比<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2tvdGxpbi9qYXZhL3V0aWwvY29uY3VycmVudC9FeGVjdXRvci5odG1s" title="https://developer.android.google.cn/reference/kotlin/java/util/concurrent/Executor.html">Executor<i class="fa fa-external-link"></i></span>直接使用更多的实用程序。</p></blockquote><p>AsyncTask是为围绕<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2tvdGxpbi9qYXZhL2xhbmcvVGhyZWFkLmh0bWw=" title="https://developer.android.google.cn/reference/kotlin/java/lang/Thread.html">Thread<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2tvdGxpbi9hbmRyb2lkL29zL0hhbmRsZXI=" title="https://developer.android.google.cn/reference/kotlin/android/os/Handler">Handler<i class="fa fa-external-link"></i></span>的帮助器类而被设计出来的，并且不构成通用的线程框架。理想情况下，应将AsyncTasks用于较短的操作（最多几秒钟）。如果需要使线程长时间运行，则强烈建议您使用<strong>java.util.concurrent</strong>包提供的各种API，例如 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2tvdGxpbi9qYXZhL3V0aWwvY29uY3VycmVudC9FeGVjdXRvci5odG1s" title="https://developer.android.google.cn/reference/kotlin/java/util/concurrent/Executor.html">Executor<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2tvdGxpbi9qYXZhL3V0aWwvY29uY3VycmVudC9UaHJlYWRQb29sRXhlY3V0b3IuaHRtbA==" title="https://developer.android.google.cn/reference/kotlin/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2tvdGxpbi9qYXZhL3V0aWwvY29uY3VycmVudC9GdXR1cmVUYXNrLmh0bWw=" title="https://developer.android.google.cn/reference/kotlin/java/util/concurrent/FutureTask.html">FutureTask<i class="fa fa-external-link"></i></span>。</p><h3 id="代替示例"><a href="#代替示例" class="headerlink" title="代替示例"></a>代替示例</h3><h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------- 示例1 ----------------------</span></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> : <span class="type">Executor &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(runnable: <span class="type">Runnable</span>?)</span></span> &#123;</span><br><span class="line">        runnable?.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">val</span> directExecutor = DirectExecutor()</span><br><span class="line">   directExecutor.execute &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"###### DirectExecutor execute ##### "</span>)</span><br><span class="line">            .........</span><br><span class="line">            .........</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//----------- 示例2 ----------------------</span></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> : <span class="type">Executor &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(runnable: <span class="type">Runnable</span>?)</span></span> &#123;</span><br><span class="line">            Thread(runnable).start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">val</span> threadPerTaskExecutor = ThreadPerTaskExecutor()</span><br><span class="line">    threadPerTaskExecutor.execute &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"###### threadPerTaskExecutor execute #####"</span>)</span><br><span class="line">        .........</span><br><span class="line">        .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程池大小 --&gt; 即需要开启多少个线程</span></span><br><span class="line"><span class="keyword">val</span> coreThreadPoolSize = Runtime.getRuntime().availableProcessors() <span class="comment">//系统有多少可用就开多少</span></span><br><span class="line"><span class="comment">//最大线程池大小</span></span><br><span class="line"><span class="keyword">val</span> maximumPoolSize = <span class="number">15</span></span><br><span class="line"><span class="comment">//线程最大空闲时间</span></span><br><span class="line"><span class="comment">//线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)使得核心线程  有效时间</span></span><br><span class="line"><span class="keyword">val</span> keepAliveTime = <span class="number">120L</span></span><br><span class="line"><span class="comment">//keepAliveTime时间单位</span></span><br><span class="line"><span class="keyword">val</span> unit = TimeUnit.SECONDS</span><br><span class="line"><span class="comment">//定义阻塞式列队</span></span><br><span class="line"><span class="keyword">val</span> workQueue = ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">val</span> executor = ThreadPoolExecutor(coreThreadPoolSize,</span><br><span class="line">               maximumPoolSize, keepAliveTime, unit, workQueue</span><br><span class="line">       )</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span>) &#123;</span><br><span class="line">       executor.execute &#123;</span><br><span class="line">           Log.d(TAG, <span class="string">"线程池中线程数目："</span>+executor.poolSize +<span class="string">"，队列中等待执行的任务数目："</span>+</span><br><span class="line">                   executor.queue.size +<span class="string">"，已执行完成的任务数目："</span>+executor.completedTaskCount)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown()</span><br></pre></td></tr></table></figure><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> service = Executors.newSingleThreadExecutor()</span><br><span class="line"><span class="keyword">val</span> futureTask = FutureTask(Callable &#123; ......... &#125;)</span><br><span class="line">service.execute(futureTask)</span><br><span class="line">Log.d(TAG, <span class="string">"###### futureTask execute #####  <span class="subst">$&#123;futureTask.get()&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h4 id="Kotlin并发-协程-实用程序"><a href="#Kotlin并发-协程-实用程序" class="headerlink" title="Kotlin并发(协程)实用程序"></a>Kotlin并发(协程)实用程序</h4><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义耗时操作的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">spendLongTimeAction</span><span class="params">()</span></span> : String&#123;</span><br><span class="line">    <span class="comment">//模拟网络请求,耗时5s</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is a json data from web server"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="comment">//使用给定的协程上下文调用指定的暂停块，暂停直到完成，然后返回结果。</span></span><br><span class="line">    withContext(Dispatchers.Main)&#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = spendLongTimeAction()</span><br><span class="line">        textView.text = <span class="keyword">data</span></span><br><span class="line">        Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>,<span class="string">"数据请求成功"</span>,Toast.LENGTH_LONG).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关文献"><a href="#相关文献" class="headerlink" title="相关文献"></a>相关文献</h2><ol><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vc2RrL2FwaV9kaWZmL3ItZHAxL2NoYW5nZXMvYW5kcm9pZC5vcy5Bc3luY1Rhc2sjYW5kcm9pZC5vcy5Bc3luY1Rhc2suY3Rvcl9jaGFuZ2VkKCk=" title="https://developer.android.google.cn/sdk/api_diff/r-dp1/changes/android.os.AsyncTask#android.os.AsyncTask.ctor_changed()">API Differences between 29 and rdp1<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVjaHlvdXJjaGFuY2UuY29tL2FzeW5jdGFzay1kZXByZWNhdGVkLw==" title="https://www.techyourchance.com/asynctask-deprecated/">AsyncTask is Deprecated, Now What?<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9oZWFydGJlYXQuZnJpdHouYWkvcmVwbGFjaW5nLWFzeW5jdGFzay1pbi1hbmRyb2lkLXdpdGgta290bGluLWNvcm91dGluZXMtdG8taGFuZGxlLWJhY2tncm91bmQtdGFza3MtOTMxMDhmOGYyZGI=" title="https://heartbeat.fritz.ai/replacing-asynctask-in-android-with-kotlin-coroutines-to-handle-background-tasks-93108f8f2db">Deprecating AsyncTask in Android with Kotlin Coroutines<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BwcmF0aWsua3VtYWFyL2dvb2dsZS1kZXByZWNpYXRlZC1hc3luY3Rhc2stZnJvbS1hbmRyb2lkLTExLWExMzFiN2QwZThkMQ==" title="https://medium.com/@pratik.kumaar/google-depreciated-asynctask-from-android-11-a131b7d0e8d1">Google depreciated AsyncTask from Android 11<i class="fa fa-external-link"></i></span></li></ol><p>以上就是本文对AsyncTask的简单回顾总结</p><blockquote><p>本文发布于Android 11 / R DP 1 。如有不足，欢迎指正 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在过去的十年中，&lt;a href=&quot;https://developer.android.google.cn/reference/kotlin/android/os/AsyncTask&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AsyncTask&lt;/a&gt;一直是用于在Android中编写并发代码的最广泛使用的解决方案之一&lt;br&gt;但是，从 Android 11 (R) 开始，官方正式弃用, 也标志着&lt;strong&gt;AsyncTask&lt;/strong&gt; 的时代正式结束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文我们一起来回顾它的前世今生&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android R" scheme="https://shoewann0402.github.io/categories/Android/Android-R/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android R" scheme="https://shoewann0402.github.io/tags/Android-R/"/>
    
      <category term="AsycnTask" scheme="https://shoewann0402.github.io/tags/AsycnTask/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 检查网络连通性</title>
    <link href="https://shoewann0402.github.io/2019/08/14/android-q-network-connectivity-check/"/>
    <id>https://shoewann0402.github.io/2019/08/14/android-q-network-connectivity-check/</id>
    <published>2019-08-13T17:58:20.000Z</published>
    <updated>2019-08-13T18:30:16.423Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对Android Q 上检查网络连通性的相关记录</p></blockquote><hr><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大多数情况下，我们从ConnectivityManager获取活动的网络信息，并检查该网络是否已经连接</p><p>像这样</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isNetworkConnected</span><span class="params">(context: <span class="type">Context</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mConnectivityManager = context?.getSystemService(Context.CONNECTIVITY_SERVICE) <span class="keyword">as</span> ConnectivityManager</span><br><span class="line">    <span class="keyword">val</span> mNetworkInfo = mConnectivityManager.activeNetworkInfo</span><br><span class="line">    <span class="keyword">return</span> mNetworkInfo!=<span class="literal">null</span> &amp;&amp; mNetworkInfo.isConnected</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在Android Q (API 29) 上，从<strong>ConnectivityManager</strong>类里<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvbmV0L0Nvbm5lY3Rpdml0eU1hbmFnZXIuaHRtbCNnZXRBY3RpdmVOZXR3b3JrSW5mbygp" title="https://developer.android.google.cn/reference/android/net/ConnectivityManager.html#getActiveNetworkInfo()">废弃<i class="fa fa-external-link"></i></span>了<strong>activeNetworkInfo</strong>方法(Java对应<strong>getActiveNetworkInfo()</strong>方法)。</p><h2 id="Android-Q"><a href="#Android-Q" class="headerlink" title="Android Q"></a>Android Q</h2><p>查询相关文档，可以找到另一种方法</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isNetworkConnectedWithQ</span><span class="params">(context: <span class="type">Context</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> hasNetwork = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> mConnectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) <span class="keyword">as</span> ConnectivityManager</span><br><span class="line">                <span class="keyword">val</span> networks = mConnectivityManager.allNetworks</span><br><span class="line">                <span class="keyword">if</span> (networks.isNotEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (network <span class="keyword">in</span> networks) &#123;</span><br><span class="line">                        <span class="keyword">val</span> nc = mConnectivityManager.getNetworkCapabilities(network)</span><br><span class="line">                        <span class="keyword">if</span> (nc!!.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) &#123;</span><br><span class="line">                            hasNetwork = <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> hasNetwork </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意：以上代码中<strong>allNetworks</strong>、<strong>getNetworkCapabilities</strong>和<strong>hasCapability</strong>都是在API 21 (Lollipop)被添加的，也就是说最低版本需要21。对此，这里为了兼容到21版本以下，可以将两种方式合并到一个方法中，同时兼容。</p><h2 id="同时兼容"><a href="#同时兼容" class="headerlink" title="同时兼容"></a>同时兼容</h2><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isNetworkConnected</span><span class="params">(context: <span class="type">Context</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> mConnectivityManager = context?.getSystemService(Context.CONNECTIVITY_SERVICE) <span class="keyword">as</span> ConnectivityManager</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT&lt;Build.VERSION_CODES.Q)&#123;</span><br><span class="line">                <span class="keyword">val</span> mNetworkInfo = mConnectivityManager.activeNetworkInfo</span><br><span class="line">                <span class="keyword">return</span> mNetworkInfo!=<span class="literal">null</span> &amp;&amp; mNetworkInfo.isConnected</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> hasNetwork = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> networks = mConnectivityManager.allNetworks</span><br><span class="line">            <span class="keyword">if</span> (networks.isNotEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (network <span class="keyword">in</span> networks) &#123;</span><br><span class="line">                    <span class="keyword">val</span> nc = mConnectivityManager.getNetworkCapabilities(network)</span><br><span class="line">                    <span class="keyword">if</span> (nc!!.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) &#123;</span><br><span class="line">                        hasNetwork = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> hasNetwork</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>最后，不要忘记在清单文件添加网络权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>以上就是针对Android Q上网络检查方式的一个简单的记录，如有不足，欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对Android Q 上检查网络连通性的相关记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="NetWork" scheme="https://shoewann0402.github.io/tags/NetWork/"/>
    
      <category term="ConnectivityManager" scheme="https://shoewann0402.github.io/tags/ConnectivityManager/"/>
    
  </entry>
  
  <entry>
    <title>Android Q Beta 6 存储示例</title>
    <link href="https://shoewann0402.github.io/2019/08/13/android-q-beta6-storage-sample-record/"/>
    <id>https://shoewann0402.github.io/2019/08/13/android-q-beta6-storage-sample-record/</id>
    <published>2019-08-12T16:08:11.000Z</published>
    <updated>2019-08-12T18:14:40.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对 Android Q Beta 6 版本上的存储示例，进行一次测试分析并记录</p></blockquote><hr><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>官方给出: Android Q 会继续使用 READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE 权限，这些权限与面向用户的存储运行时权限相对应。不过，默认情况下，以 Android Q 为目标平台的应用（以及选择接受这些变更的应用）在访问外部存储设备中的文件时会进入过滤视图。此类应用只能查看特定于应用的目录和特定类型的媒体，因此应用无需请求任何其他用户权限。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p><strong>编译环境</strong>：Ubuntu 19.04 、Android Studio 3.4.2、compileSdkVersion 29、buildToolsVersion “29.0.1”、 targetSdkVersion 29<br><strong>运行环境</strong>：Pixel 2 、Android Version 10 (QPP6.190730.005) 、API 29</p></blockquote><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>界面上有两个按钮，一个写入内容到文件存储，一个是从存储读取文件内容</p><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><h3 id="类别-1-传统目录方式"><a href="#类别-1-传统目录方式" class="headerlink" title="类别 1 传统目录方式"></a>类别 1 传统目录方式</h3><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 写文件的方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">val</span> file = File(Environment.getExternalStorageDirectory(), <span class="string">"测试Android Q文件.txt"</span>)</span><br><span class="line">     Log.d(tag, <span class="string">"file.exists():<span class="subst">$&#123;file.exists()&#125;</span> ， file.getAbsolutePath(): <span class="subst">$&#123;file.absolutePath&#125;</span>"</span>)</span><br><span class="line">     <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">         file.delete()</span><br><span class="line">         <span class="keyword">val</span> flag  = file.createNewFile()</span><br><span class="line">         Log.d(tag, <span class="string">"SD卡目录下创建文件是否成功？:<span class="variable">$flag</span>"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">val</span> fw = FileWriter(file)</span><br><span class="line">     fw.write(<span class="string">"我是测试Android Q文件写入的内容"</span>);</span><br><span class="line">     fw.close()</span><br><span class="line">     Toast.makeText(<span class="keyword">this</span><span class="symbol">@StorageActivity</span>, <span class="string">"SD卡写入内容完成..."</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">     Log.d(tag, <span class="string">"SD卡写入内容完成..."</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 读文件的方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">val</span> fr = FileReader(Environment.getExternalStorageDirectory().path+<span class="string">"/测试Android Q文件.txt"</span>)</span><br><span class="line">     <span class="keyword">val</span> r = BufferedReader(fr)</span><br><span class="line">     <span class="keyword">val</span> result = r.readLine()</span><br><span class="line">     Log.d(tag, <span class="string">"SD卡文件里面的内容:<span class="variable">$result</span>"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="不加读写权限"><a href="#不加读写权限" class="headerlink" title="不加读写权限"></a>不加读写权限</h4><p>清单文件不添加如下权限，也没有动态请求代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>失败，程序异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">2019-08-13 00:42:47.945 9976-9976/com.xw.androidqtest D/StorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/测试Android Q文件.txt</span><br><span class="line">2019-08-13 00:42:47.947 9976-9976/com.xw.androidqtest D/AndroidRuntime: Shutting down VM</span><br><span class="line">2019-08-13 00:42:47.951 9976-9976/com.xw.androidqtest E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.xw.androidqtest, PID: 9976</span><br><span class="line">    java.lang.RuntimeException: java.lang.reflect.InvocationTargetException</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:502)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)</span><br><span class="line">     Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) </span><br><span class="line">     Caused by: java.io.FileNotFoundException: /storage/emulated/0/测试Android Q文件.txt: open failed: EACCES (Permission denied)</span><br><span class="line">        at libcore.io.IoBridge.open(IoBridge.java:496)</span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235)</span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186)</span><br><span class="line">        at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90)</span><br><span class="line">        at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79)</span><br><span class="line">        at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21)</span><br><span class="line">        at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31)</span><br><span class="line">        at android.view.View.performClick(View.java:7140)</span><br><span class="line">        at android.view.View.performClickInternal(View.java:7117)</span><br><span class="line">        at android.view.View.access$3500(View.java:801)</span><br><span class="line">        at android.view.View$PerformClick.run(View.java:27351)</span><br><span class="line">        at android.os.Handler.handleCallback(Handler.java:883)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:100)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:214)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:7356)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) </span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) </span><br><span class="line">     Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied)</span><br><span class="line">        at libcore.io.Linux.open(Native Method)</span><br><span class="line">        at libcore.io.ForwardingOs.open(ForwardingOs.java:167)</span><br><span class="line">        at libcore.io.BlockGuardOs.open(BlockGuardOs.java:252)</span><br><span class="line">        at libcore.io.ForwardingOs.open(ForwardingOs.java:167)</span><br><span class="line">        at android.app.ActivityThread$AndroidOs.open(ActivityThread.java:7255)</span><br><span class="line">        at libcore.io.IoBridge.open(IoBridge.java:482)</span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235) </span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186) </span><br><span class="line">        at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90) </span><br><span class="line">        at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79) </span><br><span class="line">        at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21) </span><br><span class="line">        at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31) </span><br><span class="line">        at android.view.View.performClick(View.java:7140) </span><br><span class="line">        at android.view.View.performClickInternal(View.java:7117) </span><br><span class="line">        at android.view.View.access$3500(View.java:801) </span><br><span class="line">        at android.view.View$PerformClick.run(View.java:27351) </span><br><span class="line">        at android.os.Handler.handleCallback(Handler.java:883) </span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:100) </span><br><span class="line">        at android.os.Looper.loop(Looper.java:214) </span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:7356) </span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) </span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)</span><br></pre></td></tr></table></figure><h4 id="加读写权限但不动态请求"><a href="#加读写权限但不动态请求" class="headerlink" title="加读写权限但不动态请求"></a>加读写权限但不动态请求</h4><p>清单文件添加如下权限，但不动态请求</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>失败，程序异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">2019-08-13 00:47:52.759 11693-11693/com.xw.androidqtest D/StorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/测试Android Q文件.txt</span><br><span class="line">2019-08-13 00:47:52.761 11693-11693/com.xw.androidqtest D/AndroidRuntime: Shutting down VM</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    --------- beginning of crash</span><br><span class="line">2019-08-13 00:47:52.766 11693-11693/com.xw.androidqtest E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.xw.androidqtest, PID: 11693</span><br><span class="line">    java.lang.RuntimeException: java.lang.reflect.InvocationTargetException</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:502)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)</span><br><span class="line">     Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) </span><br><span class="line">     Caused by: java.io.FileNotFoundException: /storage/emulated/0/测试Android Q文件.txt: open failed: EACCES (Permission denied)</span><br><span class="line">        at libcore.io.IoBridge.open(IoBridge.java:496)</span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235)</span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186)</span><br><span class="line">        at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90)</span><br><span class="line">        at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79)</span><br><span class="line">        at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21)</span><br><span class="line">        at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31)</span><br><span class="line">        at android.view.View.performClick(View.java:7140)</span><br><span class="line">        at android.view.View.performClickInternal(View.java:7117)</span><br><span class="line">        at android.view.View.access$3500(View.java:801)</span><br><span class="line">        at android.view.View$PerformClick.run(View.java:27351)</span><br><span class="line">        at android.os.Handler.handleCallback(Handler.java:883)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:100)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:214)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:7356)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) </span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) </span><br><span class="line">     Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied)</span><br><span class="line">        at libcore.io.Linux.open(Native Method)</span><br><span class="line">        at libcore.io.ForwardingOs.open(ForwardingOs.java:167)</span><br><span class="line">        at libcore.io.BlockGuardOs.open(BlockGuardOs.java:252)</span><br><span class="line">        at libcore.io.ForwardingOs.open(ForwardingOs.java:167)</span><br><span class="line">        at android.app.ActivityThread$AndroidOs.open(ActivityThread.java:7255)</span><br><span class="line">        at libcore.io.IoBridge.open(IoBridge.java:482)</span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235) </span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186) </span><br><span class="line">        at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90) </span><br><span class="line">        at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79) </span><br><span class="line">        at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21) </span><br><span class="line">        at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31) </span><br><span class="line">        at android.view.View.performClick(View.java:7140) </span><br><span class="line">        at android.view.View.performClickInternal(View.java:7117) </span><br><span class="line">        at android.view.View.access$3500(View.java:801) </span><br><span class="line">        at android.view.View$PerformClick.run(View.java:27351) </span><br><span class="line">        at android.os.Handler.handleCallback(Handler.java:883) </span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:100) </span><br><span class="line">        at android.os.Looper.loop(Looper.java:214) </span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:7356) </span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) </span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)</span><br></pre></td></tr></table></figure><h4 id="加读写权限但并动态请求"><a href="#加读写权限但并动态请求" class="headerlink" title="加读写权限但并动态请求"></a>加读写权限但并动态请求</h4><p>清单文件添加如下权限，并动态请求</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initPermission</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="comment">// 检查权限状态</span></span><br><span class="line">                <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123;</span><br><span class="line">                    <span class="comment">//  用户彻底拒绝授予权限</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//  用户未彻底拒绝授予权限</span></span><br><span class="line">                    ActivityCompat.requestPermissions(<span class="keyword">this</span>, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(requestCode: <span class="type">Int</span>, permissions: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;, grantResults: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        <span class="keyword">if</span> (requestCode == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> permissions.indices) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grantResults[i] == PERMISSION_GRANTED) &#123;</span><br><span class="line">                    <span class="comment">// 申请成功</span></span><br><span class="line">                    Log.d(tag,<span class="string">"申请成功"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 申请失败</span></span><br><span class="line">                    Log.d(tag,<span class="string">"申请失败"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>失败，程序异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">2019-08-13 00:53:45.690 13471-13471/com.xw.androidqtest D/StorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/测试Android Q文件.txt</span><br><span class="line">2019-08-13 00:53:45.692 13471-13471/com.xw.androidqtest D/AndroidRuntime: Shutting down VM</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    --------- beginning of crash</span><br><span class="line">2019-08-13 00:53:45.698 13471-13471/com.xw.androidqtest E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.xw.androidqtest, PID: 13471</span><br><span class="line">    java.lang.RuntimeException: java.lang.reflect.InvocationTargetException</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:502)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)</span><br><span class="line">     Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) </span><br><span class="line">     Caused by: java.io.FileNotFoundException: /storage/emulated/0/测试Android Q文件.txt: open failed: EACCES (Permission denied)</span><br><span class="line">        at libcore.io.IoBridge.open(IoBridge.java:496)</span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235)</span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186)</span><br><span class="line">        at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90)</span><br><span class="line">        at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79)</span><br><span class="line">        at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21)</span><br><span class="line">        at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31)</span><br><span class="line">        at android.view.View.performClick(View.java:7140)</span><br><span class="line">        at android.view.View.performClickInternal(View.java:7117)</span><br><span class="line">        at android.view.View.access$3500(View.java:801)</span><br><span class="line">        at android.view.View$PerformClick.run(View.java:27351)</span><br><span class="line">        at android.os.Handler.handleCallback(Handler.java:883)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:100)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:214)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:7356)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) </span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) </span><br><span class="line">     Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied)</span><br><span class="line">        at libcore.io.Linux.open(Native Method)</span><br><span class="line">        at libcore.io.ForwardingOs.open(ForwardingOs.java:167)</span><br><span class="line">        at libcore.io.BlockGuardOs.open(BlockGuardOs.java:252)</span><br><span class="line">        at libcore.io.ForwardingOs.open(ForwardingOs.java:167)</span><br><span class="line">        at android.app.ActivityThread$AndroidOs.open(ActivityThread.java:7255)</span><br><span class="line">        at libcore.io.IoBridge.open(IoBridge.java:482)</span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235) </span><br><span class="line">        at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186) </span><br><span class="line">        at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90) </span><br><span class="line">        at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79) </span><br><span class="line">        at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21) </span><br><span class="line">        at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31) </span><br><span class="line">        at android.view.View.performClick(View.java:7140) </span><br><span class="line">        at android.view.View.performClickInternal(View.java:7117) </span><br><span class="line">        at android.view.View.access$3500(View.java:801) </span><br><span class="line">        at android.view.View$PerformClick.run(View.java:27351) </span><br><span class="line">        at android.os.Handler.handleCallback(Handler.java:883) </span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:100) </span><br><span class="line">        at android.os.Looper.loop(Looper.java:214) </span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:7356) </span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) </span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)</span><br></pre></td></tr></table></figure><h3 id="类别-2-特定目录方式"><a href="#类别-2-特定目录方式" class="headerlink" title="类别 2 特定目录方式"></a>类别 2 特定目录方式</h3><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 写文件的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//这里我们创建的是一个文本txt,getExternalFilesDir使用Environment.DIRECTORY_DOCUMENTS类型</span></span><br><span class="line">       <span class="keyword">val</span> file = File(<span class="keyword">this</span><span class="symbol">@StorageActivity</span>.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), <span class="string">"测试Android Q文件.txt"</span>)</span><br><span class="line">       Log.d(tag, <span class="string">"file.exists():<span class="subst">$&#123;file.exists()&#125;</span> ， file.getAbsolutePath(): <span class="subst">$&#123;file.absolutePath&#125;</span>"</span>)</span><br><span class="line">       <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">           file.delete()</span><br><span class="line">           <span class="keyword">val</span> flag  = file.createNewFile()</span><br><span class="line">           Log.d(tag, <span class="string">"SD卡目录下创建文件是否成功？:<span class="variable">$flag</span>"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">val</span> fw = FileWriter(file)</span><br><span class="line">       fw.write(<span class="string">"我是测试Android Q文件写入的内容"</span>);</span><br><span class="line">       fw.close()</span><br><span class="line">       Toast.makeText(<span class="keyword">this</span><span class="symbol">@StorageActivity</span>, <span class="string">"SD卡写入内容完成..."</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">       Log.d(tag, <span class="string">"SD卡写入内容完成..."</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读文件的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//这里我们创建的是一个文本txt,getExternalFilesDir使用Environment.DIRECTORY_DOCUMENTS类型</span></span><br><span class="line">       <span class="keyword">val</span> fr = FileReader(<span class="keyword">this</span><span class="symbol">@StorageActivity</span>.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS)!!.path+<span class="string">"/测试Android Q文件.txt"</span>)</span><br><span class="line">       <span class="keyword">val</span> r = BufferedReader(fr)</span><br><span class="line">       <span class="keyword">val</span> result = r.readLine()</span><br><span class="line">       Log.d(tag, <span class="string">"SD卡文件里面的内容:<span class="variable">$result</span>"</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="不加读写权限-1"><a href="#不加读写权限-1" class="headerlink" title="不加读写权限"></a>不加读写权限</h4><p>清单文件不添加如下权限，也没有动态请求代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>成功，程序正常运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-08-13 01:01:40.653 14721-14721/com.xw.androidqtest D/StorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/Android/data/com.xw.androidqtest/files/Documents/测试Android Q文件.txt</span><br><span class="line">2019-08-13 01:01:40.671 14721-14721/com.xw.androidqtest D/StorageActivity: SD卡写入内容完成...</span><br><span class="line">2019-08-13 01:01:54.410 14721-14721/com.xw.androidqtest D/StorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容</span><br></pre></td></tr></table></figure><p>查看设备上应用详情的相关权限模块，并没有相应的权限请求</p><h4 id="加读写权限但不动态请求-1"><a href="#加读写权限但不动态请求-1" class="headerlink" title="加读写权限但不动态请求"></a>加读写权限但不动态请求</h4><p>清单文件添加如下权限，但不动态请求</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>成功，程序正常运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-08-13 01:12:22.104 18040-18040/com.xw.androidqtest D/StorageActivity: file.exists():true ， file.getAbsolutePath(): /storage/emulated/0/Android/data/com.xw.androidqtest/files/Documents/测试Android Q文件.txt</span><br><span class="line">2019-08-13 01:12:22.105 18040-18040/com.xw.androidqtest D/StorageActivity: SD卡目录下创建文件是否成功？:true</span><br><span class="line">2019-08-13 01:12:22.116 18040-18040/com.xw.androidqtest D/StorageActivity: SD卡写入内容完成...</span><br><span class="line">2019-08-13 01:12:26.276 18040-18040/com.xw.androidqtest D/StorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容</span><br></pre></td></tr></table></figure><p>查看设备上应用详情的相关权限模块，有相应的存储权限请求，为拒绝状态</p><h4 id="加读写权限但并动态请求-1"><a href="#加读写权限但并动态请求-1" class="headerlink" title="加读写权限但并动态请求"></a>加读写权限但并动态请求</h4><p>清单文件添加如下权限，并动态请求</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initPermission</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="comment">// 检查权限状态</span></span><br><span class="line">                <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123;</span><br><span class="line">                    <span class="comment">//  用户彻底拒绝授予权限</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//  用户未彻底拒绝授予权限</span></span><br><span class="line">                    ActivityCompat.requestPermissions(<span class="keyword">this</span>, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(requestCode: <span class="type">Int</span>, permissions: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;, grantResults: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        <span class="keyword">if</span> (requestCode == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> permissions.indices) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grantResults[i] == PERMISSION_GRANTED) &#123;</span><br><span class="line">                    <span class="comment">// 申请成功</span></span><br><span class="line">                    Log.d(tag,<span class="string">"申请成功"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 申请失败</span></span><br><span class="line">                    Log.d(tag,<span class="string">"申请失败"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>成功，程序正常运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-08-13 01:16:06.530 19535-19535/com.xw.androidqtest D/StorageActivity: 申请成功</span><br><span class="line">2019-08-13 01:16:09.301 19535-19535/com.xw.androidqtest D/StorageActivity: file.exists():true ， file.getAbsolutePath(): /storage/emulated/0/Android/data/com.xw.androidqtest/files/Documents/测试Android Q文件.txt</span><br><span class="line">2019-08-13 01:16:09.303 19535-19535/com.xw.androidqtest D/StorageActivity: SD卡目录下创建文件是否成功？:true</span><br><span class="line">2019-08-13 01:16:09.316 19535-19535/com.xw.androidqtest D/StorageActivity: SD卡写入内容完成...</span><br><span class="line">2019-08-13 01:16:12.023 19535-19535/com.xw.androidqtest D/StorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容</span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>1.Android Q 如果调用Environment.getExternalStorageDirectory()，需要添加READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE权限，并动态请求权限，同时还需要添加新的清单属性为<strong>requestLegacyExternalStorage</strong>,否则会出现类别1的测试结果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- This attribute is "false" by default on apps targeting Android Q. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:requestLegacyExternalStorage</span>=<span class="string">"true"</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样添加完成之后，getExternalStorageDirectory方式就能执行成功了。</p><p>2、Android Q 如果调用Environment.getExternalFilesDir()。正如官方所言，默认情况下，以 Android Q 为目标平台的应用（以及选择接受这些变更的应用）在访问外部存储设备中的文件时会进入过滤视图。此类应用只能查看特定于应用的目录和特定类型的媒体，因此应用无需请求任何其他用户权限。（类别2测试示例体现）</p><blockquote><p>以上内容简单的对Android Q 存储方式进行简单的示例说明。如果有不足之处，欢迎指正。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对 Android Q Beta 6 版本上的存储示例，进行一次测试分析并记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="Storage" scheme="https://shoewann0402.github.io/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 气泡</title>
    <link href="https://shoewann0402.github.io/2019/04/07/android-q-beta2-bubbles/"/>
    <id>https://shoewann0402.github.io/2019/04/07/android-q-beta2-bubbles/</id>
    <published>2019-04-07T08:26:47.000Z</published>
    <updated>2019-07-19T16:41:32.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节内容测试Android Q新功能 —— 气泡</p></blockquote><hr><a id="more"></a><blockquote><p><em>当前文章首次编辑于Android Q Beta 2 版本，可能部分内容会在后期版本上发生变化，仅供参考</em></p></blockquote><p>气泡是Android Q中的一项新功能。通过气泡，用户可以轻松地从设备上的任何位置进行多任务处理。 气泡内置于通知系统中。 它们会浮动在其他应用内容之上，并随时随地关注用户。 可以扩展气泡以显示应用程序功能和信息，并且可以在不使用时折叠。</p><p>当设备被锁定或始终显示处于活动状态时，气泡就会像通常那样出现。</p><p>气泡是一种选择退出功能。 当应用程序显示其第一个气泡时，会显示一个权限对话框，提供两个选项：</p><blockquote><p>1.阻止您应用中的所有气泡 - 通知不会被阻止，但它们永远不会显示为气泡</p></blockquote><blockquote><p>2.允许来自您应用的所有气泡 - 使用<code>BubbleMetaData</code>发送的所有通知都将显示为气泡</p></blockquote><h1 id="Bubble-API"><a href="#Bubble-API" class="headerlink" title="Bubble API"></a>Bubble API</h1><p>气泡是通过通知API创建的，您可以像往常一样发送通知。如果你想让它冒泡，你需要附加一些额外的数据到它。</p><p>气泡的展开视图是由您选择的Activity创建的。需要将Activity配置为适当显示为气泡。该Activity必须<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vZ3VpZGUvdG9waWNzL21hbmlmZXN0L2FjdGl2aXR5LWVsZW1lbnQjcmVzaXplYWJsZUFjdGl2aXR5" title="https://developer.android.google.cn/guide/topics/manifest/activity-element#resizeableActivity">可调整大小<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vZ3VpZGUvdG9waWNzL21hbmlmZXN0L2FjdGl2aXR5LWVsZW1lbnQuaHRtbCNlbWJlZGRlZA==" title="https://developer.android.google.cn/guide/topics/manifest/activity-element.html#embedded">嵌入<i class="fa fa-external-link"></i></span>并始终以文档UI模式启动。如果它缺少这些要求中的任何一个，它将以通知的形式显示。</p><p>下面的代码演示了如何实现一个简单的气泡:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">".bubbles.BubbleActivity"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme.NoActionBar"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:label</span>=<span class="string">"@string/title_activity_bubble"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:allowEmbedded</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:documentLaunchMode</span>=<span class="string">"always"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:resizeableActivity</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>如果您的应用程序显示多个相同类型的气泡，比如多个联系人的聊天对话，则该活动必须能够启动多个实例。将documentLaunchMode设置为“always”。</p><p>要发送气泡，请遵循以下步骤:</p><p>1、像平常一样创建通知。</p><p>2、调用<code>Notification.BubbleMetadata.Builder</code>创建一个BubbleMetadata对象。</p><p>3、使用<code>setBubbleMetadata</code>将元数据添加到通知中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create bubble intent</span></span><br><span class="line"><span class="keyword">val</span> target = Intent(context, BubbleActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="keyword">val</span> bubbleIntent = PendingIntent.getActivity(context, <span class="number">0</span>, target, <span class="number">0</span> <span class="comment">/* flags */</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create bubble metadata</span></span><br><span class="line"><span class="keyword">val</span> bubbleData = Notification.BubbleMetadata.Builder()</span><br><span class="line">    .setDesiredHeight(<span class="number">600</span>)</span><br><span class="line">    <span class="comment">// Note: although you can set the icon is not displayed in Q Beta 2</span></span><br><span class="line">    .setIcon(Icon.createWithResource(context, R.drawable.icon))</span><br><span class="line">    .setIntent(bubbleIntent)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create notification</span></span><br><span class="line"><span class="keyword">val</span> chatBot = Person.Builder()</span><br><span class="line">    .setBot(<span class="literal">true</span>)</span><br><span class="line">    .setName(<span class="string">"BubbleBot"</span>)</span><br><span class="line">    .setImportant(<span class="literal">true</span>)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> builder = Notification.Builder(context, CHANNEL_ID)</span><br><span class="line">    .setContentIntent(contentIntent)</span><br><span class="line">    .setSmallIcon(smallIcon)</span><br><span class="line">    .setBubbleMetadata(bubbleData)</span><br></pre></td></tr></table></figure><p>注意:第一次发送显示气泡的通知时，它必须位于<strong>IMPORTANCE_HIGH</strong>的通知通道中。这是因为气泡是由通知重要性管理器处理的。如果系统在用户有机会允许或阻止冒泡之前降低了通知的重要性，则通知将不会冒泡。</p><p>如果您的应用程序在发送气泡时位于前台，那么重要性将被忽略，并且您的气泡将始终显示(除非用户已经阻止了气泡或来自应用程序的通知)。</p><h1 id="创建扩展的气泡"><a href="#创建扩展的气泡" class="headerlink" title="创建扩展的气泡"></a>创建扩展的气泡</h1><p>您可以配置气泡以自动将其呈现为展开状态。 我们建议仅在用户执行可能导致冒泡的操作时使用此功能，例如点按按钮以开始新聊天。 在这种情况下，抑制创建气泡时发送的初始通知也是有意义的。</p><p>您可以使用一些方法来设置启用这些行为的标志：<code>setAutoExpandBubble()</code>和<code>setSuppressInitialNotification</code></p><p>注意:虽然您可以在Android Q Beta 2中设置这些标志，但它们还没有任何效果。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bubbleMetadata = Notification.BubbleMetadata.Builder()</span><br><span class="line">    .setDesiredHeight(<span class="number">600</span>)</span><br><span class="line">    .setIntent(bubbleIntent)</span><br><span class="line">    .setAutoExpandBubble(<span class="literal">true</span>)</span><br><span class="line">    .setSuppressInitialNotification(<span class="literal">true</span>)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>1、气泡占据了屏幕空间，并覆盖了其他应用程序内容。只有在非常重要的情况下(比如正在进行的通信)，或者用户明确要求某些内容使用冒泡时，才应该将通知作为冒泡发送。</p><p>2、注意，用户可以禁用气泡。在这种情况下，气泡通知显示为正常通知。您应该始终确保气泡通知与正常通知一样工作。</p><p>3、从气泡中启动的流程(如活动和对话框)出现在气泡容器中。这意味着一个气泡可以有一个任务堆栈。如果气泡中有很多功能或导航，事情就会变得复杂。我们建议保持功能尽可能的具体和轻量级。</p><h1 id="测试示例"><a href="#测试示例" class="headerlink" title="测试示例"></a>测试示例</h1><p>创建BubbleActivity，在AndroidManifest.xml添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".BubbleActivity"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme.NoActionBar"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:label</span>=<span class="string">"@string/title_activity_bubble"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:allowEmbedded</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:documentLaunchMode</span>=<span class="string">"always"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:resizeableActivity</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中AppTheme.NoActionBar主题代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme.NoActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"windowActionBar"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"windowNoTitle"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowDrawsSystemBarBackgrounds"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:statusBarColor"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在MainActivity中，定义NotificatioManager对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> notificationManager: NotificationManager? = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>并在onCreate方法初始化</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notificationManager = <span class="keyword">this</span><span class="symbol">@MainActivity</span>.getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br></pre></td></tr></table></figure><p>定义常量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CONTENT = <span class="number">1</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_BUBBLE = <span class="number">2</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>定义显示Bubble气泡的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showBubble</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(tag, <span class="string">"show bubble"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建通知渠道</span></span><br><span class="line">        <span class="keyword">val</span> channel = NotificationChannel(<span class="string">"通知渠道ID"</span>, <span class="string">"通知渠道名称"</span>, NotificationManager.IMPORTANCE_HIGH)</span><br><span class="line">        notificationManager!!.createNotificationChannel(channel)</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">val</span> icon = Icon.createWithResource(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, R.mipmap.ic_launcher_round)</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">val</span> person = Person.Builder()</span><br><span class="line">            .setName(<span class="string">"Person Name"</span>)</span><br><span class="line">            .setIcon(icon)</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> contentIntent = PendingIntent.getActivity(</span><br><span class="line">                    <span class="keyword">this</span><span class="symbol">@MainActivity</span>,REQUEST_CONTENT,</span><br><span class="line">                    Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, MainActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>), <span class="type">PendingIntent.FLAG_UPDATE_CURRENT)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bubbleIntent = PendingIntent.getActivity(</span><br><span class="line">                    <span class="keyword">this</span><span class="symbol">@MainActivity</span>,</span><br><span class="line">                    REQUEST_BUBBLE,</span><br><span class="line">                    Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, BubbleActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>),<span class="type"></span></span></span><br><span class="line">                    PendingIntent.FLAG_UPDATE_CURRENT)</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">val</span> bubbleMetadata = Notification.BubbleMetadata.Builder()</span><br><span class="line">            .setDesiredHeight(<span class="number">400</span>)</span><br><span class="line">            .setIcon(icon)</span><br><span class="line">            .setAutoExpandBubble(<span class="literal">true</span>)</span><br><span class="line">            .setSuppressInitialNotification(<span class="literal">true</span>)</span><br><span class="line">            .setIntent(bubbleIntent)</span><br><span class="line">            .build()</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">val</span> builder = Notification.Builder(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, <span class="string">"通知渠道ID"</span>)</span><br><span class="line">            .setContentTitle(<span class="string">"Bubble"</span>)</span><br><span class="line">            .setContentText(<span class="string">"测试Android Q Bubble"</span>)</span><br><span class="line">            .setContentIntent(contentIntent)</span><br><span class="line">            .setSmallIcon(icon)</span><br><span class="line">            .setBubbleMetadata(bubbleMetadata)</span><br><span class="line">            .addPerson(person)</span><br><span class="line">            .setShowWhen(<span class="literal">true</span>)</span><br><span class="line">        notificationManager!!.notify(<span class="number">0</span>, builder.build());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在按钮的点击事件中调用<code>showBubble</code>方法，触发通知，并显示气泡</p><p>通知栏出现通知消息，屏幕右侧显示出了气泡（气泡好像没有图标，上文中有提到，即使设置了也不会在Q Beta 2上显示）</p><p><img alt="android-q-beta2-bubble-0" data-src="/images/android-q-beta2-bubble-0.png"></p><p>下拉通知栏，可以看到创建的通知消息</p><p><img alt="android-q-beta2-bubble-1" data-src="/images/android-q-beta2-bubble-1.png"></p><p>长按快捷方式的效果</p><p><img alt="android-q-beta2-bubble-2" data-src="/images/android-q-beta2-bubble-2.png"></p><p>点击气泡，会触发打开<strong>BubbleActivity</strong>并弹出窗口，可以看到右上角两个图标，左下角一个，右下角一个</p><p><img alt="android-q-beta2-bubble-3" data-src="/images/android-q-beta2-bubble-3.png"></p><p>首先我们看看左下角的图标，点击了会弹出两个选项，一个添加应用快捷方式，另一个设置壁纸</p><p><img alt="android-q-beta2-bubble-4" data-src="/images/android-q-beta2-bubble-4.png"></p><p>点击第一个添加应用快捷方式，可以列出当前设备安装的应用</p><p><img alt="android-q-beta2-bubble-5" data-src="/images/android-q-beta2-bubble-5.png"></p><p>随机点了两个，一个微信，一个支付宝，添加进去。添加完成之后，从此处点击过去，就能直接打开跳转到指定的应用程序 (添加进去还没测试如何移除，试过了清除数据和重新安装都没效果)</p><p><img alt="android-q-beta2-bubble-6" data-src="/images/android-q-beta2-bubble-6.png"></p><p>点击右上角箭头的的图标可以直接进入 —— <strong>MainActivity</strong></p><p>点击右上角的齿轮，可以跳转的该应用的通知的设置</p><p><img alt="android-q-beta2-bubble-7" data-src="/images/android-q-beta2-bubble-7.png"></p><p>点击具体的一条通知渠道后面的齿轮，可以详细的进入具体的通知渠道设置</p><p><img alt="android-q-beta2-bubble-8" data-src="/images/android-q-beta2-bubble-8.png"></p><p>然后气泡右下角的图标，类似于快捷launcher桌面，可以直接访问桌面的所有应用程序，点击也是直接打开跳转到指定的应用程序中</p><p><img alt="android-q-beta2-bubble-9" data-src="/images/android-q-beta2-bubble-9.png"></p><p>最后，长按气泡图标，拖拽到底部指定区域，可以销毁气泡</p><p><img alt="android-q-beta2-bubble-10" data-src="/images/android-q-beta2-bubble-10.png"></p><p>判断是否允许了气泡的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">canBubble</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = notificationManager!!.getNotificationChannel(<span class="string">"通知渠道ID"</span>)</span><br><span class="line">    <span class="keyword">return</span> notificationManager!!.areBubblesAllowed() &amp;&amp; channel.canBubble()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9mZWF0dXJlcy9idWJibGVz" title="https://developer.android.google.cn/preview/features/bubbles">官方文档<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvYW5kcm9pZC1CdWJibGVz" title="https://github.com/googlesamples/android-Bubbles">官方示例<i class="fa fa-external-link"></i></span>简单总结，感谢您的阅读。如有不足，欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本节内容测试Android Q新功能 —— 气泡&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="Bubbles" scheme="https://shoewann0402.github.io/tags/Bubbles/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 访问剪切板数据</title>
    <link href="https://shoewann0402.github.io/2019/03/27/android-q-beta-access-clipboard-data/"/>
    <id>https://shoewann0402.github.io/2019/03/27/android-q-beta-access-clipboard-data/</id>
    <published>2019-03-27T09:08:34.000Z</published>
    <updated>2019-07-19T16:43:10.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节内容测试Android Q对剪切板数据的访问 </p></blockquote><hr><a id="more"></a><blockquote><p><em>当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考</em></p></blockquote><h1 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h1><p>Android Q 对访问剪切板数据进行了限制，非系统默认输入法以及后台运行的程序是无法访问到剪切板数据</p><h1 id="测试示例-——-后台运行的程序访问剪切板"><a href="#测试示例-——-后台运行的程序访问剪切板" class="headerlink" title="测试示例 —— 后台运行的程序访问剪切板"></a>测试示例 —— 后台运行的程序访问剪切板</h1><p>测试之前我复制了本博客地址:<strong><a href="https://shoewann0402.github.io">https://shoewann0402.github.io</a></strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xw.clipboarddemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ClipboardManager</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tag: String = MainActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cm: ClipboardManager? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        cm = <span class="keyword">this</span>.getSystemService(Context.CLIPBOARD_SERVICE) <span class="keyword">as</span> ClipboardManager?</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.直接获取剪切板数据</span></span><br><span class="line">        getClipboardData()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.点击按钮获取剪切板数据</span></span><br><span class="line">        btn_get_clipboard_data.setOnClickListener &#123;</span><br><span class="line">            getClipboardData()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取剪切板数据的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getClipboardData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(tag, getString(R.string.get_clipboard_data))</span><br><span class="line">        <span class="comment">//如果当前剪贴板上存在Copy返回True</span></span><br><span class="line">        <span class="keyword">val</span> hasPrimaryClip = cm!!.hasPrimaryClip()</span><br><span class="line">        Log.d(tag, <span class="string">"<span class="subst">$&#123;getString(R.string.hasPrimaryClip)&#125;</span><span class="variable">$hasPrimaryClip</span>"</span>)</span><br><span class="line">        <span class="keyword">if</span> (hasPrimaryClip) &#123;</span><br><span class="line">            <span class="keyword">val</span> abc = cm!!.primaryClip</span><br><span class="line">            <span class="keyword">if</span> (abc != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> item = abc.getItemAt(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> text = item.text.toString()</span><br><span class="line">                Log.d(tag, <span class="string">"<span class="subst">$&#123;getString(R.string.clipboard_data)&#125;</span><span class="variable">$text</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对剪贴板文字的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当应用加载成功，输出日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-03-27 17:17:17.127 26244-26244/com.xw.clipboarddemo D/MainActivity: 获取剪切板数据</span><br><span class="line">2019-03-27 17:17:17.128 26244-26244/com.xw.clipboarddemo D/MainActivity: 剪切板是否含有复制数据:false</span><br></pre></td></tr></table></figure><p>然后点击按钮，输出日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-03-27 17:17:18.924 26244-26244/com.xw.clipboarddemo D/MainActivity: 获取剪切板数据</span><br><span class="line">2019-03-27 17:17:18.924 26244-26244/com.xw.clipboarddemo D/MainActivity: 剪切板是否含有复制数据:true</span><br><span class="line">2019-03-27 17:17:18.925 26244-26244/com.xw.clipboarddemo D/MainActivity: [剪切板数据]:https://shoewann0402.github.io</span><br></pre></td></tr></table></figure><p>可见Android Q上只有当前应用获取了焦点，运行在前台才能访问到剪切板数据，在后台无法获取到剪切板的数据</p><p>针对默认键盘这种方式的，这里不做测试了</p><blockquote><p>本文参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5L2RhdGEtaWRlbnRpZmllcnMjY2xpcGJvYXJkLWRhdGE=" title="https://developer.android.com/preview/privacy/data-identifiers#clipboard-data">官方文档<i class="fa fa-external-link"></i></span>简单总结，感谢您的阅读。如有不足，欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本节内容测试Android Q对剪切板数据的访问 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="Clipboard" scheme="https://shoewann0402.github.io/tags/Clipboard/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 应用切换WiFi开关的限制</title>
    <link href="https://shoewann0402.github.io/2019/03/20/android-q-beta-enable-and-disable-wifi/"/>
    <id>https://shoewann0402.github.io/2019/03/20/android-q-beta-enable-and-disable-wifi/</id>
    <published>2019-03-20T00:34:49.000Z</published>
    <updated>2019-07-19T16:43:27.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android Q 不允许应用程序开/关WIFI</p></blockquote><hr><a id="more"></a><blockquote><p><em>当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考</em></p></blockquote><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>Android Q 将切断应用对Wi-Fi设置的访问权限，防止恶意软件滥用系统功能的访问权限。</p><h1 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h1><p>运行在Q上的应用程序将无法启用/禁用WIFI, <code>WifiManager.setWifiEnabled()</code>方法始将终返回false,该方法不被允许</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xw.androidqtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.net.wifi.WifiManager</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WifiActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tag: String = WifiActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> wifiManager: WifiManager? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_wifi)</span><br><span class="line">        wifiManager = <span class="keyword">this</span>.getSystemService(Context.WIFI_SERVICE) <span class="keyword">as</span> WifiManager?</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> isWifiEnabled = wifiManager!!.isWifiEnabled</span><br><span class="line">        Log.d(tag, <span class="string">"[默认状态]是否开启 :<span class="variable">$isWifiEnabled</span>"</span>)</span><br><span class="line">        <span class="keyword">when</span> (isWifiEnabled) &#123;</span><br><span class="line">            <span class="literal">true</span> -&gt; &#123;</span><br><span class="line">                Log.d(tag, <span class="string">"[关闭]WiFi，设置WiFi状态为: false"</span>)</span><br><span class="line">                wifiManager!!.isWifiEnabled = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">val</span> result = wifiManager!!.isWifiEnabled</span><br><span class="line">                Log.d(tag, <span class="string">"当前状态:<span class="variable">$result</span>"</span>)</span><br><span class="line">                <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                    Log.d(tag, <span class="string">"检查到当前是true[开启状态], 关闭WiFi: [失败]"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.d(tag, <span class="string">"检查到当前是false[关闭状态], 关闭WiFi: [成功]"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                Log.d(tag, <span class="string">"[开启]WiFi，设置WiFi状态为: true"</span>)</span><br><span class="line">                wifiManager!!.isWifiEnabled = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">val</span> result = wifiManager!!.isWifiEnabled</span><br><span class="line">                Log.d(tag, <span class="string">"当前状态:<span class="variable">$result</span>"</span>)</span><br><span class="line">                <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                    Log.d(tag, <span class="string">"检查当前是true[开启状态], 开启WiFi: [成功]"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.d(tag, <span class="string">"检查当前是false[关闭状态], 开启WiFi: [失败]"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>当WiFi默认是开启的情况下，需要代码关闭WiFi，输出日志:</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-03-20 08:24:51.741 1213-1650/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.WifiActivity&#125; from uid 10505</span><br><span class="line">2019-03-20 08:24:51.779 11562-11562/? D/WifiActivity: [默认状态]是否开启 :true</span><br><span class="line">2019-03-20 08:24:51.779 11562-11562/? D/WifiActivity: [关闭]WiFi，设置WiFi状态为: false</span><br><span class="line">2019-03-20 08:24:51.781 1213-1650/? I/WifiService: setWifiEnabled not allowed for uid=10505</span><br><span class="line">2019-03-20 08:24:51.781 11562-11562/? D/WifiActivity: 当前状态:true</span><br><span class="line">2019-03-20 08:24:51.781 11562-11562/? D/WifiActivity: 检查到当前是true[开启状态], 关闭WiFi: [失败]</span><br></pre></td></tr></table></figure><blockquote><ul><li>当WiFi默认是关闭的情况下，需要代码开启WiFi，输出日志:</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-03-20 08:27:00.212 1213-3863/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.WifiActivity&#125; from uid 10505</span><br><span class="line">2019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: [默认状态]是否开启 :false</span><br><span class="line">2019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: [开启]WiFi，设置WiFi状态为: true</span><br><span class="line">2019-03-20 08:27:00.245 1213-5152/? I/WifiService: setWifiEnabled not allowed for uid=10505</span><br><span class="line">2019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: 当前状态:false</span><br><span class="line">2019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: 检查当前是false[关闭状态], 开启WiFi: [失败]</span><br></pre></td></tr></table></figure><p>通过以上的示例可以看到，不论是开启还是关闭WiFi都没有效果，系统都将返回<code>false</code>，并输出<code>setWifiEnabled</code>不被允许的日志信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setWifiEnabled not allowed for uid= xxxx</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>使用设置面板提示用户启用和禁用Wi-Fi，<br>调用<code>Settings.Panel.ACTION_INTERNET_CONNECTIVITY</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(Intent(Settings.Panel.ACTION_INTERNET_CONNECTIVITY))</span><br></pre></td></tr></table></figure><blockquote><p>本文参考官方文档简单总结，感谢您的阅读。如有不足，欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android Q 不允许应用程序开/关WIFI&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="WIFI" scheme="https://shoewann0402.github.io/tags/WIFI/"/>
    
      <category term="setWifiEnabled" scheme="https://shoewann0402.github.io/tags/setWifiEnabled/"/>
    
      <category term="Settings Panel" scheme="https://shoewann0402.github.io/tags/Settings-Panel/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 设置面板</title>
    <link href="https://shoewann0402.github.io/2019/03/19/android-q-beta-settings-panel/"/>
    <id>https://shoewann0402.github.io/2019/03/19/android-q-beta-settings-panel/</id>
    <published>2019-03-19T10:15:56.000Z</published>
    <updated>2019-07-19T16:44:06.128Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android Q 引入了设置面板，它是一种API, 允许从应用程序上下文直接向用户展示设置。</p></blockquote><hr><a id="more"></a><blockquote><p><em>当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考</em></p></blockquote><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>避免了用户为了使用应用程序而需要进入<strong>设置</strong>来更改<strong>NFC</strong>或<strong>移动数据</strong>等内容。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>例如，假设用户在其设备处于飞行模式时打开Web浏览器。 在Android Q之前，该应用只能显示一条通用消息，要求用户打开“设置”以恢复连接。 使用Android Q，浏览器应用程序可以显示一个内联面板，显示关键的连接设置，如飞行模式，Wi-Fi（包括附近的网络）和移动数据。 使用此面板，用户无需离开应用即可恢复连接。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>这一新功能目前暂提供了<code>网络连接</code>、<code>NFC</code>、<code>音量</code>三个<strong>设置面板</strong>,使我们可以访问这三个不同的设置面板，所有这些面板都可以通过简单的<code>startActivity()</code>调用启动。</p><h2 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings.Panel.ACTION_INTERNET_CONNECTIVITY</span><br></pre></td></tr></table></figure><p><img alt="android-q-beta-settings-panel-wifi-1.png" data-src="/images/android-q-beta-settings-panel-wifi-1.png"></p><p><img alt="android-q-beta-settings-panel-wifi-1.png" data-src="/images/android-q-beta-settings-panel-wifi-2.png"></p><p>面板属性:</p><blockquote><ul><li>启用/禁用飞行模式</li><li>启用/禁用WIFI连接</li><li>启用/禁用移动数据</li><li>更改WIFI连接</li><li>导航到连接设置</li></ul></blockquote><h2 id="NFC"><a href="#NFC" class="headerlink" title="NFC"></a>NFC</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings.Panel.ACTION_NFC</span><br></pre></td></tr></table></figure><p><img alt="android-q-beta-settings-panel-nfc.png" data-src="/images/android-q-beta-settings-panel-nfc.png"></p><p>面板属性:</p><blockquote><ul><li>显示与近场通信（NFC）相关的所有设置。</li></ul></blockquote><h2 id="音量"><a href="#音量" class="headerlink" title="音量"></a>音量</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings.Panel.ACTION_VOLUME</span><br></pre></td></tr></table></figure><p><img alt="android-q-beta-settings-panel-volume.png" data-src="/images/android-q-beta-settings-panel-volume.png"></p><p>面板属性:</p><blockquote><ul><li>媒体音量</li><li>通话音量</li><li>铃声音量</li><li>闹钟音量</li></ul></blockquote><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xw.androidqtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.provider.Settings</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_settings_panel.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SettingsPanelActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tag: String = SettingsPanelActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_settings_panel)</span><br><span class="line">        </span><br><span class="line">        btnConnectivity.setOnClickListener &#123;</span><br><span class="line">            openSettings(Settings.Panel.ACTION_INTERNET_CONNECTIVITY)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnNFC.setOnClickListener &#123;</span><br><span class="line">            openSettings(Settings.Panel.ACTION_NFC)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnVolume.setOnClickListener &#123;</span><br><span class="line">            openSettings(Settings.Panel.ACTION_VOLUME)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">openSettings</span><span class="params">(panel: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        Log.d(tag, <span class="string">"panel:<span class="variable">$panel</span>"</span>)</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(panel)</span><br><span class="line">        startActivity(intent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9mZWF0dXJlcyNzZXR0aW5ncy1wYW5lbHM=" title="https://developer.android.google.cn/preview/features#settings-panels">官方文档<i class="fa fa-external-link"></i></span>及示例简单总结，感谢您的阅读。如有不足，欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android Q 引入了设置面板，它是一种API, 允许从应用程序上下文直接向用户展示设置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="Settings Panel" scheme="https://shoewann0402.github.io/tags/Settings-Panel/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 独立存储</title>
    <link href="https://shoewann0402.github.io/2019/03/17/android-q-beta-scoped-storage/"/>
    <id>https://shoewann0402.github.io/2019/03/17/android-q-beta-scoped-storage/</id>
    <published>2019-03-17T04:42:37.000Z</published>
    <updated>2019-08-12T18:05:43.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android Q 系统, 对应用存储空间访问进行了限制。</p></blockquote><hr><a id="more"></a><blockquote><p><em>当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考</em></p></blockquote><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>为了让用户更好地控制文件并限制文件混乱，Android Q 改变了应用程序访问设备外部存储上文件的方式</p><h1 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h1><blockquote><ul><li>使用更精细粒度、特殊媒体权限取代<code>READ_EXTERNAL_STORAGE</code> 和<code>WRITE_EXTERNAL_STORAGE</code> 权限</li></ul></blockquote><blockquote><ul><li>应用程序从外部存储设备访问自己的文件不需要特殊权限</li></ul></blockquote><hr><h1 id="更新变化-gt-Q-beta5"><a href="#更新变化-gt-Q-beta5" class="headerlink" title="更新变化 -&gt; Q beta5"></a>更新变化 -&gt; Q beta5</h1><p>以下内容是 Q beta 5 上<strong>最新的变化</strong> (临时添加部分内容)</p><p>1、您可以使用新的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvUi5hdHRyLmh0bWwjcmVxdWVzdExlZ2FjeUV4dGVybmFsU3RvcmFnZQ==" title="https://developer.android.google.cn/reference/android/R.attr.html#requestLegacyExternalStorage">requestLegacyExternalStorage<i class="fa fa-external-link"></i></span> manifest属性在Android Q设备上启用应用程序的新行为，即使您的应用程序的目标是Android 9或更低。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">  <span class="comment">&lt;!--在目标版本为 Android Q 的应用程序上这个属性值默认情况下为 false --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- This attribute is "false" by default on apps targeting Android Q. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:requestLegacyExternalStorage</span>=<span class="string">"true"</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、Android Q继续使用<strong>READ_EXTERNAL_STORAGE</strong>和<strong>WRITE_EXTERNAL_STORAGE</strong>权限，这两个权限对应于面向存储用户的运行时权限。<br>3、早期测试版本中引入的特定于媒体集合的权限，现<strong>已过时</strong></p><blockquote><ul><li><del>READ_MEDIA_IMAGES</del></li><li><del>READ_MEDIA_AUDIO</del> </li><li><del>READ_MEDIA_VIDEO</del></li></ul></blockquote><h2 id="更多变化和使用参见官方文档"><a href="#更多变化和使用参见官方文档" class="headerlink" title="更多变化和使用参见官方文档"></a>更多变化和使用参见官方文档</h2><h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>这些更改会影响您的应用保存和访问外部存储上的文件的方式。</p><p><img alt="android_q_file_access.png" data-src="/images/android_q_file_access.png"></p><h1 id="沙箱独立存储应用私有文件"><a href="#沙箱独立存储应用私有文件" class="headerlink" title="沙箱独立存储应用私有文件"></a>沙箱独立存储应用私有文件</h1><p>Android Q 为每一个应用在外部存储设备内采用了<code>沙箱独立存储</code>。比如<code>/sdcard</code>, 没有其他应用程序能够直接访问您应用程序沙箱内的文件，因为对于您的应用程序来说这些文件是私有的，您不再需要任何权限去访问和保存您自己外部存储中的文件，这一变化使维护用户文件的隐私变得更容易，并有助于减少应用程序所需的权限数量。</p><p><strong>【注意】如果用户手动卸载了应用程序，沙箱内的私有文件也会被清理</strong></p><p>通过<code>Context.getExternalFilesDir()</code>返回的位置是在外部存储上存储文件的最佳位置。因为这个位置在所有Android版本上的行为都是一致的。使用此方法时，请传入与要创建或打开的文件类型对应的媒体环境，比如说，访问或保存应用程序私有图片，调用<code>Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)</code></p><h1 id="分享媒体文件集"><a href="#分享媒体文件集" class="headerlink" title="分享媒体文件集"></a>分享媒体文件集</h1><p>如果您的应用程序创建的文件属于用户，用户希望在当应用程序被卸载之后这些文件能够被保留，然后保存到一个公共的媒体集，也称为共享集合。共享集合包括：<strong>图片&amp;视频、音乐以及下载</strong></p><h2 id="查看其他应用程序文件的权限"><a href="#查看其他应用程序文件的权限" class="headerlink" title="查看其他应用程序文件的权限"></a>查看其他应用程序文件的权限</h2><p>在这些共享集合中您的应用程序为了创建和变更它自己的文件不需要请求任何的权限。如果您的应用需要去创建和变更其他应用程序创建的文件，它必须首先要请求适当的权限</p><blockquote><ul><li>在<strong>图片&amp;视频</strong>共享集合中去访问其他应用的文件需要请求<code>READ_MEDIA_IMAGES</code>或者 <code>READ_MEDIA_VIDEO</code>权限，依赖您的应用程序需要去访问的文件类型</li></ul></blockquote><blockquote><ul><li>在<strong>音乐</strong>共享集合中去访问其他应用的文件需要请求<code>READ_MEDIA_AUDIO</code>权限</li></ul></blockquote><p>【注意】这里没有访问<strong>下载</strong>共享集合的权限。您的应用程序能够在这个集合里访问它自己的文件，对于访问这个集合里其他应用程序的文件，您必须使用系统文件选择器应用程序允许用户去选择一个文件</p><p>【注意】如果您的应用使用了<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vZ3VpZGUvdG9waWNzL3Byb3ZpZGVycy9kb2N1bWVudC1wcm92aWRlcg==" title="https://developer.android.google.cn/guide/topics/providers/document-provider">Storage Access Framework(存储访问框架)<i class="fa fa-external-link"></i></span>,它不需要去请求这些独立的媒体权限</p><h2 id="访问共享集合"><a href="#访问共享集合" class="headerlink" title="访问共享集合"></a>访问共享集合</h2><p>请求必要的权限之后，您的应用程序使用<code>MediaStore</code>API 访问这些集合</p><blockquote><ul><li><strong>图片 &amp; 视频</strong> 共享集合 —— 使用<code>MediaStore.Images</code>或<code>MediaStore.Video</code></li><li><strong>音乐</strong> 共享集合 —— 使用<code>MediaStore.Audio</code></li><li><strong>下载</strong> 共享集合 —— 使用<code>MediaStore.Downloads</code><br>【警告】对于新安装在Android Q上的应用程序，调用<code>getExternalStoragePublicDirectory</code>,只提供对应用程序存储在其隔离存储沙箱中的文件的访问。保持对其他应用程序文件的访问权限，更新应用程序的逻辑，使用<code>MediaStore</code>代替</li></ul></blockquote><h2 id="保留应用程序在共享集合中的文件"><a href="#保留应用程序在共享集合中的文件" class="headerlink" title="保留应用程序在共享集合中的文件"></a>保留应用程序在共享集合中的文件</h2><p>默认情况下，当用户卸载了您的应用程序，Android Q 会清理您保存在沙箱中的文件。当您应用程序被卸载时对于保留这些文件，使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vZ3VpZGUvdG9waWNzL3Byb3ZpZGVycy9kb2N1bWVudC1wcm92aWRlcg==" title="https://developer.android.google.cn/guide/topics/providers/document-provider">Storage Access Framework(存储访问框架)<i class="fa fa-external-link"></i></span>或者保存到一个共享集合。</p><p>要保留文件到共享集合，请在相关的MediaStore集合中插入新行，并按以下方式填充其列</p><blockquote><ul><li>最低限度，为<code>DISPLAY_NAME</code>和<code>MIME_TYPE</code>列提供值</li><li>可选性，您能够使用<code>PRIMARY_DIRECTORY</code>和<code>SECONDARY_DIRECTORY</code>列影响文件放置在磁盘上的位置。</li><li>不定义DATA列，这样，平台可以灵活地将文件保存在您的沙箱之外。</li></ul></blockquote><p>插入之后，您能够使用像<code>ContentResolver.openFileDescriptor()</code>读写数据到新创建的文件</p><p>如果用户在之后重新安装了您的应用，您的应用程序不会访问这些文件，除非它执行以下操作之一：</p><blockquote><ul><li>请求相应的集合权限</li><li>从存储访问框架向用户发送请求。<br>这种情况类似于应用程序尝试访问其他应用程序文件的情况。</li></ul></blockquote><h1 id="照片的特殊注意事项"><a href="#照片的特殊注意事项" class="headerlink" title="照片的特殊注意事项"></a>照片的特殊注意事项</h1><p>Android Q 添加了几个增强功能，让用户更好的控制在外部存储上他们照片的访问</p><h2 id="访问照片的位置"><a href="#访问照片的位置" class="headerlink" title="访问照片的位置"></a>访问照片的位置</h2><p>有一些照片在它们Exif元数据中包含了位置信息，允许用户查看照片的拍摄地。因为这些位置信息是敏感的，Android Q 默认情况下重新编辑了这些信息。这个位置信息的限制不同于适用于相机特性的限制。</p><p>【注意】如果您的应用程序是用户默认的照片管理应用程序，平台将会自动给予您应用程序访问照片中的位置信息。</p><p>如果您的应用程序需要访问一个照片的位置，需要完成如下步骤</p><p>1.添加新的权限<code>ACCESS_MEDIA_LOCATION</code>到您应用程序的清单中<br>2.从您的MediaStore对象，调用setRequireOriginal()，传入照片的URI</p><h2 id="展示用户图库照片"><a href="#展示用户图库照片" class="headerlink" title="展示用户图库照片"></a>展示用户图库照片</h2><p>如果您的应用程序是一个相机应用，它无法直接访问保存在<strong>图片&amp;视频</strong>共享集合中的照片，除非它是默认的照片管理应用，要将用户引导到图库应用程序，请使用<code>ACTION_REVIEW</code> intent意图。</p><h1 id="处理其他应用程序的文件"><a href="#处理其他应用程序的文件" class="headerlink" title="处理其他应用程序的文件"></a>处理其他应用程序的文件</h1><p>这个环节解释应用程序如何与存储在共享集合中的其他应用程序的文件进行交互。</p><h2 id="访问其他应用创建的文件"><a href="#访问其他应用创建的文件" class="headerlink" title="访问其他应用创建的文件"></a>访问其他应用创建的文件</h2><p>在一个外部存储设备上，访问和读取其他应用程序的已经保存的媒体文件，分为以下几步：</p><p>1.请求必要的权限，基于包含您要访问的文件的共享集合。<br>2.使用<code>ContentResolver</code>对象去查找并打开文件</p><p>【注意】<strong>ContentResolver</strong>类包含了一个新的方法，<strong>loadThumbnail()</strong>,提供给您应用预览文件。最好先调用<strong>loadThumbnail()</strong>,以便用户能够查看媒体文件快照无需您的应用程序加载所有文件本身。这个方法还允许更灵活的请求，比如请求特殊维度和取消请求的能力。</p><h2 id="写入其他应用创建的文件"><a href="#写入其他应用创建的文件" class="headerlink" title="写入其他应用创建的文件"></a>写入其他应用创建的文件</h2><p>通过保存文件到共享集合，您的应用程序将成为该文件的所有者。通常情况下，您的应用程序能够写入到共享集合的文件，除非您是这个文件的所有者。如果您的应用程序有正确的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9mZWF0dXJlcyNyb2xlcw==" title="https://developer.android.google.cn/preview/features#roles">角色<i class="fa fa-external-link"></i></span>分配给它，您也能够写入到其他应用程序自己的文件：</p><blockquote><ul><li>如果您的应用程序是用户默认的照片管理应用，你能够变更其他应用保存在<strong>图片&amp;视频</strong>共享集合里的图片文件</li><li>如果您的应用程序是用户默认的音乐应用，您能够变更其他应用程序保存在<strong>音乐</strong>共享集合里的音频文件</li></ul></blockquote><p>【注意】您的应用程序应该保持功能，无论它是默认的照片管理器或音乐应用程序。</p><p>要变更其他应用保存在外部存储设备中原始的媒体文件，完成如下步骤之一：</p><blockquote><ul><li>通过<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9mZWF0dXJlcy9yb2xlcyNjaGVjay1kZWZhdWx0LWFwcA==" title="https://developer.android.google.cn/preview/features/roles#check-default-app">角色指南<i class="fa fa-external-link"></i></span>检查您的应用是否是默认的图片管理应用或者默认的音乐管理应用</li><li>使用<code>ContentResolver</code>对象查找文件并变更它，当执行编辑/变更操作，捕获<code>RecoverableSecurityException</code>以便您能够请求用户授予您写入的特殊项</li></ul></blockquote><h1 id="访问特殊文件"><a href="#访问特殊文件" class="headerlink" title="访问特殊文件"></a>访问特殊文件</h1><p>在一些使用情况中，您的应用或许需要打开或者创建权限，它无需要有访问权限：</p><blockquote><ul><li>在照片编辑应用程序中，打开一张图片。</li><li>在商业产品应用中，保存文本文档到本地让用户选择</li></ul></blockquote><p>允许用户去选择特殊文件打开，或者选择特殊位置保存文件，对于这些解决方案，使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vZ3VpZGUvdG9waWNzL3Byb3ZpZGVycy9kb2N1bWVudC1wcm92aWRlcg==" title="https://developer.android.google.cn/guide/topics/providers/document-provider">存储访问框架<i class="fa fa-external-link"></i></span></p><h1 id="配套的app文件共享"><a href="#配套的app文件共享" class="headerlink" title="配套的app文件共享"></a>配套的app文件共享</h1><p>如果您管理一套需要互相访问彼此文件的应用程序，使用<code>content://</code>URIs,我们已经<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vdG9waWMvc2VjdXJpdHkvYmVzdC1wcmFjdGljZXMjcGVybWlzc2lvbnMtc2hhcmUtZGF0YQ==" title="https://developer.android.google.cn/topic/security/best-practices#permissions-share-data">建议作为安全性最佳实践。<i class="fa fa-external-link"></i></span></p><p>更多信息，请查阅文档如何<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vdHJhaW5pbmcvc2VjdXJlLWZpbGUtc2hhcmluZy9zZXR1cC1zaGFyaW5n" title="https://developer.android.google.cn/training/secure-file-sharing/setup-sharing">设置文件共享<i class="fa fa-external-link"></i></span></p><h1 id="升级设备上以前安装的应用程序的兼容性模式"><a href="#升级设备上以前安装的应用程序的兼容性模式" class="headerlink" title="升级设备上以前安装的应用程序的兼容性模式"></a>升级设备上以前安装的应用程序的兼容性模式</h1><p>限制外部存储中的文件访问应用于应用程序target目标版本是Android Q,或者运行在Android Q设备上最新安装的应用</p><p>当满足如下条件时，系统会将您的应用文件访问设置为兼容模式:</p><blockquote><ul><li>target version  &lt; = Android 9 (API 28)</li><li>您安装在设备上的应用从[ Android 9 ] –&gt; 升级到—&gt; [ Android Q ]</li></ul></blockquote><p>当您的应用程序进入兼容模式，以下文件访问行为适用：</p><blockquote><ul><li>您的应用程序能够访问<code>MediaStore</code>集合内所有的文件存储，甚至是您的应用程序没有创建的文件。</li><li>面向用户的是允许或拒绝您的应用程序访问整个外部存储的权限，而不是像<strong>图片&amp;视频</strong>或者<strong>音乐</strong>这样单独的共享集合</li></ul></blockquote><p>这个兼容模式直到您首次卸载您的应用程序仍然有效</p><p>【注意】如果您的应用程序之后在同一设备重新安装，兼容模式不会重新被激活</p><h1 id="识别特殊的外部存储设备"><a href="#识别特殊的外部存储设备" class="headerlink" title="识别特殊的外部存储设备"></a>识别特殊的外部存储设备</h1><p>SDK &lt; = Android 9 (API 28) —— 在所有的外部存储设备上的所有文件都显示在当个<code>&quot;external&quot;</code>(外部)卷标下</p><p>Android Q, 给每一个外部存储设备一个不一样的卷标，这意味着系统帮助您有效地组织和索引内容，它可以让您控制新内容的存储位置</p><p>【注意】主外部存储设备始终使用卷名“external”。</p><p>对于外部存储内唯一地标识特殊文件，您必须使用卷标名和ID一起。比如说，一个文件在主存储设备将是<code>content://media/external/images/media/12</code>，但是二级存储设备上名为FA23-3E92的相应文件将是<code>content://media/FA23-3E92/images/media/12</code></p><p>您能够在特殊的卷上，通过传入卷标名到特殊媒体集访问存储文件。比如说<code>MediaStore.Images.getContentUri()</code></p><h2 id="获取外部存储设备列表"><a href="#获取外部存储设备列表" class="headerlink" title="获取外部存储设备列表"></a>获取外部存储设备列表</h2><p>要获取所有当前可用的卷标名称列表，调用<code>call MediaStore.getAllVolumeNames()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> volumeNames: Set&lt;String&gt; = MediaStore.getAllVolumeNames(context)</span><br></pre></td></tr></table></figure><h2 id="设置一个虚拟的外部存储设备"><a href="#设置一个虚拟的外部存储设备" class="headerlink" title="设置一个虚拟的外部存储设备"></a>设置一个虚拟的外部存储设备</h2><p>在没有可移动外部存储的设备上，使用以下命令启用虚拟磁盘以进行测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell sm set-virtual-disk true</span><br></pre></td></tr></table></figure><h1 id="测试行为变化"><a href="#测试行为变化" class="headerlink" title="测试行为变化"></a>测试行为变化</h1><p>为了帮助您使应用程序与此新行为变化兼容，平台提供了多种方法来调整与更改相关的多个参数。</p><h2 id="切换行为更改"><a href="#切换行为更改" class="headerlink" title="切换行为更改"></a>切换行为更改</h2><p>要在Android Q Beta 1中启用此行为更改，请在终端窗口中执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell sm set-isolated-storage on</span><br></pre></td></tr></table></figure><p>运行此命令后，设备将重新启动。 如果没有，请等一下再尝试再次运行该命令。</p><p>要确认行为变化是否已生效，请使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop sys.isolated_storage_snapshot</span><br></pre></td></tr></table></figure><h1 id="测试兼容模式行为"><a href="#测试兼容模式行为" class="headerlink" title="测试兼容模式行为"></a>测试兼容模式行为</h1><p>测试应用程序时，可以通过在终端窗口中运行以下命令来启用外部文件存储访问的兼容性模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd appops set your-package-name android:legacy_storage allow</span><br></pre></td></tr></table></figure><p>要禁用兼容模式，请在Android Q上卸载并重新安装您的应用，或在终端窗口中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd appops set your-package-name android:legacy_storage default</span><br></pre></td></tr></table></figure><h1 id="将外部存储作为文件管理器浏览"><a href="#将外部存储作为文件管理器浏览" class="headerlink" title="将外部存储作为文件管理器浏览"></a>将外部存储作为文件管理器浏览</h1><p>获得对外部存储中的目录的广泛访问,就像文件管理器应用程序可能做的那样,使用<code>ACTION_OPEN_DOCUMENT_TREE</code>意图，比如说，在GitHub上查看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvYW5kcm9pZC1EaXJlY3RvcnlTZWxlY3Rpb24=" title="https://github.com/googlesamples/android-DirectorySelection">android-DirectorySelection<i class="fa fa-external-link"></i></span>示例。</p><p>【警告】在Android Q中不推荐使用<strong>StorageVolume</strong>类中的<strong>createAccessIntent（）</strong> 方法，因此不应使用此方法浏览外部存储设备。 如果您这样做，运行Android Q设备的用户将无法在您的应用中查看保存在外部存储中的文件。</p><h1 id="测试示例"><a href="#测试示例" class="headerlink" title="测试示例"></a>测试示例</h1><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="测试-1-——-默认方式-getExternalStorageDirectory"><a href="#测试-1-——-默认方式-getExternalStorageDirectory" class="headerlink" title="测试 1 —— 默认方式 getExternalStorageDirectory"></a>测试 1 —— 默认方式 getExternalStorageDirectory</h3><p>定义一个Activity——<code>FileStorageActivity</code>，然后定义如下读写方法，通过界面上两个按钮触发，进行默认getExternalStorageDirectory路径下文件的读写测试，运行在Android Q 设备也无需在清单文件定义<code>READ_EXTERNAL_STORAGE</code> 和<code>WRITE_EXTERNAL_STORAGE</code>权限</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> file = File(Environment.getExternalStorageDirectory(), <span class="string">"测试Android Q文件.txt"</span>);</span><br><span class="line">        Log.d(tag, <span class="string">"file.exists():<span class="subst">$&#123;file.exists()&#125;</span> ， file.getAbsolutePath(): <span class="subst">$&#123;file.absolutePath&#125;</span>"</span>);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span><span class="symbol">@FileStorageActivity</span>, <span class="string">"SD卡目录下创建文件成功..."</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        <span class="keyword">val</span> fw = FileWriter(file);</span><br><span class="line">        fw.write(<span class="string">"我是测试Android Q文件写入的内容"</span>);</span><br><span class="line">        fw.close()</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span><span class="symbol">@FileStorageActivity</span>, <span class="string">"SD卡写入内容完成..."</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">        Log.d(tag, <span class="string">"SD卡写入内容完成..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> fr = FileReader(Environment.getExternalStorageDirectory().path+<span class="string">"/测试Android Q文件.txt"</span>);</span><br><span class="line">        <span class="keyword">val</span> r = BufferedReader(fr);</span><br><span class="line">        <span class="keyword">val</span> result = r.readLine();</span><br><span class="line">        Log.d(tag, <span class="string">"SD卡文件里面的内容:<span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-03-17 14:06:46.117 31140-31140/com.xw.androidqtest D/FileStorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/测试Android Q文件.txt</span><br><span class="line">2019-03-17 14:06:46.130 31140-31140/com.xw.androidqtest D/FileStorageActivity: SD卡写入内容完成...</span><br><span class="line">2019-03-17 14:06:50.346 31140-31140/com.xw.androidqtest D/FileStorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容</span><br></pre></td></tr></table></figure><p>查看/sdcard根下的文件，发现没有该文件，被系统自动存放在如下沙箱中</p><p><img alt="android-q-beta-file-test-1.png" data-src="/images/android-q-beta-file-test-1.png"></p><h3 id="测试-2-——-推荐方式-Context-getExternalFilesDir"><a href="#测试-2-——-推荐方式-Context-getExternalFilesDir" class="headerlink" title="测试 2 —— 推荐方式 Context.getExternalFilesDir()"></a>测试 2 —— 推荐方式 Context.getExternalFilesDir()</h3><p>测试将文件放入文档目录，传入<code>Environment.DIRECTORY_DOCUMENTS</code>到<code>getExternalFilesDir()</code>方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> context: Context = <span class="keyword">this</span><span class="symbol">@FileStorageActivity</span></span><br><span class="line">        <span class="keyword">val</span> file = File(context.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), <span class="string">"测试Android Q文件.txt"</span>);</span><br><span class="line">        Log.d(tag, <span class="string">"file.exists():<span class="subst">$&#123;file.exists()&#125;</span> ， file.getAbsolutePath(): <span class="subst">$&#123;file.absolutePath&#125;</span>"</span>);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span><span class="symbol">@FileStorageActivity</span>, <span class="string">"SD卡目录下创建文件成功..."</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        <span class="keyword">val</span> fw = FileWriter(file);</span><br><span class="line">        fw.write(<span class="string">"我是测试Android Q文件写入的内容"</span>);</span><br><span class="line">        fw.close()</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span><span class="symbol">@FileStorageActivity</span>, <span class="string">"SD卡写入内容完成..."</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">        Log.d(tag, <span class="string">"SD卡写入内容完成..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> context: Context = <span class="keyword">this</span><span class="symbol">@FileStorageActivity</span></span><br><span class="line">        <span class="keyword">val</span> fr = FileReader(context.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS).path + <span class="string">"/测试Android Q文件.txt"</span>);</span><br><span class="line">        <span class="keyword">val</span> r = BufferedReader(fr);</span><br><span class="line">        <span class="keyword">val</span> result = r.readLine();</span><br><span class="line">        Log.d(tag, <span class="string">"SD卡文件里面的内容:<span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-03-17 14:27:23.423 9511-9511/com.xw.androidqtest D/FileStorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/Android/data/com.xw.androidqtest/files/Documents/测试Android Q文件.txt</span><br><span class="line">2019-03-17 14:27:23.437 9511-9511/com.xw.androidqtest D/FileStorageActivity: SD卡写入内容完成...</span><br><span class="line">2019-03-17 14:27:27.696 9511-9511/com.xw.androidqtest D/FileStorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容</span><br></pre></td></tr></table></figure><p>文件所在位置：</p><p><img alt="android-q-beta-file-test-2.png" data-src="/images/android-q-beta-file-test-2.png"></p><p>更多示例，请参照<strong>以上内容</strong>或<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9wcml2YWN5L3Njb3BlZC1zdG9yYWdl" title="https://developer.android.google.cn/preview/privacy/scoped-storage">官方文档<i class="fa fa-external-link"></i></span>, 自行测试</p><hr><p><strong>2019-03-26 更新:</strong></p><p>得到反馈，测试 1 未能在android-10模拟器上复现成功，由于上面的测试我是在pixel 2真机上测试的，对此如下又在模拟器上进行了测试 （本次真机也同时测试了一遍）。</p><p>由于<strong>没有添加</strong>读写权限，在模拟器上运行抛出了异常 —-&gt; (真机没有任何异常)</p><p><img alt="android-q-beta-file-test-3.png" data-src="/images/android-q-beta-file-test-3.png"></p><p><img alt="android-q-beta-file-test-4.png" data-src="/images/android-q-beta-file-test-4.png"></p><p>于是<strong>添加</strong>读写权限，并<strong>动态授权</strong>，模拟器上运行无异常，但是确实写入的文件未能自动放入<strong>/Android/sandbox/com.xw.androidqtest</strong>目录下，位置没变还是在<strong>/storage/emulated/0/</strong>根目录下</p><p><img alt="android-q-beta-file-test-5.png" data-src="/images/android-q-beta-file-test-5.png"></p><p>针对以上的出现的问题，猜想应该是模拟器和真机之间的差异，大家怎么看？ 欢迎大家在评论处留言讨论</p><hr><blockquote><p>本文参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9wcml2YWN5L3Njb3BlZC1zdG9yYWdl" title="https://developer.android.google.cn/preview/privacy/scoped-storage">官方文档<i class="fa fa-external-link"></i></span>进行简单翻译及示例总结，感谢您的阅读。如有不足，欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android Q 系统, 对应用存储空间访问进行了限制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="Permission" scheme="https://shoewann0402.github.io/tags/Permission/"/>
    
      <category term="scoped" scheme="https://shoewann0402.github.io/tags/scoped/"/>
    
      <category term="sandbox" scheme="https://shoewann0402.github.io/tags/sandbox/"/>
    
      <category term="Shared collections" scheme="https://shoewann0402.github.io/tags/Shared-collections/"/>
    
      <category term="File" scheme="https://shoewann0402.github.io/tags/File/"/>
    
      <category term="external storage" scheme="https://shoewann0402.github.io/tags/external-storage/"/>
    
      <category term="behavior change" scheme="https://shoewann0402.github.io/tags/behavior-change/"/>
    
      <category term="media" scheme="https://shoewann0402.github.io/tags/media/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 后台启动Activity限制</title>
    <link href="https://shoewann0402.github.io/2019/03/16/android-q-beta-background-activity-starts/"/>
    <id>https://shoewann0402.github.io/2019/03/16/android-q-beta-background-activity-starts/</id>
    <published>2019-03-16T02:40:22.000Z</published>
    <updated>2019-07-19T16:43:03.124Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文针对Android Q 后台启动Activity简单总结</p></blockquote><hr><a id="more"></a><blockquote><p><em>当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考</em></p></blockquote><p>Android Q对应用程序何时可以启动Activity进行了限制。</p><h1 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h1><p>这种行为的改变有助于减少用户的干扰，并让用户更好地控制屏幕上显示的内容。尤其是运行在Android Q上的应用程序，只有满足以下一个或多个条件才能启动Activity:</p><blockquote><ul><li>应用程序有一个可见的窗口，比如在前台一个的Activity。</li><li>一个在前台不同的应用程序发送了属于该应用程序的一个PendingIntent， 示例包括自定义选项卡提供者发送菜单项待定意图。</li><li>系统发送了一个属于该应用程序的PendingIntent，比如点击一条通知，只有应用程序可以启动UI的待处理意图才可以免除。</li><li>系统向应用程序发送一个广播，如<code>SECRET_CODE_ACTION</code>到应用程序。只有特定的广播，应用程序预计在UI启动时才会被豁免。</li></ul></blockquote><p>【注】出于Activity启动的目的，前台服务不将应用程序限定在前台。</p><h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>这个行为变化影响到所有运行在Android Q上的应用程序，即使是那些target版本是Android 9(API 28) 或者更低的，即使您的应用程序的target版本是Android 9或更低版本，并且最初安装在运行Android 9或更低版本的设备上，在设备升级到Android Q之后，行为更改仍然会生效。</p><p>但是，只要您的应用程序作为用户交互的直接结果启动Actvity，您的应用程序就很可能不会受到此更改的影响。</p><h1 id="警告信息"><a href="#警告信息" class="headerlink" title="警告信息"></a>警告信息</h1><p>在Beta 1中，如果你的应用程序运行在Android Q上，并试图从后台启动某个活动，平台允许该活动启动，但它会向logcat发送一条警告消息，并显示以下警告toast消息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This background activity start from package-name will be blocked in future Q builds.</span><br></pre></td></tr></table></figure><p>这则消息意思是: <strong>该后台activity从某包下启动，将在之后构建的Q版本中被屏蔽</strong></p><p>Android Q中与在后台启动Activity相关的限制与设备进入屏幕固定状态后系统阻止Activity启动的方式类似。</p><h1 id="改进方式"><a href="#改进方式" class="headerlink" title="改进方式"></a>改进方式</h1><p>几乎在所有情况下，后台应用程序都应创建通知，以便向用户提供信息，而不是直接启动Activity。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="复现警告"><a href="#复现警告" class="headerlink" title="复现警告"></a>复现警告</h2><p>为了测试复现警告消息，这里定义<code>MainActivity</code>和<code>BackgroundActivity</code>,在<code>MainActivity</code>的<code>onPause</code>方法中如下实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        <span class="keyword">val</span> timer = Timer()</span><br><span class="line">        <span class="keyword">val</span> timerTask = <span class="keyword">object</span> : TimerTask() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">                startActivity(Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>,BackgroundActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer.schedule(timerTask, <span class="number">5000</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>MainActivity</strong>启动之后，按Home键切换到Launcher，此时<strong>MainActivity</strong>将会执行<code>onPause</code>方法，在此方法中开启了一个定时器，模拟后台启动Activity</p><p>然后后台输出如下日志</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-03-16 10:03:10.599 1192-7709/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.BackgroundActivity&#125; from uid 10505</span><br><span class="line">2019-03-16 10:03:10.600 1192-7709/? W/ActivityTaskManager: Background activity start [callingPackage: com.xw.androidqtest; callingUid: 10505; isCallingUidForeground: false; isCallingUidPersistentSystemProcess: false; realCallingUid: 10505; isRealCallingUidForeground: false; isRealCallingUidPersistentSystemProcess: false; originatingPendingIntent: null; isBgStartWhitelisted: false; intent: Intent &#123; cmp=com.xw.androidqtest/.BackgroundActivity &#125;; callerApp: ProcessRecord&#123;b6f89ff 29017:com.xw.androidqtest/u0a505&#125;]</span><br><span class="line">2019-03-16 10:03:10.619 29017-29017/com.xw.androidqtest W/ActivityThread: handleWindowVisibility: no activity for token android.os.BinderProxy@8611b07</span><br><span class="line">2019-03-16 10:03:10.700 1192-1238/? I/ActivityTaskManager: Displayed com.xw.androidqtest/.BackgroundActivity: +96ms</span><br></pre></td></tr></table></figure><p>界面弹出了警告消息</p><p><img alt="warningMsg" data-src="/images/warningMsg.png"></p><p>参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9wcml2YWN5L2JhY2tncm91bmQtYWN0aXZpdHktc3RhcnQ=" title="https://developer.android.google.cn/preview/privacy/background-activity-start">官方文档<i class="fa fa-external-link"></i></span>，做如下处理</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>创建<strong>前台服务</strong>类，并在<code>onStartCommand</code>方法中创建一个<strong>前台通知</strong>,</p><p>以下是<strong>完整代码</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.xw.androidqtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.*</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.<span class="keyword">annotation</span>.RequiresApi</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationCompat</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForegroundService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tag: String = ForegroundService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        Log.d(tag, <span class="string">"ForegroundService OnCreate called"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        Log.d(tag, <span class="string">"ForegroundService onStartCommand called"</span>)</span><br><span class="line"></span><br><span class="line">        createNotificationChannel(<span class="string">"channelId"</span>, <span class="string">"channelName"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> fullScreenIntent = Intent(<span class="keyword">this</span>, BackgroundActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        <span class="keyword">val</span> fullScreenPendingIntent = PendingIntent.getActivity(</span><br><span class="line">            <span class="keyword">this</span>, <span class="number">0</span>,</span><br><span class="line">            fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> notificationBuilder = NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">"channelId"</span>)</span><br><span class="line">            .setSmallIcon(R.mipmap.ic_launcher_round)</span><br><span class="line">            .setContentTitle(getString(R.string.app_name))</span><br><span class="line">            .setContentText(<span class="string">"启动BackgroundActivity"</span>)</span><br><span class="line">            .setPriority(NotificationCompat.PRIORITY_HIGH)</span><br><span class="line">            .setCategory(NotificationCompat.CATEGORY_CALL)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use a full-screen intent only for the highest-priority alerts where you</span></span><br><span class="line">            <span class="comment">// have an associated activity that you would like to launch after the user</span></span><br><span class="line">            <span class="comment">// interacts with the notification. Also, if your app targets Android Q, you</span></span><br><span class="line">            <span class="comment">// need to request the USE_FULL_SCREEN_INTENT permission in order for the</span></span><br><span class="line">            <span class="comment">// platform to invoke this notification.</span></span><br><span class="line">            .setFullScreenIntent(fullScreenPendingIntent, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> incomingCallNotification = notificationBuilder.build()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The integer ID that you give to startForeground() must not be 0.</span></span><br><span class="line">        startForeground(<span class="number">1</span>, incomingCallNotification)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> START_STICKY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.O)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotificationChannel</span><span class="params">(channelId: <span class="type">String</span>, channelName: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> channel = NotificationChannel(</span><br><span class="line">            channelId,</span><br><span class="line">            channelName, NotificationManager.IMPORTANCE_NONE</span><br><span class="line">        )</span><br><span class="line">        channel.lightColor = Color.BLUE</span><br><span class="line">        channel.lockscreenVisibility = Notification.VISIBILITY_PRIVATE</span><br><span class="line">        <span class="keyword">val</span> service = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        service.createNotificationChannel(channel)</span><br><span class="line">        <span class="keyword">return</span> channelId</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        stopForeground(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>清单文件</code>注册权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.FOREGROUND_SERVICE"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- New Android Q permission --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.USE_FULL_SCREEN_INTENT"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>最后更新<code>onPause</code>方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        <span class="keyword">val</span> timer = Timer()</span><br><span class="line">        <span class="keyword">val</span> timerTask = <span class="keyword">object</span> : TimerTask() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">                startService(Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, ForegroundService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer.schedule(timerTask, <span class="number">5000</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行输出日志：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-03-16 10:25:22.308 9112-9112/com.xw.androidqtest D/ForegroundService: ForegroundService OnCreate called</span><br><span class="line">2019-03-16 10:25:22.309 9112-9112/com.xw.androidqtest D/ForegroundService: ForegroundService onStartCommand called</span><br></pre></td></tr></table></figure><p>通知栏收到了发出的通知</p><p><img alt="warningMsgFix" data-src="/images/warningMsgFix.png"></p><p>点击通知进入了需要后台启动的<code>BackgroundActivity</code><br>日志内容 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-03-16 10:29:04.074 1192-4994/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.BackgroundActivity&#125; from uid 10505</span><br><span class="line">2019-03-16 10:29:04.074 1192-4994/? W/ActivityTaskManager: startActivity called from non-Activity context; forcing Intent.FLAG_ACTIVITY_NEW_TASK for: Intent &#123; cmp=com.xw.androidqtest/.BackgroundActivity &#125;</span><br><span class="line">2019-03-16 10:29:04.082 9112-9112/com.xw.androidqtest W/ActivityThread: handleWindowVisibility: no activity for token android.os.BinderProxy@46d3c48</span><br><span class="line">2019-03-16 10:29:04.084 1192-1251/? W/WindowManager: TaskSnapshotSurface.create: Failed to find main window for token=AppWindowToken&#123;6b40830 token=Token&#123;fb2f173 ActivityRecord&#123;7d079e2 u0 com.xw.androidqtest/.BackgroundActivity t800&#125;&#125;&#125;</span><br><span class="line">2019-03-16 10:29:04.143 1192-1238/? I/ActivityTaskManager: Displayed com.xw.androidqtest/.BackgroundActivity: +69ms</span><br></pre></td></tr></table></figure><h1 id="开启行为变化"><a href="#开启行为变化" class="headerlink" title="开启行为变化"></a>开启行为变化</h1><p>即使这种行为变化在默认情况下不会在Android Q Beta 1中生效，您也可以通过完成以下任务之一来模拟这种行为变化:</p><blockquote><ul><li>导航到“设置&gt;开发人员选项”，并禁用“允许后台活动启动”选项</li><li>在终端中执行如下命令</li></ul></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global background_activity_starts_enabled <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="模拟测试"><a href="#模拟测试" class="headerlink" title="模拟测试"></a>模拟测试</h2><p>将代码还原成直接调用从后台启动Activity，设置好如上所叙述的操作，测试<br>效果图</p><p><img alt="warningQMsg" data-src="/images/warningQMsg.png"></p><p>与文章一开始测试不同之处就是: <strong>目前在Q Beta1上默认还是会启动起后台的Activity展示并显示toast消息，这次测试模拟了最终完全屏蔽的情况，不会调起后台的Activity</strong></p><blockquote><p>本文参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9wcml2YWN5L2JhY2tncm91bmQtYWN0aXZpdHktc3RhcnQ=" title="https://developer.android.google.cn/preview/privacy/background-activity-start">官方文档<i class="fa fa-external-link"></i></span>进行简单总结，感谢您的阅读。如有不足，欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文针对Android Q 后台启动Activity简单总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Activity" scheme="https://shoewann0402.github.io/tags/Activity/"/>
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="Background" scheme="https://shoewann0402.github.io/tags/Background/"/>
    
  </entry>
  
  <entry>
    <title>关于 Android Q 定位</title>
    <link href="https://shoewann0402.github.io/2019/03/15/about-android-q-beta-location/"/>
    <id>https://shoewann0402.github.io/2019/03/15/about-android-q-beta-location/</id>
    <published>2019-03-15T02:42:12.000Z</published>
    <updated>2019-07-19T16:42:06.135Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android Q Location 的简单总结</p></blockquote><hr><a id="more"></a><blockquote><p><em>当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考</em></p></blockquote><h2 id="以往情况"><a href="#以往情况" class="headerlink" title="以往情况"></a>以往情况</h2><blockquote><ul><li>Android API &lt; 23 : 无需动态请求，直接注册使用位置权限</li><li>Android API &gt; = 23 &amp;&amp; API &lt; = 28: 需要动态请求权限，并<strong>允许</strong>/<strong>拒绝</strong>权限</li></ul></blockquote><p>从之前来看，用户只有一个控件<code>允许</code>或<code>拒绝</code>应用程序访问设备位置，包括应用程序在使用时和不使用时的位置使用情况。</p><p>在Android Q上，Android团队对控件进行了改进</p><h2 id="有何变化"><a href="#有何变化" class="headerlink" title="有何变化"></a>有何变化</h2><p><img alt="android_q_location_test.png" data-src="/images/android_q_location_test.png"></p><p>从Android Q开始，用户有一个新选项，只有在使用该应用时才能让应用访问该位置; 换句话说，当应用程序在前台时。这意味着用户可以选择三种选项来为应用提供位置：</p><blockquote><ul><li><code>All the time</code> - 意味着APP任何时候都能访问到位置</li><li><code>While in use</code> - 意味着APP只有当在使用的时候才能访问到位置</li><li><code>Deny</code> - 意味着APP无法访问到位置</li></ul></blockquote><p>从Android Q Beta 1开始，此更改具有以下属性：</p><blockquote><ul><li>如果您在后台请求访问用户的位置，则会影响您的应用</li><li>通过使用新权限在后台访问位置并在没有后台位置更新的情况下确保优雅降级来进行缓解</li><li>Android Q上始终启用行为</li></ul></blockquote><h2 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_BACKGROUND_LOCATION"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果您的应用具有需要“始终”权限的功能</p><blockquote><ul><li>target version Q : 您需要为清单文件添加新的<code>ACCESS_BACKGROUND_LOCATION</code>权限</li></ul></blockquote><blockquote><ul><li>target version &lt;= Android 9 (API 28)  :  如果您请求<code>ACCESS_FINE_LOCATION</code>或<code>ACCESS_COARSE_LOCATION</code>中的任何一个，系统将会自动为您添加<code>ACCESS_BACKGROUND_LOCATION</code>权限</li></ul></blockquote><p>用户可以随时通过<code>设置</code>决定提供或删除这些位置权限。 要保持良好的用户体验，请将应用程序设计为在应用程序没有后台位置权限或没有任何位置访问权限时进行优雅处理。</p><blockquote><p><strong>注意</strong>：虽然您的应用可以请求并接收ACCESS_BACKGROUND_LOCATION，但用户可以通过选择您的应用仅应在前台访问位置信息来撤消此权限。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xw.androidqtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.Manifest</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.ActivityCompat</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_location.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocationActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tag: String = LocationActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE_FOREGROUND = <span class="number">1</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE_BACKGROUND = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_location)</span><br><span class="line"></span><br><span class="line">        btnForeground.setOnClickListener &#123;</span><br><span class="line">            requestPermission()</span><br><span class="line">        &#125;</span><br><span class="line">        btnBackground.setOnClickListener &#123;</span><br><span class="line">            requestBackgroundPermission()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(requestCode: <span class="type">Int</span>, permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;, grantResults: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">            REQUEST_CODE_FOREGROUND -&gt; handlePermissionForForeground()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> permissionAccessCoarseLocationApproved = ActivityCompat</span><br><span class="line">            .checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_COARSE_LOCATION) ==</span><br><span class="line">                PackageManager.PERMISSION_GRANTED</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (permissionAccessCoarseLocationApproved) &#123;</span><br><span class="line">            handlePermissionForForeground()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(<span class="keyword">this</span>,</span><br><span class="line">                arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION), REQUEST_CODE_FOREGROUND)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestBackgroundPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> permissionAccessCoarseLocationApproved = ActivityCompat</span><br><span class="line">            .checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_COARSE_LOCATION) ==</span><br><span class="line">                PackageManager.PERMISSION_GRANTED</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (permissionAccessCoarseLocationApproved) &#123;</span><br><span class="line">            <span class="keyword">val</span> backgroundLocationPermissionApproved = ActivityCompat</span><br><span class="line">                .checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_BACKGROUND_LOCATION) ==</span><br><span class="line">                    PackageManager.PERMISSION_GRANTED</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (backgroundLocationPermissionApproved) &#123;</span><br><span class="line">                <span class="comment">// App can access location both in the foreground and in the background.</span></span><br><span class="line">                <span class="comment">// Start your service that doesn't have a foreground service type</span></span><br><span class="line">                <span class="comment">// defined.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// App can only access location in the foreground. Display a dialog</span></span><br><span class="line">                <span class="comment">// warning the user that your app must have all-the-time access to</span></span><br><span class="line">                <span class="comment">// location in order to function properly. Then, request background</span></span><br><span class="line">                <span class="comment">// location.</span></span><br><span class="line">                ActivityCompat.requestPermissions(<span class="keyword">this</span>,</span><br><span class="line">                    arrayOf(Manifest.permission.ACCESS_BACKGROUND_LOCATION), REQUEST_CODE_BACKGROUND)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// App doesn't have access to the user's location at all. Make full request</span></span><br><span class="line">            <span class="comment">// for permission.</span></span><br><span class="line">            ActivityCompat.requestPermissions(<span class="keyword">this</span>,</span><br><span class="line">                arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION,</span><br><span class="line">                    Manifest.permission.ACCESS_BACKGROUND_LOCATION), REQUEST_CODE_BACKGROUND)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handlePermissionForForeground</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(tag,<span class="string">"handlePermissionForForeground called"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上是对Android Q 位置变化的简单总结，更多使用方法请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9wcml2YWN5L2RldmljZS1sb2NhdGlvbg==" title="https://developer.android.google.cn/preview/privacy/device-location">官方文档<i class="fa fa-external-link"></i></span></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android Q Location 的简单总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="Location" scheme="https://shoewann0402.github.io/tags/Location/"/>
    
      <category term="Permission" scheme="https://shoewann0402.github.io/tags/Permission/"/>
    
  </entry>
  
  <entry>
    <title>介绍 Android Q Beta版</title>
    <link href="https://shoewann0402.github.io/2019/03/14/introducing-android-q-beta/"/>
    <id>https://shoewann0402.github.io/2019/03/14/introducing-android-q-beta/</id>
    <published>2019-03-14T00:10:37.000Z</published>
    <updated>2020-03-01T13:29:46.272Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自: <span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOS8wMy9pbnRyb2R1Y2luZy1hbmRyb2lkLXEtYmV0YS5odG1s" title="https://android-developers.googleblog.com/2019/03/introducing-android-q-beta.html">Introducing Android Q Beta<i class="fa fa-external-link"></i></span></p></blockquote><a id="more"></a><p>2019年，移动创新比以往更加强大。新型科技从5G到边缘，再到边缘显示器，甚至是可折叠屏幕。<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmxvZy5nb29nbGUvcHJvZHVjdHMvYW5kcm9pZC9zaGFwaW5nLWZ1dHVyZS1tb2JpbGUtYW5kcm9pZC8=" title="https://www.blog.google/products/android/shaping-future-mobile-android/">Android正处于这个创新周期的中心<i class="fa fa-external-link"></i></span>，感谢数十亿设备的合作伙伴广泛的生态系统。Android帮助推动了硬件和软件的界限，带给用户全新的体验和功能。</p><p>随着移动生态系统的发展，Android着重于帮助用户利用最新的创新，确保用户的安全和隐私始终是首要任务，在像Google Pley Protect和运行时权限的基础上构建。Android Q 带来了额外的隐私和安全功能给用户，以及增强可折叠，用于连接新的APIs,新的媒体解码器和相机功能，NNAPI扩展，Vulkan 1.1支持，更快的应用程序启动，以及更多。</p><p>今天我们为早期采纳者发布了Android Q Beta 1 版本并为开发者发布SDK预览版。您今天可以通过<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9hbmRyb2lkL2JldGE=" title="https://www.google.com/android/beta">注册任意Pixel设备<i class="fa fa-external-link"></i></span>(包括原版的Pixel和Pixel XL,我们通过大众需求扩大了支持！)请<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWVkYmFjaw==" title="https://developer.android.com/preview/feedback">让我们知道您的想法！<i class="fa fa-external-link"></i></span>，继续阅读，了解Android Q中的内容，我们将在<span class="exturl" data-url="aHR0cHM6Ly9ldmVudHMuZ29vZ2xlLmNvbS9pby8=" title="https://events.google.com/io/">5月份的Google I / O<i class="fa fa-external-link"></i></span>上看到您，我们将分享更多内容。</p><h1 id="建立在Android的隐私保护之上"><a href="#建立在Android的隐私保护之上" class="headerlink" title="建立在Android的隐私保护之上"></a>建立在Android的隐私保护之上</h1><p>Android的设计以安全和隐私为中心,随着Android的成熟,我们增加了很多功能来保护用户,像<span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vc2VjdXJpdHkvZW5jcnlwdGlvbi9maWxlLWJhc2Vk" title="https://source.android.com/security/encryption/file-based">基于文件的加密<i class="fa fa-external-link"></i></span>、操作系统控制要求应用程序在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvdG9waWNzL3Blcm1pc3Npb25zL292ZXJ2aWV3" title="https://developer.android.com/guide/topics/permissions/overview">访问敏感资源之前请求权限<i class="fa fa-external-link"></i></span>、锁定<span class="exturl" data-url="aHR0cHM6Ly93d3cudGhldmVyZ2UuY29tLzIwMTgvMy83LzE3MDkxMTA0L2FuZHJvaWQtcC1wcmV2ZW50cy1hcHBzLXVzaW5nLW1pYy1jYW1lcmEtaWRsZS1iYWNrZ3JvdW5k" title="https://www.theverge.com/2018/3/7/17091104/android-p-prevents-apps-using-mic-camera-idle-background">相机/麦克风后台访问<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29tcHV0ZXJ3b3JsZC5jb20vYXJ0aWNsZS8zMjk3MDM5L2FuZHJvaWQtcGllLXNlY3VyaXR5LXNldHRpbmcuaHRtbA==" title="https://www.computerworld.com/article/3297039/android-pie-security-setting.html">锁定模式<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9zZWN1cml0eS5nb29nbGVibG9nLmNvbS8yMDE4LzEwL2dvb2dsZS1hbmQtYW5kcm9pZC1oYXZlLXlvdXItYmFjay1ieS5odG1s" title="https://security.googleblog.com/2018/10/google-and-android-have-your-back-by.html">加密备份<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5kcm9pZC5jb20vcGxheS1wcm90ZWN0Lw==" title="https://www.android.com/play-protect/">Google Play Protect<i class="fa fa-external-link"></i></span>(每天扫描超过500亿个应用程序，以识别潜在的有害应用程序并删除它们)以及更多。在Android Q中，我们已经做了更多的增强来保护我们的用户，其中许多增强是我们在Strobe项目中工作的一部分。</p><h2 id="给用户更多的位置控制"><a href="#给用户更多的位置控制" class="headerlink" title="给用户更多的位置控制"></a>给用户更多的位置控制</h2><p>使用Android Q，操作系统帮助用户更好地控制应用程序何时可以获得位置。就像之前的操作系统版本一样，应用程序只有在请求你的权限并得到你的许可后才能获得位置信息。</p><p>特别敏感的一件事是，应用程序在不使用的情况下(在后台)访问位置。Android Q 允许用户永远不允许应用程序查看自己的位置，只在应用程序正在使用(运行)或一直在使用(后台)时才允许。</p><p><img alt="android_q_loc_dialog" data-src="/images/android_q_loc_dialog.png"></p><p>例如，一个应用程序询问用户食品配送的位置是有意义的，用户可能希望授予它这样做的能力。但由于应用程序可能不需要当前正在使用的位置之外的位置，用户可能不想授予该访问权限。Android Q现在提供了更高级别的控制。请阅读<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5L2RldmljZS1sb2NhdGlvbg==" title="https://developer.android.com/preview/privacy/device-location">开发人员指南<i class="fa fa-external-link"></i></span>，了解有关如何使应用程序适应此新控件的详细信息。期待更多以用户为中心的改进出现在即将到来的beta中。我们的目标是非常敏感地，始终为开发人员提供尽可能多的通知和支持。</p><h2 id="Android-Q中更多的隐私保护"><a href="#Android-Q中更多的隐私保护" class="headerlink" title="Android Q中更多的隐私保护"></a>Android Q中更多的隐私保护</h2><p>除了位置的改变，我们还在进行进一步的更新，以确保透明度、用户控制权和个人数据的安全。</p><p>在Android Q 中，该操作系统让用户对应用程序有了更多的控制，控制对共享文件的访问。用户将能够通过新的运行时权限控制应用程序对照片、视频或音频集合的访问。对于下载，应用程序必须使用系统文件选择器，这允许用户决定应用程序可以访问哪些下载文件。对于开发人员来说，您的应用程序如何在外部存储上使用共享区域有一些变化。请确保阅读作用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5L3Njb3BlZC1zdG9yYWdl" title="https://developer.android.com/preview/privacy/scoped-storage">域存储(Scoped Storage)更改<i class="fa fa-external-link"></i></span>以获得详细信息。</p><p>我们还看到，当一个应用程序意外地跳到前台并占据焦点时，用户(和开发人员)会感到不安。为了减少这些干扰，Android Q将阻止应用程序在后台启动活动。如果你的应用程序在后台，需要迅速吸引用户的注意力——比如来电或闹钟——你可以使用高优先级通知，并提供全屏意图。有关更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5L2JhY2tncm91bmQtYWN0aXZpdHktc3RhcnRz" title="https://developer.android.com/preview/privacy/background-activity-starts">文档<i class="fa fa-external-link"></i></span>。</p><p>我们限制对不可重置设备标识符的访问，包括设备IMEI、序列号和类似标识符。阅读<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdHJhaW5pbmcvYXJ0aWNsZXMvdXNlci1kYXRhLWlkcw==" title="https://developer.android.com/training/articles/user-data-ids">最佳实践<i class="fa fa-external-link"></i></span>，以帮助您为用例选择正确的标识符，并在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5L2RhdGEtaWRlbnRpZmllcnM=" title="https://developer.android.com/preview/privacy/data-identifiers">这里<i class="fa fa-external-link"></i></span>查看详细信息。在默认情况下，当连接到不同的Wi-Fi网络时，我们还会随机设置设备的MAC地址——这在Android 9 Pie中是可选的。</p><p>我们提前把这些变化告诉你，这样你就可以有尽可能多的时间来准备。我们还努力为开发人员预先提供详细的信息，我们建议查看关于隐私更改的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5" title="https://developer.android.com/preview/privacy">详细文档<i class="fa fa-external-link"></i></span>，并立即开始测试。</p><h1 id="吸引用户的新方式"><a href="#吸引用户的新方式" class="headerlink" title="吸引用户的新方式"></a>吸引用户的新方式</h1><p>在Android Q中，我们启用了新的方式将用户带入你的应用程序，并在他们从其他应用程序过渡时简化体验。</p><h2 id="折叠和创新的新屏幕"><a href="#折叠和创新的新屏幕" class="headerlink" title="折叠和创新的新屏幕"></a>折叠和创新的新屏幕</h2><p>可折叠设备开辟了一些创新的经验和用例。为了帮助你的应用程序更好地利用这些和其他大屏幕设备，我们在Android Q中做了很多改进，包括onResume和onPause的改变，以支持多简历，并在你的应用程序有焦点时通知你。我们还更改了resizeableActivity manifest属性的工作方式，以帮助您管理应用程序在可折叠和大屏幕上的显示方式。为了让您开始在这些新设备上构建和测试，我们一直在努力更新Android模拟器，以支持多显示器类型切换——更多细节即将公布!</p><p><img alt="android_q_map" data-src="/images/android_q_map.png"></p><h2 id="分享快捷键"><a href="#分享快捷键" class="headerlink" title="分享快捷键"></a>分享快捷键</h2><p>当用户想在另一个应用程序中与他人分享照片等内容时，过程应该很快。在Android Q中，我们通过共享快捷方式让这一过程变得更快更简单，用户可以直接跳转到另一个应用程序来共享内容。开发人员可以发布共享目标，这些目标在应用程序中启动带有附加内容的特定活动，并在共享UI中显示给用户。因为它们是预先发布的，所以可以在启动时立即加载共享UI。</p><p><img alt="android_q_share" data-src="/images/android_q_share.png"></p><p>共享快捷方式机制类似于应用程序快捷方式的工作方式，因此我们扩展了<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvY29udGVudC9wbS9TaG9ydGN1dEluZm8=" title="https://developer.android.com/reference/android/content/pm/ShortcutInfo">ShortcutInfo API<i class="fa fa-external-link"></i></span>，以便更容易地集成这两个功能。新的ShareTarget AndroidX库也支持这个新的API。这允许应用程序使用新功能，同时允许pre-Q设备使用直接共享。您可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvYW5kcm9pZC1TaGFyaW5nU2hvcnRjdXRz" title="https://github.com/googlesamples/android-SharingShortcuts">这里<i class="fa fa-external-link"></i></span>找到带有源代码的早期示例应用程序。</p><h2 id="设置面板"><a href="#设置面板" class="headerlink" title="设置面板"></a>设置面板</h2><p>现在，您还可以通过一个新的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvcHJvdmlkZXIvU2V0dGluZ3MuUGFuZWw=" title="https://developer.android.com/reference/android/provider/Settings.Panel">设置面板API<i class="fa fa-external-link"></i></span>在应用程序上下文中直接显示关键系统设置，该API利用了我们在Android 9 Pie中引入的slice特性。</p><p>设置面板是一个浮动的UI，您可以从应用程序中调用它来显示用户可能需要的系统设置，比如internet连接、NFC和音频音量。例如，浏览器可以显示带有连接设置的面板，如飞机模式、Wi-Fi(包括附近的网络)和移动数据。没有必要离开应用程序;用户可以根据需要从面板管理设置。要显示设置面板，只需使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvcHJvdmlkZXIvU2V0dGluZ3MuUGFuZWwuaHRtbCNBQ1RJT05fSU5URVJORVRfQ09OTkVDVElWSVRZ" title="https://developer.android.com/reference/android/provider/Settings.Panel.html#ACTION_INTERNET_CONNECTIVITY">Settings.Panel actions<i class="fa fa-external-link"></i></span>其中一个新设置触发一个intent</p><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>在Android Q中，我们扩展了您的应用程序可以使用Android的连接堆栈并添加新的连接API。</p><p><img alt="android_q_connect" data-src="/images/android_q_connect.png"></p><h2 id="连接权限、隐私和安全性"><a href="#连接权限、隐私和安全性" class="headerlink" title="连接权限、隐私和安全性"></a>连接权限、隐私和安全性</h2><p>大多数用于扫描网络的api已经需要粗位置权限，但在Android Q 中，对于蓝牙、蜂窝网络和Wi-Fi，我们正在通过要求精细位置权限来增强对这些api的保护。如果你的应用只需要建立点对点连接或推荐网络，看看下面改进的Wi-Fi api——它们简化了连接，不需要位置许可。</p><p>除了Android Q在连接不同Wi-Fi网络时提供的随机MAC地址，我们还增加了新的Wi-Fi标准支持WP3和OWE，以提高家庭和工作网络以及开放/公共网络的安全性。</p><h2 id="改进的点对点和互联网连接"><a href="#改进的点对点和互联网连接" class="headerlink" title="改进的点对点和互联网连接"></a>改进的点对点和互联网连接</h2><p>在Android Q中，我们重构了Wi-Fi堆栈，以改善隐私和性能，但也改善了常见的用例，比如管理物联网设备和建议互联网连接——不需要位置许可。</p><p>网络连接api使得通过本地Wi-Fi管理物联网设备变得更加容易，可以实现配置、下载或打印等对等功能。应用程序通过指定首选的ssid和bssid作为<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvbmV0L05ldHdvcmtTcGVjaWZpZXIuaHRtbA==" title="https://developer.android.com/reference/android/net/NetworkSpecifier.html">WiFiNetworkSpecifiers<i class="fa fa-external-link"></i></span>间接启动连接请求。该平台自己处理Wi-Fi扫描，并在Wi-Fi选择器中显示匹配的网络。当用户选择时，平台会自动设置连接。</p><p>网络建议api允许应用程序在互联网连接方面显示用户更喜欢的Wi-Fi网络。应用程序通过提供网络和证书列表作为<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvbmV0L3dpZmkvV2lmaU5ldHdvcmtTdWdnZXN0aW9u" title="https://developer.android.com/reference/android/net/wifi/WifiNetworkSuggestion">WifiNetworkSuggestion<i class="fa fa-external-link"></i></span>来间接启动连接。该平台将基于过去的性能无缝连接时，在这些网络范围。</p><h2 id="Wi-Fi-性能模式"><a href="#Wi-Fi-性能模式" class="headerlink" title="Wi-Fi 性能模式"></a>Wi-Fi 性能模式</h2><p>现在你可以在Android Q中通过启用高性能和低延迟模式来请求自适应Wi-Fi。在低延迟对用户体验非常重要的情况下，如实时游戏、活动语音呼叫和类似的用例，这些将非常有用。</p><p>要使用新的性能模式，请使用WIFI_MODE_FULL_LOW_LATENCY或WIFI_MODE_FULL_HIGH_PERF调用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvbmV0L3dpZmkvV2lmaU1hbmFnZXIuaHRtbCNjcmVhdGVXaWZpTG9jayhpbnQsJTIwamF2YS5sYW5nLlN0cmluZyk=" title="https://developer.android.com/reference/android/net/wifi/WifiManager.html#createWifiLock(int,%20java.lang.String)">WifiManager.WifiLock.createWifiLock()<i class="fa fa-external-link"></i></span>。在这些模式下，平台与设备固件协同工作，以满足功耗最低的要求。</p><h1 id="相机、媒体、图形"><a href="#相机、媒体、图形" class="headerlink" title="相机、媒体、图形"></a>相机、媒体、图形</h1><h2 id="动态深度格式的照片"><a href="#动态深度格式的照片" class="headerlink" title="动态深度格式的照片"></a>动态深度格式的照片</h2><p>许多移动设备上的相机可以通过模糊前景或背景来模拟较窄的景深。它们为图像中的不同点捕获深度元数据，并对图像应用静态模糊，然后丢弃深度元数据。</p><p>从Android Q开始，应用程序可以请求一个动态深度图像，该图像由一个JPEG、XMP元数据(与深度相关的元素相关)和一个深度和置信度地图组成，这些数据嵌入到宣传支持的设备的同一个文件中。</p><p>要求JPEG +动态深度图像可以让你在你的应用程序中提供专门的模糊和bokeh选项。你甚至可以使用这些数据来创建3D图像或支持AR摄影用例。我们正在使动态深度成为生态系统的一种开放格式，我们正在与我们的设备制造商合作伙伴合作，使其在运行Android Q及更高版本的设备上可用。</p><p><img alt="q_depth_image_x.jpg" data-src="/images/q_depth_image_x.jpg"></p><p><img alt="q_depth_image_xx.jpg" data-src="/images/q_depth_image_xx.jpg"></p><p><img alt="q_depth_image_xxx.jpg" data-src="/images/q_depth_image_xxx.jpg"></p><p>使用动态深度图像，你可以在你的应用程序中提供专门的模糊和背景虚化选项。</p><h2 id="新的音频和视频编解码器"><a href="#新的音频和视频编解码器" class="headerlink" title="新的音频和视频编解码器"></a>新的音频和视频编解码器</h2><p>Android Q引入了对开源视频编解码器<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQVYx" title="https://en.wikipedia.org/wiki/AV1">AV1<i class="fa fa-external-link"></i></span>的支持。这使得媒体供应商可以用<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQVYxI1F1YWxpdHlfYW5kX2VmZmljaWVuY3k=" title="https://en.wikipedia.org/wiki/AV1#Quality_and_efficiency">更少的带宽<i class="fa fa-external-link"></i></span>向Android设备传输高质量的视频内容。此外，Android Q支持使用<span class="exturl" data-url="aHR0cDovL29wdXMtY29kZWMub3JnLw==" title="http://opus-codec.org/">Opus<i class="fa fa-external-link"></i></span>进行音频编码，Opus是一种针对语音和音乐流媒体进行优化的编解码器，<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGlnaC1keW5hbWljLXJhbmdlX3ZpZGVvI0hEUjEwKw==" title="https://en.wikipedia.org/wiki/High-dynamic-range_video#HDR10+">HDR10+<i class="fa fa-external-link"></i></span>用于支持Opus的设备上的高动态范围视频。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvbWVkaWEvTWVkaWFDb2RlY0luZm8=" title="https://developer.android.com/reference/android/media/MediaCodecInfo">MediaCodecInfo API<i class="fa fa-external-link"></i></span>引入了一种更简单的方法来确定Android设备的视频呈现能力。对于任何给定的编解码器，都可以使用VideoCodecCapabilities.getSupportedPerformancePoints()获得支持的大小和帧速率列表。这允许您选择在任何给定设备上呈现的最佳质量的视频内容。</p><h2 id="Vulkan上的ANGLE"><a href="#Vulkan上的ANGLE" class="headerlink" title="Vulkan上的ANGLE"></a>Vulkan上的ANGLE</h2><p>为了使游戏和图形开发人员更加一致，我们正在为所有基于Vulkan的设备开发一个标准的、可更新的OpenGL驱动程序。在Android Q中，我们在Android设备的Vulkan之上添加了对<span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2FuZ2xlL2FuZ2xlLysvbWFzdGVyL1JFQURNRS5tZA==" title="https://chromium.googlesource.com/angle/angle/+/master/README.md">ANGLE<i class="fa fa-external-link"></i></span>的实验性支持。ANGLE是一个图形抽象层，用于实现高性能的OpenGL兼容性。通过angular，许多使用OpenGL ES的应用程序和游戏都可以利用Vulkan的性能和稳定性，并从Android设备上对ES的一致、独立于供应商的实现中获益。在Android Q中，我们计划支持OpenGL ES 2.0，下一步将支持ES 3.0。</p><p>我们将使用更多OpenGL功能、bug修复和性能优化来扩展实现。有关Android中当前角度支持的详细信息，如何使用它，以及我们未来的计划，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcyNhbmdsZQ==" title="https://developer.android.com/preview/features#angle">文档<i class="fa fa-external-link"></i></span>。您可以通过“设置”中的“开发人员选项”选择我们的初始支持来开始测试。今天就试试吧!</p><h2 id="Vulkan-无处不在"><a href="#Vulkan-无处不在" class="headerlink" title="Vulkan 无处不在"></a>Vulkan 无处不在</h2><p>我们正在继续扩大<span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvdnVsa2FuLw==" title="https://www.khronos.org/vulkan/">Vulkan<i class="fa fa-external-link"></i></span>对Android的影响，我们为高性能3D图形<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vbmRrL2d1aWRlcy9ncmFwaGljcy8=" title="https://developer.android.com/ndk/guides/graphics/">实现了<i class="fa fa-external-link"></i></span>低开销、跨平台的API。我们的目标是使Android上的Vulkan成为一个广泛支持的、一致的图形开发人员API。我们正在与我们的设备制造商合作伙伴共同努力，使Vulkan 1.1成为所有运行Android Q或更高版本的64位设备的要求，并成为所有32位设备的推荐标准。未来，这将有助于为应用程序和游戏提供统一的高性能图形API。</p><h2 id="神经网络-API-1-2"><a href="#神经网络-API-1-2" class="headerlink" title="神经网络 API 1.2"></a>神经网络 API 1.2</h2><p>自2017年推出神经网络API (NNAPI)以来，我们继续扩大支持的操作数量，并改进现有功能。在Android Q中，我们增加了60个新操作，包括ARGMAX, ARGMIN，量化LSTM，以及一系列的性能优化。这为加速更大范围的模型奠定了基础，比如用于目标检测和图像分割的模型。我们正在与硬件供应商和流行的机器学习框架(如<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcv" title="https://www.tensorflow.org/">TensorFlow<i class="fa fa-external-link"></i></span>)合作，优化和推出对NNAPI 1.2的支持。</p><h1 id="Android基础的加强"><a href="#Android基础的加强" class="headerlink" title="Android基础的加强"></a>Android基础的加强</h1><h2 id="ART-性能"><a href="#ART-性能" class="headerlink" title="ART 性能"></a>ART 性能</h2><p>Android Q对ART运行时进行了几项新的改进，帮助应用程序更快地启动并消耗更少的内存，而不需要开发人员做任何工作。</p><p>自Android Nougat以来，ART提供了<span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vZGV2aWNlcy90ZWNoL2RhbHZpay9qaXQtY29tcGlsZXI=" title="https://source.android.com/devices/tech/dalvik/jit-compiler">Profile Guided Optimization <i class="fa fa-external-link"></i></span>(PGO)，它通过识别和预编译代码中经常执行的部分，随着时间的推移加快了应用程序的启动速度。为了帮助最初的应用程序启动，谷歌Play现在提供了基于云的配置文件和apk。这些都是匿名的、聚合的艺术配置文件，可以让艺术在应用程序运行之前预先编译应用程序的某些部分，从而为整个优化过程提供了一个重要的起点。基于云的配置文件对所有应用程序都有好处，而且运行Android P或更高版本的设备已经可以使用这些配置文件。</p><p><img alt="android_q_art" data-src="/images/android_q_art.png"></p><p>我们还在继续改进ART本身。例如，在Android Q中，我们通过提前启动应用程序进程并将其移至安全容器来优化Zygote进程，因此可以立即启动。 我们将更多信息存储在应用程序的堆映像中，例如类，并使用线程来更快地加载映像。 我们还在ART的Concurrent Copying（CC）垃圾收集器中添加了Generational Garbage Collection。 分代CC更有效率，因为它分别收集年轻代对象，与全堆GC相比，成本更低，同时仍然可以回收大量空间。 这使得垃圾收集整体上在时间和CPU方面更加高效，减少了jank并帮助应用程序在低端设备上更好地运行。</p><h2 id="应用安全"><a href="#应用安全" class="headerlink" title="应用安全"></a>应用安全</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvaGFyZHdhcmUvYmlvbWV0cmljcy9wYWNrYWdlLXN1bW1hcnk=" title="https://developer.android.com/reference/android/hardware/biometrics/package-summary">BiometricPrompt<i class="fa fa-external-link"></i></span>是我们的统一认证框架，支持系统级的生物识别。在Android Q中，我们扩展了对被动身份验证方法(如face)的支持，并添加了隐式和显式身份验证流。在显式流中，用户必须在身份验证期间显式地确认TEE中的事务。隐式流是为使用被动身份验证的事务设计的轻量级替代方案。我们还改进了设备凭据在需要时的回退。</p><p>Android Q增加了对TLS 1.3的支持，<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWV0Zi5vcmcvYmxvZy90bHMxMy8=" title="https://www.ietf.org/blog/tls13/">TLS 1.3<i class="fa fa-external-link"></i></span>是对TLS标准的重大修订，包括性能优势和增强的安全性。 我们的基准测试表明，与TLS 1.2相比，使用TLS 1.3可以将安全连接的速度提高40％。 默认情况下，为所有TLS连接启用TLS 1.3。 有关详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcyN0bHMtMS4z" title="https://developer.android.com/preview/features#tls-1.3">文档<i class="fa fa-external-link"></i></span>。</p><h2 id="通过公共api的兼容性"><a href="#通过公共api的兼容性" class="headerlink" title="通过公共api的兼容性"></a>通过公共api的兼容性</h2><p>我们都关心的另一件事是确保应用程序在操作系统变化和发展的过程中运行顺畅。使用非sdk api的应用程序对用户有崩溃的风险，对开发人员有紧急推出的风险。在Android Q中，我们将继续从<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vYWJvdXQvdmVyc2lvbnMvcGllL3Jlc3RyaWN0aW9ucy1ub24tc2RrLWludGVyZmFjZXM=" title="https://developer.android.com/about/versions/pie/restrictions-non-sdk-interfaces">Android P开始<i class="fa fa-external-link"></i></span>的长期努力，将应用程序转向只使用公共api。我们知道将您的应用程序从非sdk api中移除需要时间，所以我们<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOC8wNi9hbi11cGRhdGUtb24tbm9uLXNkay1yZXN0cmljdGlvbnMtaW4uaHRtbA==" title="https://android-developers.googleblog.com/2018/06/an-update-on-non-sdk-restrictions-in.html">提前通知您<i class="fa fa-external-link"></i></span>。</p><p>在Android Q中，我们限制了对<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9ub24tc2RrLXEjZ3JleWxpc3Qtbm93LXJlc3RyaWN0ZWQ=" title="https://developer.android.com/preview/non-sdk-q#greylist-now-restricted">更多非sdk接口<i class="fa fa-external-link"></i></span>的访问，并要求您使用公共接口。为了帮助您进行转换并防止您的应用程序崩溃，我们只在您的应用程序针对Android q时启用这些限制。我们将根据您的请求继续添加公共替代api;如果没有符合您用例的公共API，请让<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0zMjg0MDMmdGVtcGxhdGU9MTAyNzI2Nw==" title="https://issuetracker.google.com/issues/new?component=328403&template=1027267">我们知道<i class="fa fa-external-link"></i></span>。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZGlzdHJpYnV0ZS9iZXN0LXByYWN0aWNlcy9kZXZlbG9wL3Jlc3RyaWN0aW9ucy1ub24tc2RrLWludGVyZmFjZXMjdGVzdC1mb3Itbm9uLXNkaw==" title="https://developer.android.com/distribute/best-practices/develop/restrictions-non-sdk-interfaces#test-for-non-sdk">测试应用程序<i class="fa fa-external-link"></i></span>是否使用非sdk接口非常重要。我们建议使用StrictMode方法<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvb3MvU3RyaWN0TW9kZS5WbVBvbGljeS5CdWlsZGVyI2RldGVjdE5vblNka0FwaVVzYWdlKCk=" title="https://developer.android.com/reference/android/os/StrictMode.VmPolicy.Builder#detectNonSdkApiUsage()">detectNonSdkApiUsage()<i class="fa fa-external-link"></i></span>在应用程序通过反射或JNI访问非sdk api时发出警告。即使api此时被豁免(灰色列表)，最好还是为将来做好计划，并消除对它们的使用，以减少兼容性问题。有关Android Q中限制的更多细节，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9ub24tc2RrLXE=" title="https://developer.android.com/preview/non-sdk-q">开发人员指南<i class="fa fa-external-link"></i></span>。</p><h2 id="现代化安卓"><a href="#现代化安卓" class="headerlink" title="现代化安卓"></a>现代化安卓</h2><p>我们正在努力让所有应用程序充分利用最新版本Android的安全和性能特性。今年晚些时候，谷歌Play将要求你在新应用和更新中把应用的<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOS8wMi9leHBhbmRpbmctdGFyZ2V0LWFwaS1sZXZlbC1yZXF1aXJlbWVudHMuaHRtbA==" title="https://android-developers.googleblog.com/2019/02/expanding-target-api-level-requirements.html">targetSdkVersion设置为28<i class="fa fa-external-link"></i></span> (Android 9 Pie)。根据这些变化，Android Q将在用户首次运行针对API级别23 (Android Marshmallow)之前的平台的应用程序时，用对话框警告用户。下面是帮助您迁移应用程序的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZGlzdHJpYnV0ZS9iZXN0LXByYWN0aWNlcy9kZXZlbG9wL3RhcmdldC1zZGsuaHRtbA==" title="https://developer.android.com/distribute/best-practices/develop/target-sdk.html">资源清单<i class="fa fa-external-link"></i></span>。</p><p>我们还在推动生态系统为64位设备做好准备。今年晚些时候，谷歌Play将要求<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOS8wMS9nZXQteW91ci1hcHBzLXJlYWR5LWZvci02NC1iaXQuaHRtbA==" title="https://android-developers.googleblog.com/2019/01/get-your-apps-ready-for-64-bit.html">所有应用程序都支持64位<i class="fa fa-external-link"></i></span>。如果您的应用程序使用本地sdk或库，请记住，您需要提供这些sdk或库的64位兼容版本。有关如何准备的详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZGlzdHJpYnV0ZS9iZXN0LXByYWN0aWNlcy9kZXZlbG9wLzY0LWJpdA==" title="https://developer.android.com/distribute/best-practices/develop/64-bit">开发人员指南<i class="fa fa-external-link"></i></span>。</p><h1 id="开始使用Android-Q测试版"><a href="#开始使用Android-Q测试版" class="headerlink" title="开始使用Android Q测试版"></a>开始使用Android Q测试版</h1><p>对于可能影响您的应用程序的重要隐私特性，我们建议您立即开始测试。特别是，您希望启用和测试Android Q存储更改、新位置权限状态、后台应用程序启动的限制和设备标识符的限制。有关详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5" title="https://developer.android.com/preview/privacy">隐私文档<i class="fa fa-external-link"></i></span>。</p><p>首先，只需将您当前的应用程序从谷歌Play安装到运行Android Q Beta版的设备或Android<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3J1bi9tYW5hZ2luZy1hdmRzLmh0bWw=" title="https://developer.android.com/studio/run/managing-avds.html">虚拟设备<i class="fa fa-external-link"></i></span>上，并处理用户流。该应用程序应该运行良好，看起来很棒，并正确处理所有应用程序的Android Q<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9iZWhhdmlvci1jaGFuZ2VzLWFsbA==" title="https://developer.android.com/preview/behavior-changes-all">行为变化<i class="fa fa-external-link"></i></span>。如果你发现问题，我们建议你在当前的应用程序中修复它们，而不改变你的目标水平。查看<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9taWdyYXRpb24uaHRtbA==" title="https://developer.android.com/preview/migration.html">迁移指南<i class="fa fa-external-link"></i></span>中的步骤和建议的时间线。</p><h1 id="探索新特性和api"><a href="#探索新特性和api" class="headerlink" title="探索新特性和api"></a>探索新特性和api</h1><p>当你准备好了，深入Android Q，了解你可以在你的应用程序中使用的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcw==" title="https://developer.android.com/preview/features">新功能和api<i class="fa fa-external-link"></i></span>。以<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc2RrL2FwaV9kaWZmL3EtYmV0YTEvY2hhbmdlcy5odG1s" title="https://developer.android.com/sdk/api_diff/q-beta1/changes.html">API diff报告<i class="fa fa-external-link"></i></span>、Android Q Beta <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL3BhY2thZ2VzLmh0bWw=" title="https://developer.android.com/reference/packages.html">API参考<i class="fa fa-external-link"></i></span>和开发人员指南作为起点。另外，在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9pbmRleC5odG1s" title="https://developer.android.com/preview/index.html">Android Q Beta开发人员站点<i class="fa fa-external-link"></i></span>上，您可以找到<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9yZWxlYXNlLW5vdGVzLmh0bWw=" title="https://developer.android.com/preview/release-notes.html">发布说明<i class="fa fa-external-link"></i></span>和报告问题的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWVkYmFjay5odG1s" title="https://developer.android.com/preview/feedback.html">支持资源<i class="fa fa-external-link"></i></span>。</p><p>要使用Android Q进行构建，请下载Android Q Beta SDK和工具到Android Studio 3.3或更高版本中，并按照<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9zZXR1cC1zZGs=" title="https://developer.android.com/preview/setup-sdk">以下<i class="fa fa-external-link"></i></span>说明配置您的环境。如果你想要最新的修复Android Q相关的变化，我们建议你使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3ByZXZpZXcv" title="https://developer.android.com/studio/preview/">Android Studio 3.5<i class="fa fa-external-link"></i></span>或更高版本。</p><h1 id="我如何得到Android-Q测试版"><a href="#我如何得到Android-Q测试版" class="headerlink" title="我如何得到Android Q测试版?"></a>我如何得到Android Q测试版?</h1><p>这很简单——你可以在<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9hbmRyb2lkL2JldGE=" title="https://www.google.com/android/beta">这里注册<i class="fa fa-external-link"></i></span>，在任何像素设备上通过无线方式获得Android Q Beta更新(今年我们支持所有三代Pixel—Pixel3、Pixel2，甚至原始Pixel!)还<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9kb3dubG9hZA==" title="https://developer.android.com/preview/download">可以<i class="fa fa-external-link"></i></span>下载这些设备的系统映像。如果没有Pixel设备，可以使用Android模拟器，并通过Android Studio中的SDK Manager下载最新的模拟器系统镜像。</p><p>我们计划在整个预览过程中定期更新预览系统图像和SDK。随着Beta版程序的推进，我们将有更多的功能可以分享。</p><p>一如既往，你的反馈是至关重要的，所以请<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWVkYmFjay5odG1s" title="https://developer.android.com/preview/feedback.html">让我们知道你的想法<i class="fa fa-external-link"></i></span>——我们越早收到你的反馈，我们就能整合更多的反馈。当您发现问题时，请在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9idWc=" title="https://developer.android.com/preview/bug">这里报告<i class="fa fa-external-link"></i></span>。我们有单独的热门列表来归档<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0xOTA2MDImdGVtcGxhdGU9MTIyNjU3Mw==" title="https://issuetracker.google.com/issues/new?component=190602&template=1226573">平台问题<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0xOTA2MDImdGVtcGxhdGU9MTIyNzM3Ng==" title="https://issuetracker.google.com/issues/new?component=190602&template=1227376">应用程序兼容性问题<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0xOTA2MDImdGVtcGxhdGU9MTIyNzU4Mw==" title="https://issuetracker.google.com/issues/new?component=190602&template=1227583">第三方SDK问题<i class="fa fa-external-link"></i></span>。</p><blockquote><p>以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自: &lt;a href=&quot;https://android-developers.googleblog.com/2019/03/introducing-android-q-beta.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introducing Android Q Beta&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack WorkManager 稳定发布</title>
    <link href="https://shoewann0402.github.io/2019/03/06/android-jetpack-workmanager-stable/"/>
    <id>https://shoewann0402.github.io/2019/03/06/android-jetpack-workmanager-stable/</id>
    <published>2019-03-06T07:37:35.000Z</published>
    <updated>2019-03-11T09:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自: <span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOS8wMy9hbmRyb2lkLWpldHBhY2std29ya21hbmFnZXItc3RhYmxlLmh0bWw=" title="https://android-developers.googleblog.com/2019/03/android-jetpack-workmanager-stable.html">Android Jetpack WorkManager Stable Release<i class="fa fa-external-link"></i></span></p></blockquote><a id="more"></a><p><strong>使用WorkManager的方式简化您的后台管理</strong></p><p>今天我们非常高兴的宣布<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS93b3JrbWFuYWdlcg==" title="https://developer.android.com/topic/libraries/architecture/workmanager">Android Jetpack WorkManager<i class="fa fa-external-link"></i></span> 1.0 稳定版发布。我们想感谢许多在我们开发社区的您，一路上为我们给予反馈和bug记录 —— 我们到达了这里，感谢您的帮助！</p><p>当我们通过开发者看到面临的主要问题时，我们看见了做可靠的后台处理和友好的电量管理是一个巨大的挑战。这意味着定期刷新内容或者上传您的日志是复杂的。不同的Android版本为工作提供了不同的工具，它们每一个都有自己怪异的API。比如说，监听网络或者存储可用性以及自动重试您的任务涉及到大量工作。</p><p>我们对于这些挑战的回答是WorkManager。在Google <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1JcktvQkZMd1ROMA==" title="https://www.youtube.com/watch?v=IrKoBFLwTN0">I/O 2018<i class="fa fa-external-link"></i></span>上，我们介绍了Android Jetpack <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS93b3JrbWFuYWdlcg==" title="https://developer.android.com/topic/libraries/architecture/workmanager">WorkManager库<i class="fa fa-external-link"></i></span>的预览,并且从那之后在它上面迭代了额外的功能核和bug修复，感谢您宝贵的意见。</p><p>WorkManager的目标就是为了您操作后台使其简单。WorkManager考虑到了像电量优化、存储或者网络可用性的约束，同事当满足适当的条件它只能运行它的任务。它也知道去重试或者重新调度您的工作——即使您的设备或者app重启了。</p><p>我们相信ＷOrkManager是友好的，亲切的API,能够处理好Android最复杂的部分之一，您可以将焦点放在让您的App独特代码上。</p><h2 id="WorkManager-亮点"><a href="#WorkManager-亮点" class="headerlink" title="ＷorkManager 亮点"></a>ＷorkManager 亮点</h2><p>这里是WorkManager一些关键点：</p><blockquote><ul><li>让您设置约束，比如网络状态或者充电状态、任务在运行时</li><li>支持异步一次性和周期性</li><li>支持带输入和输出的链式任务</li><li>确保任务执行，及时APP或者设备重启</li><li>支持Android 4.0+ (API 14+)</li></ul></blockquote><p>观看和阅读下面去学习在您的APP里面什么时候以及如何使用WorkManager去简化管理后台工作</p><p><img alt="android_jetpack_introducing_workmanager" data-src="/images/android_jetpack_introducing_workmanager.png"></p><p><span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9wZV95cU0xNmhQUQ==" title="https://youtu.be/pe_yqM16hPQ">Android Jetpack: 介绍WorkManager<i class="fa fa-external-link"></i></span></p><h2 id="何时使用-WorkManager"><a href="#何时使用-WorkManager" class="headerlink" title="何时使用 WorkManager"></a>何时使用 WorkManager</h2><p>WorkManager是针对于能够被延期任务的最佳套件，但是即使是应用程序或者设备重启(比如: 使用后端服务定期同步数据以及上传日志或者分析数据) 也是仍然有望运行</p><p>对于像需要立即运行去发送即时消息或者APP在退出之后不需要立即运行的任务，去看看<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvYmFja2dyb3VuZC8=" title="https://developer.android.com/guide/background/">后台处理向导 <i class="fa fa-external-link"></i></span>了解哪一种解决方案满足您的需求。</p><h2 id="如何使用-WorkManager"><a href="#如何使用-WorkManager" class="headerlink" title="如何使用 WorkManager"></a>如何使用 WorkManager</h2><p>开始使用WorkManager API, 添加在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL2J1aWxkL2RlcGVuZGVuY2llcyNnb29nbGUtbWF2ZW4=" title="https://developer.android.com/studio/build/dependencies#google-maven">Google’s Maven repository<i class="fa fa-external-link"></i></span>上WorkManager可用的Java或者Kotlin依赖到您应用程序的<code>build.gradle</code>文件:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">def</span> work_version = <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java</span></span><br><span class="line">    implementation <span class="string">"android.arch.work:work-runtime:$work_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin KTX + coroutines</span></span><br><span class="line">    implementation <span class="string">"android.arch.work:work-runtime-ktx:$work_version"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>现在，只需要将<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWR4L3dvcmsvV29ya2Vy" title="https://developer.android.com/reference/androidx/work/Worker">Worker<i class="fa fa-external-link"></i></span>子类化并利用<strong>doWork()</strong>实现您的后台工作，并用WorkManager加入列队。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWorker</span></span>(ctx: Context, params: WorkerParameters)</span><br><span class="line">  : Worker(ctx, params) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> WorkerResult <span class="title">doWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//在这里完成一些需要在后台处理的工作</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">return</span> Result.success()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选, 添加像电源、网络可用性的约束</span></span><br><span class="line"><span class="keyword">val</span> constraints: Constraints = Constraints.Builder()</span><br><span class="line">     .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">                .setRequiredNetworkType(NetworkType.CONNECTED)</span><br><span class="line">                .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myWork = OneTimeWorkRequestBuilder&lt;MyWorker&gt;()</span><br><span class="line">                .setConstraints(constraints).build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，列队您的工作</span></span><br><span class="line">WorkManager.getInstance().enqueue(myWork)</span><br></pre></td></tr></table></figure><p>WorkManager当识别到您的设备正在充电且网络是可用时，它将负责运行您的任务。</p><h2 id="为何使用-WorkManager"><a href="#为何使用-WorkManager" class="headerlink" title="为何使用 WorkManager"></a>为何使用 WorkManager</h2><h3 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h3><p>WorkManager将利用正确的调度API:它使用了<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXBwL2pvYi9Kb2JTY2hlZHVsZXI=" title="https://developer.android.com/reference/android/app/job/JobScheduler">JobScheduler API<i class="fa fa-external-link"></i></span>在Android 6.0+ (API 23+)并且结合了之前版本上的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXBwL0FsYXJtTWFuYWdlcg==" title="https://developer.android.com/reference/android/app/AlarmManager">AlarmManager<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvY29udGVudC9Ccm9hZGNhc3RSZWNlaXZlcg==" title="https://developer.android.com/reference/android/content/BroadcastReceiver">BroadcastReceiver<i class="fa fa-external-link"></i></span></p><p>它也力求最佳行为，这样它就符合了在较新的Android API版本中引入系统优化去最大化电量和强制执行良好的APP行为。</p><p>比如说，当系统是进入了Doze 模式时，对于Android 6.0+(API 23+)的设备，WorkManager将在维护窗口期间调度后台工作。</p><h3 id="可靠的调度"><a href="#可靠的调度" class="headerlink" title="可靠的调度"></a>可靠的调度</h3><p>利用WorkManager,您能够简单的添加像网络可用性或者充电状态的约束。当约束满足您的工作将会运行，并且如果在运行的过程中它们失败了将会自动重试。比如说，如果您的任务要求网络可用，当网络不再可用时任务将会停止并且之后重试。</p><p>您也能够使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9saXZlZGF0YQ==" title="https://developer.android.com/topic/libraries/architecture/livedata">LiveData<i class="fa fa-external-link"></i></span>监控工作状态和检索工作结果。当您的任务完成时，这样可以通知您的UI。</p><p>您的工作失败了的情况下，您可用通过配置<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWR4L3dvcmsvQmFja29mZlBvbGljeQ==" title="https://developer.android.com/reference/androidx/work/BackoffPolicy">backoff(退避)<i class="fa fa-external-link"></i></span>的处理方式来控制您的工作重试方式</p><p>WorkManager也能够重新调度您的工作，如果一个应用程序或者设备重启发生了，使用本地数据库记录您的工作。</p><h3 id="控制您的工作方式"><a href="#控制您的工作方式" class="headerlink" title="控制您的工作方式"></a>控制您的工作方式</h3><p>我们明白每一个APP有不同的需求，您的任务也如此——甚至是在同一个APP内。WorkManager提供了简单但高度灵活的API表面，可以帮助您配置您的工作和运行它的方式。</p><p>利用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWR4L3dvcmsvT25lVGltZVdvcmtSZXF1ZXN0Lmh0bWw=" title="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest.html">OneTimeWorkRequest<i class="fa fa-external-link"></i></span>一次性调度或者<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWR4L3dvcmsvUGVyaW9kaWNXb3JrUmVxdWVzdA==" title="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest">PeriodicWorkRequest<i class="fa fa-external-link"></i></span>周期性调度</p><p>您也能够链接您的一次工作请求以按顺序或并行运行。如果任意链接工作失败，WorkManager力求确保剩下的工作链不会运行。阅读更多关于链接工作请求<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS93b3JrbWFuYWdlci9ob3ctdG8vY2hhaW4td29yay5tZA==" title="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/chain-work.md">这里<i class="fa fa-external-link"></i></span></p><p>如果您需要更多灵活性的WorkManager并行化方式以及消息工作，检出我们<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS93b3JrbWFuYWdlci9hZHZhbmNlZC90aHJlYWRpbmcubWQ=" title="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/threading.md">高级线程向导<i class="fa fa-external-link"></i></span></p><h2 id="开发者有说什么"><a href="#开发者有说什么" class="headerlink" title="开发者有说什么"></a>开发者有说什么</h2><p><span class="exturl" data-url="aHR0cHM6Ly9wbGF5Lmdvb2dsZS5jb20vc3RvcmUvYXBwcy9kZXRhaWxzP2lkPWluLnJlZGJ1cy5hbmRyb2lk" title="https://play.google.com/store/apps/details?id=in.redbus.android">redBus<i class="fa fa-external-link"></i></span> ，最大在线巴士票务平台，分享他们使用WorkManager的经验，以简化他们在Android应用中收集用户反馈的方式：</p><blockquote><p><em>“随着我们扩展到其他国家，反馈对于readBus至关重要。一个用户给予了关于在redBus应用程序中功能至关重要的反馈，但是当应用程序尝试去上传反馈到后端，这儿或许没有足够的网络覆盖或者电量</em><br><em>WorkManager简化了redBus应用程序向后端提供信息的方式。WorkManager库处理像网络连接、电量参数的能力以及使用像AlarmManager或者JobScheduler适当的处理程序，使我们能够专注于构建业务逻辑并将执行复杂性卸载到WorkManager</em></p></blockquote><p>   ——  Dinesh Shanmugam</p><p>   Android Lead, redBus.in</p><h2 id="开始使用-WorkManager"><a href="#开始使用-WorkManager" class="headerlink" title="开始使用 WorkManager"></a>开始使用 WorkManager</h2><p>根据您后台任务的需要，检出我们<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS93b3JrbWFuYWdlci9iYXNpY3M=" title="https://developer.android.com/topic/libraries/architecture/workmanager/basics">开始使用向导<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9jb2RlbGFicy5kZXZlbG9wZXJzLmdvb2dsZS5jb20vY29kZWxhYnMvYW5kcm9pZC13b3JrbWFuYWdlci1rdC8jMA==" title="https://codelabs.developers.google.com/codelabs/android-workmanager-kt/#0">codelab<i class="fa fa-external-link"></i></span>动手去使用WorkManager库</p><p>我们欣赏您的反馈，包括您喜欢的新功能以及您希望看到的新功能</p><p>如果您发现了一个bug或者issue,随时<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD00MDk5MDYmdGVtcGxhdGU9MTA5NDE5Nw==" title="https://issuetracker.google.com/issues/new?component=409906&template=1094197">提出问题<i class="fa fa-external-link"></i></span></p><blockquote><p>以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自: &lt;a href=&quot;https://android-developers.googleblog.com/2019/03/android-jetpack-workmanager-stable.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Jetpack WorkManager Stable Release&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Jetpack" scheme="https://shoewann0402.github.io/categories/Android/Jetpack/"/>
    
      <category term="WorkManager" scheme="https://shoewann0402.github.io/categories/Android/Jetpack/WorkManager/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Jetpack" scheme="https://shoewann0402.github.io/tags/Jetpack/"/>
    
      <category term="WorkManager" scheme="https://shoewann0402.github.io/tags/WorkManager/"/>
    
  </entry>
  
  <entry>
    <title>Android P 默认通过TLS保护用户</title>
    <link href="https://shoewann0402.github.io/2018/04/11/protecting-users-with-tls-by-default-in/"/>
    <id>https://shoewann0402.github.io/2018/04/11/protecting-users-with-tls-by-default-in/</id>
    <published>2018-04-11T14:29:28.000Z</published>
    <updated>2019-03-11T09:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOC8wNC9wcm90ZWN0aW5nLXVzZXJzLXdpdGgtdGxzLWJ5LWRlZmF1bHQtaW4uaHRtbA==" title="https://android-developers.googleblog.com/2018/04/protecting-users-with-tls-by-default-in.html">Protecting users with TLS by default in Android P<i class="fa fa-external-link"></i></span></p></blockquote><p>Android承诺去保持用户他们的设备和数据安全。保持数据安全之一的方式是,通过保护Android设备在进入或者离开中转传输层安全（TLS）的所有数据。正如我们在Android P开发者预览版中<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOC8wMy9wcmV2aWV3aW5nLWFuZHJvaWQtcC5odG1s" title="https://android-developers.googleblog.com/2018/03/previewing-android-p.html">宣布<i class="fa fa-external-link"></i></span>的那样，我们将进一步改善这些保护，通过阻止目标版本是Android P的应用程序来自默认允许未加密的连接。</p><a id="more"></a><p>这是我们为保护Android用户，多年来做出的各种改变。去阻止偶发的未加密连接，在Android Marshmallow(6.0)中我们介绍了android:usesCleartextTraffic清单属性。在Android Nougat(7.0),我们通过创建<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdHJhaW5pbmcvYXJ0aWNsZXMvc2VjdXJpdHktY29uZmlnLmh0bWw=" title="https://developer.android.com/training/articles/security-config.html">Network Security Config<i class="fa fa-external-link"></i></span>(网络安全配置)功能特性去扩展了这个属性，允许应用程序去表明它们不打算在没有加密的情况下发送网络流量。在Android Nougat(7.0)和Android Oreo(8.0)，我们仍然允许明文连接。</p><h1 id="我怎么更新我的应用程序？"><a href="#我怎么更新我的应用程序？" class="headerlink" title="我怎么更新我的应用程序？"></a>我怎么更新我的应用程序？</h1><p>如果你的应用程序对于所有的连接都使用了TLS，然后你不需要做什么了。如果你还没有，就去使用TLS去加密所有的连接更新你的应用程序。如果你仍然需要去使用明文进行连接,继续去阅读一下最佳做法。</p><h1 id="为什么我应该使用TLS？"><a href="#为什么我应该使用TLS？" class="headerlink" title="为什么我应该使用TLS？"></a>为什么我应该使用TLS？</h1><p>Android考虑到所有的网络可能有敌意，因此加密流量应该在所有时间对于所有的连接都被使用。移动设备尤其面临风险，因为它们经常会连接到许多不同的网络，比如在咖啡店的Wi-Fi</p><p>所有的流量应该被加密，无论内容是什么。作为任意一种未加密的连接能够注入内容被使用，对于那些可能弱势的客户端代码增加攻击面，或者攻击用户。更多信息，看我们过去的<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNi8wNC9wcm90ZWN0aW5nLWFnYWluc3QtdW5pbnRlbnRpb25hbC5odG1s" title="https://android-developers.googleblog.com/2016/04/protecting-against-unintentional.html">博客文章<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1mY1dWVjBIYWZ1ayZ0PTFz" title="https://www.youtube.com/watch?v=fcWVV0Hafuk&t=1s">开发者高峰论坛<i class="fa fa-external-link"></i></span></p><h1 id="TLS是不是很慢？"><a href="#TLS是不是很慢？" class="headerlink" title="TLS是不是很慢？"></a>TLS是不是很慢？</h1><p><span class="exturl" data-url="aHR0cHM6Ly9pc3Rsc2Zhc3R5ZXQuY29tLw==" title="https://istlsfastyet.com/">不，它不是<i class="fa fa-external-link"></i></span></p><h1 id="我如何在我的应用程序中使用TLS"><a href="#我如何在我的应用程序中使用TLS" class="headerlink" title="我如何在我的应用程序中使用TLS ?"></a>我如何在我的应用程序中使用TLS ?</h1><p>只要你的服务器支持TLS, 只需要在你的应用程序和服务器响应中把URLs 从http://改变成https:// 。你的HTTP栈处理TLS握手，无需其他更多操作。</p><p>如果你是自己制作的Socket,使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2phdmF4L25ldC9zc2wvU1NMU29ja2V0RmFjdG9yeS5odG1s" title="https://developer.android.com/reference/javax/net/ssl/SSLSocketFactory.html">SSLSocketFactory<i class="fa fa-external-link"></i></span>去替代<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2phdmF4L25ldC9Tb2NrZXRGYWN0b3J5Lmh0bWw=" title="https://developer.android.com/reference/javax/net/SocketFactory.html">SocketFactory<i class="fa fa-external-link"></i></span><br>要格外小心去正确使用作为SSLSocket的socket，它不会去验证主机。你的应用程序需要做的是它自己的主机验证。优选通过调用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2phdmF4L25ldC9zc2wvSHR0cHNVUkxDb25uZWN0aW9uLmh0bWwjZ2V0RGVmYXVsdEhvc3RuYW1lVmVyaWZpZXIoKQ==" title="https://developer.android.com/reference/javax/net/ssl/HttpsURLConnection.html#getDefaultHostnameVerifier()">getDefaultHostnameVerifier()<i class="fa fa-external-link"></i></span>期望的主机名。进一步，谨防<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2phdmF4L25ldC9zc2wvSG9zdG5hbWVWZXJpZmllci5odG1sI3ZlcmlmeShqYXZhLmxhbmcuU3RyaW5nLCUyMGphdmF4Lm5ldC5zc2wuU1NMU2Vzc2lvbik=" title="https://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html#verify(java.lang.String,%20javax.net.ssl.SSLSession)">HostnameVerifier.verify()<i class="fa fa-external-link"></i></span>在发生异常时不会抛出错误，但是相反的會返回一个boolean的结果，你必须明确的检查。</p><h1 id="我需要去使用一个明文去…"><a href="#我需要去使用一个明文去…" class="headerlink" title="我需要去使用一个明文去…"></a>我需要去使用一个明文去…</h1><p>当你应该对所有连接使用TLS，可能你需要去使用一个明文流量针对于遗留原因。比如连接到一些服务器。因此，改变你的应用程序的网络安全配置，以允许这些连接。</p><p>我们包括了一组示例配置，更多帮助查看<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdHJhaW5pbmcvYXJ0aWNsZXMvc2VjdXJpdHktY29uZmlnLmh0bWw=" title="https://developer.android.com/training/articles/security-config.html">network security config<i class="fa fa-external-link"></i></span>文档。</p><h1 id="允许明文连接到一个具体的域，你可以使用如下的配置作为一个向导："><a href="#允许明文连接到一个具体的域，你可以使用如下的配置作为一个向导：" class="headerlink" title="允许明文连接到一个具体的域，你可以使用如下的配置作为一个向导："></a>允许明文连接到一个具体的域，你可以使用如下的配置作为一个向导：</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">domain-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>insecure.example.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>insecure.cdn.example.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">domain-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="允许连接到任意不安全的域"><a href="#允许连接到任意不安全的域" class="headerlink" title="允许连接到任意不安全的域"></a>允许连接到任意不安全的域</h1><p>如果你的应用程序支持打开任意来自不安全URLs的内容，当支持明文连接到任意主机，你应该禁用明文连接到你自己的服务器。记住，对于这些通过<br>不安全连接接收到的数据你应该谨慎，它能够在传输的过程当中被篡改。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">domain-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>example.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>cdn.example2.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">domain-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="我应该怎么更新我的库？"><a href="#我应该怎么更新我的库？" class="headerlink" title="我应该怎么更新我的库？"></a>我应该怎么更新我的库？</h1><p>如果你的库是直接创建安全/不安全的连接，确保它在打开任意明文连接之前通过检查<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvc2VjdXJpdHkvTmV0d29ya1NlY3VyaXR5UG9saWN5Lmh0bWwjaXNDbGVhcnRleHRUcmFmZmljUGVybWl0dGVkKGphdmEubGFuZy5TdHJpbmcp" title="https://developer.android.com/reference/android/security/NetworkSecurityPolicy.html#isCleartextTrafficPermitted(java.lang.String)">isCleartextTrafficPermitted<i class="fa fa-external-link"></i></span>来尊重应用程序明文设置。</p><blockquote><p>以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://android-developers.googleblog.com/2018/04/protecting-users-with-tls-by-default-in.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Protecting users with TLS by default in Android P&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android承诺去保持用户他们的设备和数据安全。保持数据安全之一的方式是,通过保护Android设备在进入或者离开中转传输层安全（TLS）的所有数据。正如我们在Android P开发者预览版中&lt;a href=&quot;https://android-developers.googleblog.com/2018/03/previewing-android-p.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;宣布&lt;/a&gt;的那样，我们将进一步改善这些保护，通过阻止目标版本是Android P的应用程序来自默认允许未加密的连接。&lt;/p&gt;
    
    </summary>
    
      <category term="TLS" scheme="https://shoewann0402.github.io/categories/TLS/"/>
    
      <category term="android p" scheme="https://shoewann0402.github.io/categories/TLS/android-p/"/>
    
    
      <category term="android p" scheme="https://shoewann0402.github.io/tags/android-p/"/>
    
      <category term="android security" scheme="https://shoewann0402.github.io/tags/android-security/"/>
    
      <category term="connection encryption" scheme="https://shoewann0402.github.io/tags/connection-encryption/"/>
    
      <category term="HTTPS" scheme="https://shoewann0402.github.io/tags/HTTPS/"/>
    
      <category term="network security" scheme="https://shoewann0402.github.io/tags/network-security/"/>
    
      <category term="TLS" scheme="https://shoewann0402.github.io/tags/TLS/"/>
    
      <category term="TLS by default" scheme="https://shoewann0402.github.io/tags/TLS-by-default/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 切换到D8 dexer</title>
    <link href="https://shoewann0402.github.io/2018/04/07/android-studio-switching-to-d8-dexer/"/>
    <id>https://shoewann0402.github.io/2018/04/07/android-studio-switching-to-d8-dexer/</id>
    <published>2018-04-07T01:58:21.000Z</published>
    <updated>2019-03-11T09:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOC8wNC9hbmRyb2lkLXN0dWRpby1zd2l0Y2hpbmctdG8tZDgtZGV4ZXIuaHRtbA==" title="https://android-developers.googleblog.com/2018/04/android-studio-switching-to-d8-dexer.html">Android Studio switching to D8 dexer<i class="fa fa-external-link"></i></span></p></blockquote><a id="more"></a><h1 id="D8现在是默认的dex编译器"><a href="#D8现在是默认的dex编译器" class="headerlink" title="D8现在是默认的dex编译器"></a>D8现在是默认的dex编译器</h1><p>更快、更小的应用程序编译一直是Android工具团队的目标，那也是为什么我们此前宣布了<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8wOC9uZXh0LWdlbmVyYXRpb24tZGV4LWNvbXBpbGVyLW5vdy1pbi5odG1s" title="https://android-developers.googleblog.com/2017/08/next-generation-dex-compiler-now-in.html">D8<i class="fa fa-external-link"></i></span>,下一代的dex编译器。相比历史编译器-DX,D8运行更快并生成更小的.dex文件具有相当或者更佳的运行时性能。</p><p>我们最近宣布了D8成为Android Studio 3.1中默认的编译器。如果你之前还没有去尝试D8，我们希望你在切换的时候注意到更佳、更快的dex编译。</p><p>D8首次在Android Studio3.0中作为一个可选的功能被发出。除此之外我们自己也在严格测试，我们现在已经看到了它在各种各样的应用程序中良好的表现。最后，我们确信D8对于每一个开始在3.1中使用他的人来说都将良好运作。然而，如果你在使用的时候有什么问题，你现在能够通过在你的项目gradle.properties文件下一直设置如下还原到DX</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.enableD8=<span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>如果你确实遇到什么问题导致你禁用了D8，请<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0xOTI3MDgmdGVtcGxhdGU9ODQwNTMz" title="https://issuetracker.google.com/issues/new?component=192708&template=840533">让我们知道!<i class="fa fa-external-link"></i></span></p><h1 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h1><p>我们的目标是确保每一个人都能访问到快速、正确的dex编译器。因此避免冒着任一個用户的回归，我们将分为3个阶段去弃用DX</p><p>第一阶段打算防止过早的弃用DX。在这个阶段期间，DX将仍然可以在studio中使用。我们将修复它的关键性问题，但是不会再有新的功能特性了。这个阶段将会持续至少6个月，期间我们将打开任何一个D8的错误去决定如果是回归，将会阻止一些用户使用D8替换DX。第一个阶段直到团队解决完全部的迁移阻滞者问题才会结束。在这个窗口中我们将会特别注意到错误追踪器，因此如果你遭遇任何回归，<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0xOTI3MDgmdGVtcGxhdGU9ODQwNTMz" title="https://issuetracker.google.com/issues/new?component=192708&template=840533">请提出问题<i class="fa fa-external-link"></i></span>。</p><p>一旦我们将查看6个月的窗口没有了D8替换DX的主要回归问题，我们将进入第二阶段。这个阶段将会至少是一年，打算确保那些即使是复杂的项目都有大量时间去进行迁移。在这个阶段期间，我们仍然保持着DX可用，但是我们将它视为完全弃用，我们将不会修复它的任何问题。</p><p>再第三阶段也就是最后阶段，DX将会从Android Studio中移除。在此时，为了能继续使用DX去构建，你将需要使用一个legacy版本的Android Gradle插件。</p><blockquote><p>以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://android-developers.googleblog.com/2018/04/android-studio-switching-to-d8-dexer.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Studio switching to D8 dexer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Dex" scheme="https://shoewann0402.github.io/categories/Dex/"/>
    
      <category term="Android Studio" scheme="https://shoewann0402.github.io/categories/Dex/Android-Studio/"/>
    
    
      <category term="Android Studio" scheme="https://shoewann0402.github.io/tags/Android-Studio/"/>
    
      <category term="Dex" scheme="https://shoewann0402.github.io/tags/Dex/"/>
    
  </entry>
  
  <entry>
    <title>关于Android O 通知渠道总结</title>
    <link href="https://shoewann0402.github.io/2018/01/08/about-android-o-notification-channels/"/>
    <id>https://shoewann0402.github.io/2018/01/08/about-android-o-notification-channels/</id>
    <published>2018-01-08T02:56:22.000Z</published>
    <updated>2019-03-11T09:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于针对Android O 通知渠道的总结。 </p></blockquote><a id="more"></a><p>Android O 引入了通知渠道<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vZ3VpZGUvdG9waWNzL3VpL25vdGlmaWVycy9ub3RpZmljYXRpb25zLmh0bWwjTWFuYWdlQ2hhbm5lbHM=" title="https://developer.android.google.cn/guide/topics/ui/notifiers/notifications.html#ManageChannels">Notification Channels<i class="fa fa-external-link"></i></span>，更好的方便用户管理通知栏消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NotificationChannel</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationChannel</span> </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line"><span class="class">   ↳<span class="title">android</span>.<span class="title">app</span>.<span class="title">NotificationChannel</span></span></span><br></pre></td></tr></table></figure><p>距离上一次总结通知栏相关的东西好像有很久了，可以去<span class="exturl" data-url="aHR0cDovL3Nob2V3YW5uLnRvcC8yMDE2LzA1LzEyL0FuZHJvaWQtTm90aWZpY2F0aW9uLSVFOSU4MCU5QSVFNyU5RiVBNSVFNiVBMCVCNyVFNSVCQyU4RiVFNiU4MCVCQiVFNyVCQiU5My8=" title="http://shoewann.top/2016/05/12/Android-Notification-%E9%80%9A%E7%9F%A5%E6%A0%B7%E5%BC%8F%E6%80%BB%E7%BB%93/">这里查看<i class="fa fa-external-link"></i></span></p><p>今天我们从一个基本的通知示例开始，来总结下Android O 通知渠道相关的使用。</p><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建通知栏管理对象</span></span><br><span class="line">NotificationManager mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line"><span class="comment">//为了版本兼容  选择V7包下的NotificationCompat进行构造</span></span><br><span class="line">NotificationCompat.Builder builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//setTicker 在5.0以上不显示Ticker属性信息</span></span><br><span class="line">builder.setTicker(<span class="string">"状态栏显示的提示"</span>);;</span><br><span class="line"><span class="comment">//setContentTitle 通知栏通知的标题</span></span><br><span class="line">builder.setContentTitle(<span class="string">"内容标题"</span>);</span><br><span class="line"><span class="comment">//setContentText  通知栏通知的详细内容</span></span><br><span class="line">builder.setContentText(<span class="string">"内容文本信息"</span>);</span><br><span class="line"><span class="comment">//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）</span></span><br><span class="line">builder.setAutoCancel(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//setLargeIcon  通知消息上的大图标</span></span><br><span class="line">builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));</span><br><span class="line"><span class="comment">//setSmallIcon  通知上面的小图标</span></span><br><span class="line">builder.setSmallIcon(R.mipmap.ic_launcher);<span class="comment">//小图标</span></span><br><span class="line"><span class="comment">//创建一个意图</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"https://www.baidu.com"</span>));</span><br><span class="line">PendingIntent pIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">1</span>, intent, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//setContentIntent  将意图设置到通知上</span></span><br><span class="line">builder.setContentIntent(pIntent);</span><br><span class="line"><span class="comment">//通知默认的声音 震动 呼吸灯</span></span><br><span class="line">builder.setDefaults(NotificationCompat.DEFAULT_ALL);</span><br><span class="line"><span class="comment">//构建通知</span></span><br><span class="line">Notification notification = builder.build();</span><br><span class="line"><span class="comment">//将构建好的通知添加到通知管理器中，执行通知</span></span><br><span class="line">mNotificationManager.notify(<span class="number">0</span>, notification);</span><br></pre></td></tr></table></figure><p>这段代码很简单，已经添加了注释，没有什么可以说的。</p><h2 id="差异复现"><a href="#差异复现" class="headerlink" title="差异复现"></a>差异复现</h2><h3 id="SDK-lt-8-0-API-26"><a href="#SDK-lt-8-0-API-26" class="headerlink" title="SDK &lt; 8.0(API 26)"></a>SDK &lt; 8.0(API 26)</h3><p>这种情况，上面的示例代码是能无障碍的将通知消息显示出来。</p><h3 id="SDK-gt-8-0-API-26"><a href="#SDK-gt-8-0-API-26" class="headerlink" title="SDK &gt; = 8.0(API 26)"></a>SDK &gt; = 8.0(API 26)</h3><p>这种情况，上面的示例代码，是死活都不会把通知消息显示出来的。</p><p>在Android Oreo上的开发者选项中，新增加了一个<strong>show notification channel warnings</strong>的选项功能，可以通过<strong>Settings</strong> &gt; <strong>System</strong> &gt; <strong>Developer options</strong> 下找到开启。</p><p>再次运行代码后，界面上会弹出类似于下面的这样一个<strong>Toast</strong>,告知你的通知消息post失败，详细情况查看log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Developer warning for package &quot;com.shoewann.notificationsimple&quot; </span><br><span class="line">Failed to post notification on channel &quot;null&quot; </span><br><span class="line">See log for more details</span><br></pre></td></tr></table></figure><p>查看log是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E/NotificationService: No Channel found for pkg=com.shoewann.notificationsimple, channelId=null, id=0, tag=null, opPkg=com.shoewann.notificationsimple, callingUid=10083, userId=0, incomingUserId=0, notificationUid=10083, notification=Notification(channel=null pri=0 contentView=null vibrate=default sound=default tick defaults=0xffffffff flags=0x11 color=0x00000000 vis=PRIVATE)</span><br></pre></td></tr></table></figure><p>通过跟踪查看相关源代码，分析到了，在NotificationCompat这个类中的Builder方法。</p><p>在版本<strong>com.android.support:appcompat-v7:26.1.0</strong>的兼容库中，可以看到传一个参数的<strong>Builder(Context context)</strong>方法已经过期，使用传入两个参数的<strong>Builder(@NonNull Context context, @NonNull String channelId)</strong>新方法代替。</p><p><strong>注意</strong>：该新方法需要传入的这两个参数都是标注了<strong>@NonNull</strong>，也就是<strong>不能传入null</strong>或者<strong>未初始化的变量</strong>。</p><h2 id="兼容代码"><a href="#兼容代码" class="headerlink" title="兼容代码"></a>兼容代码</h2><p>通过以上的分析，也就是我们在Android Oreo上面使用Notification，就必须要为你的Notification创建一个Notification Channels(通知渠道)。</p><h3 id="创建通知渠道"><a href="#创建通知渠道" class="headerlink" title="创建通知渠道"></a>创建通知渠道</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">NotificationCompat.Builder builder = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    NotificationChannel channel = <span class="keyword">new</span> NotificationChannel(<span class="string">"通知渠道ID"</span>,</span><br><span class="line">                    <span class="string">"通知渠道名称"</span>, NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class="line">    channel.enableLights(<span class="keyword">true</span>); <span class="comment">//设置开启指示灯，如果设备有的话</span></span><br><span class="line">    channel.setLightColor(Color.RED); <span class="comment">//设置指示灯颜色</span></span><br><span class="line">    channel.setShowBadge(<span class="keyword">true</span>); <span class="comment">//设置是否显示角标</span></span><br><span class="line">    channel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE);<span class="comment">//设置是否应在锁定屏幕上显示此频道的通知</span></span><br><span class="line">    channel.setDescription(<span class="string">"通知渠道描述"</span>);<span class="comment">//设置渠道描述</span></span><br><span class="line">    channel.setVibrationPattern(<span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">600</span>&#125;);<span class="comment">//设置震动频率</span></span><br><span class="line">    channel.setBypassDnd(<span class="keyword">true</span>);<span class="comment">//设置是否绕过免打扰模式</span></span><br><span class="line">    mNotificationManager.createNotificationChannel(channel);</span><br><span class="line">    createNotificationChannelGroups();</span><br><span class="line">    setNotificationChannelGroups(channel);</span><br><span class="line">    builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">"通知渠道ID"</span>);</span><br><span class="line">    builder.setBadgeIconType(BADGE_ICON_SMALL);<span class="comment">//设置显示角标的样式</span></span><br><span class="line">    builder.setNumber(<span class="number">3</span>);<span class="comment">//设置显示角标的数量</span></span><br><span class="line">    builder.setTimeoutAfter(<span class="number">5000</span>);<span class="comment">//设置通知被创建多长时间之后自动取消通知栏的通知。</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//setContentTitle 通知栏通知的标题</span></span><br><span class="line">builder.setContentTitle(<span class="string">"内容标题"</span>);</span><br><span class="line"><span class="comment">//setContentText  通知栏通知的详细内容</span></span><br><span class="line">builder.setContentText(<span class="string">"内容文本信息"</span>);</span><br><span class="line"><span class="comment">//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）</span></span><br><span class="line">builder.setAutoCancel(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//setLargeIcon  通知消息上的大图标</span></span><br><span class="line">builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));</span><br><span class="line"><span class="comment">//setSmallIcon  通知上面的小图标</span></span><br><span class="line">builder.setSmallIcon(R.mipmap.ic_launcher);<span class="comment">//小图标</span></span><br><span class="line"><span class="comment">//创建一个意图</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"https://www.baidu.com"</span>));</span><br><span class="line">PendingIntent pIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">1</span>, intent, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//setContentIntent  将意图设置到通知上</span></span><br><span class="line">builder.setContentIntent(pIntent);</span><br><span class="line"><span class="comment">//通知默认的声音 震动 呼吸灯</span></span><br><span class="line">builder.setDefaults(NotificationCompat.DEFAULT_ALL);</span><br><span class="line"><span class="comment">//构建通知</span></span><br><span class="line">Notification notification = builder.build();</span><br><span class="line"><span class="comment">//将构建好的通知添加到通知管理器中，执行通知</span></span><br><span class="line">mNotificationManager.notify(<span class="number">0</span>, notification);</span><br></pre></td></tr></table></figure><p>效果图:</p><p><img alt="android-o-notification-channel-1" data-src="/images/android-o-notification-channel-1.png"></p><p>向右滑动通知消息，可以显示延迟本条消息显示和设置选项</p><p><img alt="android-o-notification-channel-2" data-src="/images/android-o-notification-channel-2.png"></p><p>点击左边的延迟本条消息显示的时间</p><p><img alt="android-o-notification-channel-3" data-src="/images/android-o-notification-channel-3.png"></p><p>点击右边的设置选项，可以显示进入操作通知的设置入口</p><p><img alt="android-o-notification-channel-4" data-src="/images/android-o-notification-channel-4.png"></p><p>在桌面上的快捷方式上会显示角标</p><p><img alt="android-o-notification-channel-6" data-src="/images/android-o-notification-channel-6.png"></p><p>长按快捷方式，会在快捷方式旁边弹出通知栏窗口，显示通知栏消息等信息。</p><p><img alt="android-o-notification-channel-7" data-src="/images/android-o-notification-channel-7.png"></p><h3 id="移除通知渠道"><a href="#移除通知渠道" class="headerlink" title="移除通知渠道"></a>移除通知渠道</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    mNotificationManager.deleteNotificationChannel(<span class="string">"通知渠道ID"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳转到通知渠道设置"><a href="#跳转到通知渠道设置" class="headerlink" title="跳转到通知渠道设置"></a>跳转到通知渠道设置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);</span><br><span class="line">    intent.putExtra(Settings.EXTRA_CHANNEL_ID, <span class="string">"通知渠道ID"</span>);</span><br><span class="line">    intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName());</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="android-o-notification-channel-5" data-src="/images/android-o-notification-channel-5.png"></p><h3 id="创建通知渠道组"><a href="#创建通知渠道组" class="headerlink" title="创建通知渠道组"></a>创建通知渠道组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    mNotificationManager.createNotificationChannelGroup(<span class="keyword">new</span> NotificationChannelGroup(<span class="string">"通知渠道组ID"</span>, <span class="string">"通知渠道组名称"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定通知渠道组"><a href="#绑定通知渠道组" class="headerlink" title="绑定通知渠道组"></a>绑定通知渠道组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    channel.setGroup(<span class="string">"通知渠道组ID"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文只是简要的总结了通知渠道的基本用法，还有更多的使用方法，请参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvYXBwL05vdGlmaWNhdGlvbkNoYW5uZWwuaHRtbA==" title="https://developer.android.google.cn/reference/android/app/NotificationChannel.html">Android官方文档-NotificationChannel<i class="fa fa-external-link"></i></span>。关于本文如有不足之处，欢迎指正，谢谢。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是关于针对Android O 通知渠道的总结。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Notification" scheme="https://shoewann0402.github.io/categories/Android/Notification/"/>
    
    
      <category term="Notification Channels" scheme="https://shoewann0402.github.io/tags/Notification-Channels/"/>
    
      <category term="Android O" scheme="https://shoewann0402.github.io/tags/Android-O/"/>
    
      <category term="通知渠道" scheme="https://shoewann0402.github.io/tags/%E9%80%9A%E7%9F%A5%E6%B8%A0%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>关于Android WindowManager行为变化</title>
    <link href="https://shoewann0402.github.io/2018/01/01/about-android-windowmanager-behavior-changes/"/>
    <id>https://shoewann0402.github.io/2018/01/01/about-android-windowmanager-behavior-changes/</id>
    <published>2018-01-01T04:25:14.000Z</published>
    <updated>2019-03-11T09:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于针对Android WindowManager悬浮窗行为变化的总结。</p></blockquote><a id="more"></a><h2 id="官方参考"><a href="#官方参考" class="headerlink" title="官方参考"></a>官方参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLmh0bWw=" title="https://developer.android.google.cn/reference/android/view/WindowManager.html"><strong>WindowManager</strong><i class="fa fa-external-link"></i></span><br>public interface WindowManager<br>implements ViewManager</p><p>android.view.WindowManager</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>首先创建一个简单的WindowManager悬浮窗，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoewann.windowmanager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.PixelFormat;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.Gravity;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.shoewann.windowmanager.view.FloatView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        (findViewById(R.id.btn_show)).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                setUpFloatView();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpFloatView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WindowManager windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);</span><br><span class="line">        FloatView floatView = <span class="keyword">new</span> FloatView(getApplicationContext());</span><br><span class="line">        WindowManager.LayoutParams params = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">        params.type = WindowManager.LayoutParams.TYPE_PHONE;</span><br><span class="line">        params.format = PixelFormat.RGBA_8888;</span><br><span class="line">        params.gravity = Gravity.START | Gravity.TOP;</span><br><span class="line">        params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;</span><br><span class="line">        params.width = <span class="number">200</span>;</span><br><span class="line">        params.height = <span class="number">200</span>;</span><br><span class="line">        params.x = <span class="number">0</span>;</span><br><span class="line">        params.y = <span class="number">0</span>;</span><br><span class="line">        floatView.setImageResource(R.mipmap.ic_launcher_round);</span><br><span class="line">        windowManager.addView(floatView, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码简单易懂，这里就不再进行解释了。</p><p>最后不要忘记了，在AndroidManifest.xml添加所需要的权限。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SYSTEM_ALERT_WINDOW"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="行为变化"><a href="#行为变化" class="headerlink" title="行为变化"></a>行为变化</h2><h3 id="SDK-lt-Android-M"><a href="#SDK-lt-Android-M" class="headerlink" title="SDK &lt; Android M"></a>SDK &lt; Android M</h3><p>以上的示例代码，在这种情况下(比如Kitkat 4.4)的设备上现在就已经可以成功创建出一个系统悬浮窗了。</p><p>运行，效果图如下</p><p><img alt="windowmanager-k" data-src="/images/windowmanager-k.png"></p><h3 id="SDK-gt-Android-M"><a href="#SDK-gt-Android-M" class="headerlink" title="SDK &gt;= Android M"></a>SDK &gt;= Android M</h3><p>到了Android M 之后的设备，也就是targetSdkVersion要指定23(及其以上)，程序就会崩溃，抛出如下异常信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">                  Process: com.shoewann.windowmanager, PID: 3120</span><br><span class="line">                  android.view.WindowManager$BadTokenException: Unable to add window android.view.ViewRootImpl$W@c1fda7 -- permission denied for this window type</span><br><span class="line">                      at android.view.ViewRootImpl.setView(ViewRootImpl.java:591)</span><br><span class="line">                      at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:310)</span><br><span class="line">                      at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:85)</span><br><span class="line">                      at com.shoewann.windowmanager.MainActivity.setUpFloatView(MainActivity.java:39)</span><br><span class="line">                      at com.shoewann.windowmanager.MainActivity$1.onClick(MainActivity.java:21)</span><br><span class="line">                      at android.view.View.performClick(View.java:5198)</span><br><span class="line">                      at android.view.View$PerformClick.run(View.java:21147)</span><br><span class="line">                      at android.os.Handler.handleCallback(Handler.java:739)</span><br><span class="line">                      at android.os.Handler.dispatchMessage(Handler.java:95)</span><br><span class="line">                      at android.os.Looper.loop(Looper.java:148)</span><br><span class="line">                      at android.app.ActivityThread.main(ActivityThread.java:5417)</span><br><span class="line">                      at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">                      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)</span><br><span class="line">                      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)</span><br></pre></td></tr></table></figure><p><strong>参考</strong>:<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvTWFuaWZlc3QucGVybWlzc2lvbi5odG1sI1dSSVRFX1NFVFRJTkdT" title="https://developer.android.google.cn/reference/android/Manifest.permission.html#WRITE_SETTINGS">SYSTEM_ALERT_WINDOW<i class="fa fa-external-link"></i></span></p><blockquote><p>Note: If the app targets API level 23 or higher, the app user must explicitly grant this permission to the app through a permission management screen. The app requests the user’s approval by sending an intent with action ACTION_MANAGE_OVERLAY_PERMISSION. The app can check whether it has this authorization by calling Settings.canDrawOverlays().</p></blockquote><p>官方的解释是，如果你的应用程序目标API等级为23或者更高版本，在使用SYSTEM_ALERT_WINDOW权限时，需要先调用Settings.canDrawOverlays()来判断一下是否允许创建悬浮窗，如果允许的话就可以创建了，不允许的话还要发送一个action值为ACTION_MANAGE_OVERLAY_PERMISSION的Intent来让用户同意创建悬浮窗。</p><p>针对该行为变化，对上面的示例代码进行了修改,添加<strong>权限请求</strong>，以兼容Android M：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoewann.windowmanager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.graphics.PixelFormat;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.provider.Settings;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.Gravity;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.shoewann.windowmanager.view.FloatView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        (findViewById(R.id.btn_show)).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!commonROMPermissionCheck(MainActivity.<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    requestAlertWindowPermission();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setUpFloatView();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpFloatView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"setUpFloatView() called"</span>);</span><br><span class="line">        WindowManager windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);</span><br><span class="line">        FloatView floatView = <span class="keyword">new</span> FloatView(getApplicationContext());</span><br><span class="line">        WindowManager.LayoutParams params = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">        params.type = WindowManager.LayoutParams.TYPE_PHONE;</span><br><span class="line">        params.format = PixelFormat.RGBA_8888;</span><br><span class="line">        params.gravity = Gravity.START | Gravity.TOP;</span><br><span class="line">        params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;</span><br><span class="line">        params.width = <span class="number">200</span>;</span><br><span class="line">        params.height = <span class="number">200</span>;</span><br><span class="line">        params.x = <span class="number">0</span>;</span><br><span class="line">        params.y = <span class="number">0</span>;</span><br><span class="line">        floatView.setImageResource(R.mipmap.ic_launcher_round);</span><br><span class="line">        windowManager.addView(floatView, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_CODE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断权限</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">commonROMPermissionCheck</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"commonROMPermissionCheck() called with: context = ["</span> + context + <span class="string">"]"</span>);</span><br><span class="line">        Boolean result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class clazz = Settings.class;</span><br><span class="line">                Method canDrawOverlays = clazz.getDeclaredMethod(<span class="string">"canDrawOverlays"</span>, Context.class);</span><br><span class="line">                result = (Boolean) canDrawOverlays.invoke(<span class="keyword">null</span>, context);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(TAG, Log.getStackTraceString(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请权限</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestAlertWindowPermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"requestAlertWindowPermission() called"</span>);</span><br><span class="line">        <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</span><br><span class="line">            intent.setData(Uri.parse(<span class="string">"package:"</span> + getPackageName()));</span><br><span class="line">            startActivityForResult(intent, REQUEST_CODE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//处理回调</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Settings.canDrawOverlays(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"onActivityResult granted"</span>);</span><br><span class="line">                    setUpFloatView();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"onActivityResult denied"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行,效果图如下</p><p><img alt="windowmanager-m" data-src="/images/windowmanager-m.png"></p><h4 id="SDK-gt-Android-O"><a href="#SDK-gt-Android-O" class="headerlink" title="SDK &gt;= Android O"></a>SDK &gt;= Android O</h4><p>到了Android O 的设备运行上面在M上二次修改的动态请求权限的代码，程序抛出运行时异常，随后崩溃，这又是为什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">                  Process: com.shoewann.windowmanager, PID: 17929</span><br><span class="line">                  android.view.WindowManager$BadTokenException: Unable to add window android.view.ViewRootImpl$W@d422e7c -- permission denied for window type 2002</span><br><span class="line">                      at android.view.ViewRootImpl.setView(ViewRootImpl.java:789)</span><br><span class="line">                      at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:356)</span><br><span class="line">                      at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:93)</span><br><span class="line">                      at com.shoewann.windowmanager.MainActivity.setUpFloatView(MainActivity.java:54)</span><br><span class="line">                      at com.shoewann.windowmanager.MainActivity$1.onClick(MainActivity.java:34)</span><br><span class="line">                      at android.view.View.performClick(View.java:6294)</span><br><span class="line">                      at android.view.View$PerformClick.run(View.java:24770)</span><br><span class="line">                      at android.os.Handler.handleCallback(Handler.java:790)</span><br><span class="line">                      at android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class="line">                      at android.os.Looper.loop(Looper.java:164)</span><br><span class="line">                      at android.app.ActivityThread.main(ActivityThread.java:6494)</span><br><span class="line">                      at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">                      at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)</span><br><span class="line">                      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)</span><br></pre></td></tr></table></figure><p>查阅Android Oreo官方文档，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vYWJvdXQvdmVyc2lvbnMvb3Jlby9hbmRyb2lkLTguMC1jaGFuZ2VzLmh0bWwjY3d0" title="https://developer.android.google.cn/about/versions/oreo/android-8.0-changes.html#cwt">Alert windows行为变化<i class="fa fa-external-link"></i></span></p><p>应用程序使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvTWFuaWZlc3QucGVybWlzc2lvbi5odG1sI1NZU1RFTV9BTEVSVF9XSU5ET1c=" title="https://developer.android.google.cn/reference/android/Manifest.permission.html#SYSTEM_ALERT_WINDOW">SYSTEM_ALERT_WINDOW<i class="fa fa-external-link"></i></span>权限时，不再支持如下窗口类型在其他应用和系统窗口之上显示警告窗口了：</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfUEhPTkU=" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_PHONE">TYPE_PHONE<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfUFJJT1JJVFlfUEhPTkU=" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_PRIORITY_PHONE">TYPE_PRIORITY_PHONE<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfU1lTVEVNX0FMRVJU" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_SYSTEM_ALERT">TYPE_SYSTEM_ALERT<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfU1lTVEVNX09WRVJMQVk=" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_SYSTEM_OVERLAY">TYPE_SYSTEM_OVERLAY<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfU1lTVEVNX0VSUk9S" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_SYSTEM_ERROR">TYPE_SYSTEM_ERROR<i class="fa fa-external-link"></i></span></li></ul></blockquote><p>应用必须使用一个被叫做<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfQVBQTElDQVRJT05fT1ZFUkxBWQ==" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_APPLICATION_OVERLAY">TYPE_APPLICATION_OVERLAY<i class="fa fa-external-link"></i></span>类型的新窗口类型替代。</p><p>当使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfQVBQTElDQVRJT05fT1ZFUkxBWQ==" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_APPLICATION_OVERLAY">TYPE_APPLICATION_OVERLAY<i class="fa fa-external-link"></i></span>类型的窗口为你的应用程序去显示警告窗口，请记住新窗口的如下特征：</p><blockquote><ul><li>一个应用程序的警告窗口总是显示在系统窗口之下，比如状态栏和输入法。</li><li>系统能够移除和重置窗口大小，使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfQVBQTElDQVRJT05fT1ZFUkxBWQ==" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_APPLICATION_OVERLAY">TYPE_APPLICATION_OVERLAY<i class="fa fa-external-link"></i></span>类型的窗口去提高屏幕演示</li><li>通过打开通知栏窗帘，用户能够访问设置去屏蔽一个应用通过<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfQVBQTElDQVRJT05fT1ZFUkxBWQ==" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_APPLICATION_OVERLAY">TYPE_APPLICATION_OVERLAY<i class="fa fa-external-link"></i></span>窗口类型去显示警告窗口的显示</li></ul></blockquote><p>针对该行为变化，对上面的示例代码进行了修改，以兼容Android O：</p><p>更改<strong>TYPE_PHONE</strong>为<strong>TYPE_APPLICATION_OVERLAY</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-  params.type = WindowManager.LayoutParams.TYPE_PHONE;</span><br><span class="line">+  params.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;</span><br></pre></td></tr></table></figure><p>运行,效果图如下</p><p><img alt="windowmanager-o" data-src="/images/windowmanager-o.png"></p><blockquote><p>以上就是简单的对Android WindowManager悬浮窗行为变化的简单总结。如有不足，欢迎指正，谢谢。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是关于针对Android WindowManager悬浮窗行为变化的总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="WindowManager" scheme="https://shoewann0402.github.io/categories/Android/WindowManager/"/>
    
    
      <category term="Android O" scheme="https://shoewann0402.github.io/tags/Android-O/"/>
    
      <category term="WindowManager" scheme="https://shoewann0402.github.io/tags/WindowManager/"/>
    
      <category term="Android M" scheme="https://shoewann0402.github.io/tags/Android-M/"/>
    
  </entry>
  
  <entry>
    <title>Android 模拟器快速启动和主要功能</title>
    <link href="https://shoewann0402.github.io/2017/12/19/quick-boot-top-features-in-android/"/>
    <id>https://shoewann0402.github.io/2017/12/19/quick-boot-top-features-in-android/</id>
    <published>2017-12-19T03:13:19.000Z</published>
    <updated>2019-03-11T09:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8xMi9xdWljay1ib290LXRvcC1mZWF0dXJlcy1pbi1hbmRyb2lkLmh0bWw=" title="https://android-developers.googleblog.com/2017/12/quick-boot-top-features-in-android.html">Quick Boot &amp; the Top Features in the Android Emulator<i class="fa fa-external-link"></i></span></p></blockquote><p>今天我们很高兴的宣布Android模拟器快速启动。使用快速启动，您能在6秒内启动模拟器。快速启动通过快照模拟器会话来工作，因此您能够在几秒钟内重新加载。快速启动是在Android Studio 3.0 canary更新通道首次发布，我们很高兴的的在今天的更新中将这一个功能作为稳定版本发布。</p><a id="more"></a><p>除了这个新功能以外，我们也想突出显示最近发布的一些主要功能，自从<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNS8xMi9hbmRyb2lkLXN0dWRpby0yMC1wcmV2aWV3LWFuZHJvaWQuaHRtbA==" title="https://android-developers.googleblog.com/2015/12/android-studio-20-preview-android.html">两年前<i class="fa fa-external-link"></i></span>对Android模拟器进行了改造，我们继续将焦点放在改善速度、兼容性和添加一些丰富的功能，加速您的应用程序开发和测试。随着最近所有的变化，今天绝对值得去更新Android模拟器到最新版并使用它。</p><h2 id="主要的5个功能"><a href="#主要的5个功能" class="headerlink" title="主要的5个功能"></a>主要的5个功能</h2><blockquote><ul><li><strong>快速启动</strong> —— 今天作为一个稳定功能发布，快速启动允许您在6秒之内恢复您的Android模拟器会话。首次您开始启动Android模拟器的Android虚拟设备，它必须执行冷启动(就像启动设备一样)，但是随后的启动速度很快，系统将会恢复在您最后关闭模拟器时的状态(像唤醒设备一样)。我们通过完全重新设计旧式仿真器快照架构，使用虚拟传感器和GPU加速工作来完成了这个。无需额外的请求，因为快速启动在Android模拟器v27.0.2版本上是默认开启的。</li></ul></blockquote><p><img alt="image2.gif" data-src="/images/image2.gif"></p><blockquote><ul><li><strong>Android CTS 兼容性</strong> —— 每发布一个版本的Android SDK，我们都将确保Android模拟器已经为您的应用程序做好了需要的开发准备，从测试向后兼容的Android KitKat到集成了最新APIs的开发者预览版。对于增加模拟器系统镜像产品的质量和可靠性，我们现在从Android Nougat (API 24) 或者更高的对<span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vY29tcGF0aWJpbGl0eS8=" title="https://source.android.com/compatibility/">Android 兼容性的测试套件<i class="fa fa-external-link"></i></span>(CTS)构建有资格的最终版Android系统镜像 — 相同的测试套件官方Android物理设备必须通过。</li></ul></blockquote><blockquote><ul><li><strong>Google Play支持</strong> —— 我们知道大多数的应用程序开发者使用Google play 服务，在Android模拟器系统镜像上是很难保持服务的最新。为了解决这个问题，我们现在提供的Android系统镜像包括了Play商店的应用程序。Google Play 服务现开始从Android Nougat (API 24)可以使用了。这些新的模拟器镜像，您可以从您模拟器里面的Play 应用商店里面更新Google Play服务，正如您会在物理设备上操作的一样。还有就是，您现在能够使用Google Play应用商店测试结束到结束安装、更新和购买流程。</li></ul></blockquote><blockquote><ul><li><strong>性能提高</strong> —— 使模拟器更快速以及性能是我们团队正在进行的一个目标。我们持续的观察运行在您的开发机器上的模拟器对性能的影响，尤其是内存使用情况。使用最新版的Android模拟器，我们现在按需求分配RAM(内存)，而不是在您的AVD中定义最大的内存大小去分配和固定内存。对于Linux (KVM) 、macOS® (Hypervisor.内核)我们通过挖掘本地虚拟管理程序来实现这个，以及对Microsoft® Windows®增强Intel® HAXM (v6.2.1 或者更高版本)，它使用新的按需要分配内存。</li></ul></blockquote><p>额外的还有，再过去的几个版本中，我们有改善CPU和I/O性能，同时增强了GPU的性能，包括了对OpenGL ES 3.0的支持。看一下像ADB推送这样常见的任务，突出了Android CPU和I/O管道的改进：</p><p><img alt="image5.png" data-src="/images/image5.png"></p><p>对于GPU性能，我们创建了一个简单的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9ncHUtZW11bGF0aW9uLXN0cmVzcy10ZXN0" title="https://github.com/google/gpu-emulation-stress-test">GPU仿真压力测试应用程序<i class="fa fa-external-link"></i></span>去测量时间的推移。我们发现最最新版本的模拟器能够渲染比之前更高速的帧率，它是少数模拟器之一能够准确的按照Android规范去渲染OpenGL ES。</p><p><img alt="image1.gif" data-src="/images/image1.gif"></p><p><img alt="gpu_emulator_stress_test_chart.png" data-src="/images/gpu_emulator_stress_test_chart.png"></p><h2 id="更多的功能点"><a href="#更多的功能点" class="headerlink" title="更多的功能点"></a>更多的功能点</h2><p>除了这些主要的功能以外，这儿还有一大堆额外的功能，我们在过去的一年中已经添加到了Android 模拟器，您可能还不知道：</p><blockquote><ul><li><strong>Wi-Fi支持</strong> —— 从API 24的系统镜像开始，您能创建一个包含了连接到一个虚拟的数据网络和一个虚拟的Wi-Fi访问点的AVD</li></ul></blockquote><blockquote><ul><li><strong>Google cast 的支持</strong> —— 当使用一个Google Play 系统镜像，您能够在相同的Wi-Fi网络下够投屏幕和音频内容到Chromecast设备。</li></ul></blockquote><blockquote><ul><li><strong>拖拽APKs和文件</strong> —— 简单的拖拽一个apk到Android模拟器的窗口去触发一个app应用程序的安装。您也能够拖拽任意其它文件，并在您的Android虚拟设备里的/Downloads文件夹下发现它们。</li></ul></blockquote><blockquote><ul><li><strong>主机复制&amp;粘贴</strong> —— 您能够复制&amp;粘贴文本在Android模拟器和您的开发机器之间。</li></ul></blockquote><blockquote><ul><li><strong>虚拟的两个手指捏&amp;缩放</strong> —— 当您的应用程序像集成了Google Maps，按下Ctrl键(在Microsoft® Windows®或者Linux上)或者⌘ (在macOS®上)，并在屏幕上出现手指叠加以帮助捏和缩放操作。</li></ul></blockquote><blockquote><ul><li><strong>GPS位置</strong> —— 手动选择一个GPS点或者在Android模拟器的位置下选项卡下设置GPS点。</li></ul></blockquote><blockquote><ul><li><strong>虚拟传感器</strong> —— 在扩展控制面板上是一个支持传感器专用的页面，包括了加速度，方向，接近度以及更多</li></ul></blockquote><blockquote><ul><li><strong>摄像头支持</strong> —— 您能够使用一个摄像头或者您的笔记本内置的摄像头作为一个在AVD里面虚拟的摄像头。在AVD设置页面里面的高级设置页面验证您的相机设置。</li></ul></blockquote><blockquote><ul><li><strong>主机键盘</strong> —— 您能够使用您真实的键盘去输入文本内容到Android虚拟设备。</li></ul></blockquote><blockquote><ul><li><strong>虚拟短信和拨号</strong> —— 在扩展控制面板，您能够触发一个虚拟的短信或者拨号的去测试您应用里电话的依赖。</li></ul></blockquote><blockquote><ul><li><strong>屏幕缩放</strong> —— 在主工具栏，点击放大镜图标进入放大模式，然后选择一个您需要检测的屏幕区域。</li></ul></blockquote><blockquote><ul><li><strong>窗口重置大小</strong> —— 简单的拖拽Android模拟器窗口的一个角去改变您想要的大小</li></ul></blockquote><blockquote><ul><li><strong>网络代理的支持</strong> —— 通过到代理选项卡下的设置页面，添加一个自定义的HTTP代理到您的Android模拟器会话。</li></ul></blockquote><blockquote><ul><li><strong>Bug 报告</strong> —— 您能够通过使用在扩展控制面板的Bug报告部分，快速的为您的应用程序生成一个bug报告，并分享到您的团队或者发送反馈到Google</li></ul></blockquote><p>了解更多关于Android模拟器的内容，参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3J1bi9lbXVsYXRvci5odG1s" title="https://developer.android.com/studio/run/emulator.html">模拟器文档<i class="fa fa-external-link"></i></span></p><h2 id="从这里开始"><a href="#从这里开始" class="headerlink" title="从这里开始"></a>从这里开始</h2><p>这些所有的功能和改善都可以使用了，去下载并现在使用Android 模拟器v27.0.2+，您能够从Android Studio中的SDK Manager里面获得。对于一个快速的体验，我们建议您创建和运行x86版本的模拟器系统镜像，使用最新版本的Android 模拟器，安装 Intel® HAXM(如果适用)和显卡驱动。</p><p>我们感谢您反馈任何您喜欢的意见建议，问题或者您希望看到的功能。如果您发现了一个bug、issue或者有一个功能请求随时<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3JlcG9ydC1idWdzLmh0bWwjZW11bGF0b3ItYnVncw==" title="https://developer.android.com/studio/report-bugs.html#emulator-bugs">提出问题<i class="fa fa-external-link"></i></span>,我们无疑没有完成，但是我们希望您对到目前为止的改进感到兴奋。</p><blockquote><p>以上是对Google官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://android-developers.googleblog.com/2017/12/quick-boot-top-features-in-android.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Quick Boot &amp;amp; the Top Features in the Android Emulator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们很高兴的宣布Android模拟器快速启动。使用快速启动，您能在6秒内启动模拟器。快速启动通过快照模拟器会话来工作，因此您能够在几秒钟内重新加载。快速启动是在Android Studio 3.0 canary更新通道首次发布，我们很高兴的的在今天的更新中将这一个功能作为稳定版本发布。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Emulator" scheme="https://shoewann0402.github.io/categories/Android/Android-Emulator/"/>
    
    
      <category term="Android Studio" scheme="https://shoewann0402.github.io/tags/Android-Studio/"/>
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Emulator" scheme="https://shoewann0402.github.io/tags/Android-Emulator/"/>
    
  </entry>
  
  <entry>
    <title>GDD China 2017之旅</title>
    <link href="https://shoewann0402.github.io/2017/12/18/gdd-china-2017-in-shanghai-trip-record/"/>
    <id>https://shoewann0402.github.io/2017/12/18/gdd-china-2017-in-shanghai-trip-record/</id>
    <published>2017-12-18T15:34:51.000Z</published>
    <updated>2019-03-11T09:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016年，那个时候我还在上海。去年的GDD上海场我没有去参加，当时是有些遗憾；今年2017年的GDD如期而至，两天都在上海举办，而我已经不在上海，回到了成都。这时的我决定去参加，因为我是谷歌爱好者，梦寐有机会去参加一次谷歌总部的活动，既然出国不行，那在国内举办活动更近了，并且这次大会我可以和我一直只能在电视和社交软件上的关注的谷歌大佬面对面，更不容错过！</p><a id="more"></a><p>通过GDD大会邮件的报名、筛选，我有幸成为了大会的嘉宾之一，GDD China 2017 活动举办的时间越来越近了。12月12日下午下班，没来得及吃饭，我就直奔机场，踏上成都飞往上海的航程。21：00的飞机，到上海已经23:10分，然后深夜地铁已经结束运营了，只好乘坐的士到以前上海的同事住的地方，已经是第二天凌晨12:00多了。</p><p>13日，GDD China 2017大会举办的第一天，地点在上海跨国采购会展中心。迎着朝阳，我来到了会场地点。首先需要通过安检方可进入会场，在会场外，随处可见Google的元素，Android机器人、Google Map定位图标，GDD China 2017大会代表中国元素的图案，旗帜，还有一些帐篷。会展大楼入口上面贴着醒目的“<strong>Google Developer Days China 2017</strong>”的Logo</p><p><img alt="aa" data-src="/images/mmexport1513120781516.jpg"></p><p><img alt="bb" data-src="/images/IMG_20171213_080050.jpg"></p><p>走进会场内，一楼进门口正对的是大会3D的Logo，从左侧看是Google，从右侧看是GDD2017，旁边是签到处，我排好队在签到处提供了签到二维码领到了大会的证件以及Google的纪念礼包，里面包含了DIY音响、贴纸等。之后，到了二楼领了同声传译机，去了三楼的会场层。</p><p>我来的还算比较早，在三楼有Google各种产品的展台，AndroidThings&amp;IoT、Android Wear、Android Assistant、Codelab、GDG等等。时间越来越近了，大会参加的人也越来越多了，10:00大会即将开始，我们进入了主会场听取大会的开幕主题演讲。主会场容纳了2000-3000人，随着代表着中国元素的舞蹈拉开了GDD China 2017大会的序幕。</p><p><img alt="cc" data-src="/images/IMG_20171213_081434.jpg"></p><p><img alt="dd" data-src="/images/IMG_20171213_083451.jpg"></p><p>这种气氛仿佛是就是在Google I/O现场，我见到了Google产品总监Andrew Bowers, Google大中华区总裁石博盟(Scott Beaumont),还有李飞飞博士，Google Cloud人工智能和机器学习首席科学家，两次提到了“AI 没有国界，AI 福祉亦无边界。”，并当场宣布了：谷歌AI中国中心的成立。现场如爆裂般的欢呼。</p><p><img alt="ee" data-src="/images/IMG_20171213_104152.jpg"></p><p>主会场的主题演讲之后，接下来两天的活动也算正式开始了。<br>听了一场由Pete LePage演讲的主题分享之后，就到了午餐时间。在每个活动现场的展会证上都有两天的用餐券，免费提供午餐，在会场的一楼。会场数千人从会场到就餐区，享受Google提供的西式自助餐带来的惬意。</p><p><img alt="ff" data-src="/images/IMG_20171213_113848.jpg"></p><p>午餐之后，距离下午的分会场活动开始还有一段时间，就在会场转了转。Google的产品展示区，你可以通过下载APP玩游戏活动糖果、通过使用Google翻译扫描明细片上地点的名称在大会现场找到当地的邮票就可以活动谷歌的抱枕、还有单人/多人的QuickDraw、根据你弹奏的曲目自动通过人工智能的方式做出一段相似的旋律、在3D空间内体验艺术的宇宙大爆炸、Tensorflow通过采集人脸数据，自动识别人脸、物联网设备的猜拳和作画等</p><p><img alt="gg" data-src="/images/IMG_20171213_122106.jpg"></p><p><img alt="hh" data-src="/images/IMG_20171213_122202.jpg"></p><p><img alt="ii" data-src="/images/IMG_20171213_122319.jpg"></p><p><img alt="jj" data-src="/images/IMG_20171213_122329.jpg"></p><p><img alt="kk" data-src="/images/IMG_20171213_122545.jpg"></p><p><img alt="ll" data-src="/images/IMG_20171213_122555.jpg"></p><p>很多很多只能在Google总部体验到的产品，都能在现场体验到。在AndroidThings展台和分会场领取一张AndroidThings的兑换券，就能去兑换一套价值不菲的AndroidThings开发套件。通过扫描证件后面的二维码反馈大会意见和建议成功就能获得Google定制的电脑包一个，不过到最后我都没有去领。</p><p><img alt="mm" data-src="/images/IMG_20171213_145635.jpg"></p><p>下午参加了几场分会场的活动，其中也包含了比较熟悉的演讲嘉宾Daniel Galpin、Hoi lam、Wayne Piekarski、Laurence Moroney。</p><p><img alt="nn" data-src="/images/IMG_20171213_150238.jpg"></p><p>本次大会还发布了Tensorflow中文网站 —— tensorflow.google.cn，并创建了Tensorflow公众号，为中国开发者提供了Tensorflow的新闻和技术资源。</p><p>After Party，晚宴时间。仿照I/O的方式，主会场变成了party场地，台下有香槟红酒、可乐雪碧、蛋糕水果自助餐，街机电竞游戏，投篮球比赛。台上乐队尽情演奏，灯光和LED显示屏伴随着音乐也嗨了起来，在音乐声中大家也慢慢的散场，每个人都提着Google提供的大礼包，结束了第一天的活动。</p><p><img alt="oo" data-src="/images/IMG_20171213_183932.jpg"></p><p><img alt="pp" data-src="/images/wx_camera_1513162978228.jpg"></p><p>14日，GDD大会的第二天，也是最后一天。今天的目标除了听大会喜欢的演讲嘉宾分享技术上新东西，复习和学习以外，还有——当然是找演讲嘉宾他们合影了。</p><p>这两天的活动，由于部分主题人数爆满，临时新增加了分会场，像人工智能、机器学习、Google Cloud等等，虽然我是主要做Android Mobile开发的，但在这次大会上我没有去听Android Oreo相关的话题，应该最多的还是AndroidThings、Tensorflow相关的。</p><p><img alt="qq" data-src="/images/wx_camera_1513215610762.jpg"></p><p>最后，<br>荣幸的是，我成功的和Laurence Moroney、Wayne Piekarski合影了。<br>遗憾的是，我错过了Daniel Galpin、Hoi lam、还有Ankur Kotwal的交流。</p><p><img alt="rr" data-src="/images/20171215_095625-COLLAGE.jpg"></p><p>Laurence Moroney说14日当天晚上要离开，准备回去过圣诞节！Merry Christmas ~</p><p>Wayne Piekarski握了一个手，问我最后一场是他的演讲，要去不去参加，我说当然。</p><p>在离开会场时Wayne还给我发androidThings的卡劵去领，我说我已经有一个了，然后挥手道别,两天的GDD活动结束了，我体会到了很多，很多收获和感想。特别是Andrew Bowers和Anna D Goldie，中文讲的真好。</p><p>正如stormzhang说的那样：如果你没去GDD，那真是一种遗憾。</p><p>GDD 明年见 ~</p><blockquote><p>以上就是个人第一次参加GDD活动的一个简单总结</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016年，那个时候我还在上海。去年的GDD上海场我没有去参加，当时是有些遗憾；今年2017年的GDD如期而至，两天都在上海举办，而我已经不在上海，回到了成都。这时的我决定去参加，因为我是谷歌爱好者，梦寐有机会去参加一次谷歌总部的活动，既然出国不行，那在国内举办活动更近了，并且这次大会我可以和我一直只能在电视和社交软件上的关注的谷歌大佬面对面，更不容错过！&lt;/p&gt;
    
    </summary>
    
      <category term="GDD" scheme="https://shoewann0402.github.io/categories/GDD/"/>
    
    
      <category term="GDD" scheme="https://shoewann0402.github.io/tags/GDD/"/>
    
      <category term="GDD China 2017" scheme="https://shoewann0402.github.io/tags/GDD-China-2017/"/>
    
      <category term="Google Developer Days" scheme="https://shoewann0402.github.io/tags/Google-Developer-Days/"/>
    
  </entry>
  
  <entry>
    <title>介绍Android Oreo(Go版)与Android8.1的发布</title>
    <link href="https://shoewann0402.github.io/2017/12/05/Introducing-android-oreo-go-edition/"/>
    <id>https://shoewann0402.github.io/2017/12/05/Introducing-android-oreo-go-edition/</id>
    <published>2017-12-05T13:11:50.000Z</published>
    <updated>2019-03-11T09:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmxvZy5nb29nbGUvcHJvZHVjdHMvYW5kcm9pZC9pbnRyb2R1Y2luZy1hbmRyb2lkLW9yZW8tZ28tZWRpdGlvbi8=" title="https://www.blog.google/products/android/introducing-android-oreo-go-edition/">Introducing Android Oreo (Go edition) with the release of Android 8.1<i class="fa fa-external-link"></i></span></p></blockquote><p>自Android的创建，我们的使命是将计算的力量带给每一个人。作为一个全球操作系统，Android已经发展到全球超过20亿激活设备，印度的用户人数超过了美国。</p><p>为了确保数十亿人能够访问到计算，入门级设备是功能齐全的智能手机，可以浏览网页和使用应用程序。在<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmxvZy5nb29nbGUvcHJvZHVjdHMvYW5kcm9pZC8yYm4tbWlsZXN0b25lLw==" title="https://www.blog.google/products/android/2bn-milestone/">今年的Google I/O大会上<i class="fa fa-external-link"></i></span>,我们提前看了一个被我们称之为”Android Go”的项目，并让这个项目成为可能。我们激动的宣布这个软件体验——<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5kcm9pZC5jb20vdmVyc2lvbnMvb3Jlby04LTAvZ28tZWRpdGlvbg==" title="https://www.android.com/versions/oreo-8-0/go-edition">Android Oreo(Go版)<i class="fa fa-external-link"></i></span>——准备好了,将在明天作为Android 8.1发布的一个部分发布。</p><a id="more"></a><p>具有512MB到1GB内存的Android Oreo设备将随着Go的全面优化而来,这个Android Oreo(Go版)体验是由三个关键部分组成：</p><ul><li><p><strong>操作系统：</strong>对于操作系统的性能和存储提高,数据管理功能和内置安全优势。</p></li><li><p><strong>Google 应用：</strong>一组新的Google应用程序,设计更轻且与首次上网的人的独特需求相关。</p></li><li><p><strong>Google Play商店：</strong>一款调整版本的Google Play商店允许你下载任意的应用程序,但是也突出了在你设备上设计最好的应用程序。</p></li></ul><h2 id="Go-大，性能更快，更多存储，数据管理和安全性"><a href="#Go-大，性能更快，更多存储，数据管理和安全性" class="headerlink" title="Go 大，性能更快，更多存储，数据管理和安全性"></a>Go 大，性能更快，更多存储，数据管理和安全性</h2><p>我们增强了Android Oreo（Go版）在入门级设备上对于速度和可靠性，意味着在Android Oreo（Go版）的设备上运行的平均应用程序现在快了15%，这儿有很多这样各种各样的优化——它们真的加起来了。如果所有的入门级Android设备启动应用程序的速度提高15%,将节约全球累计100万小时的时间——每天！</p><p>入门级设备,一旦你考虑到操作系统的大小和预装的应用程序，它们通常有着非常小的存储空间可以使用。对于那些想要更大空间为了他们的音乐、应用程序以及照片的人来说这个就很沮丧了。因此，我们将优化Android Oreo（Go版）并增强我们预安装的Google应用程序占用至少50%的空间。最终的结果是，我们已经将入门级设备上面的可用空间增加了一倍。</p><p><img alt="Screen_Shot_2017-12-05_at_11.54.52_AM.width-1000.png" data-src="/images/Screen_Shot_2017-12-05_at_11.54.52_AM.width-1000.png"></p><p>设备运行了Android Oreo（Go版）也伴随了默认开启的Google的数据节省器功能的到来。比如说,在Chrome中的数据节省器每年节约了平均每个用户超过600MB的数据。你也能够通过使用我们内置的数据节省功能管理在后台使用数据的应用程序，给你更多控制你的数据是如何被使用的。</p><p>Android Oreo是Android最安全的版本,因此当你购买一款Android Oreo（Go版）的设备，你将能够获得所有相同的安全功能,并且当然所有的Android Oreo（Go版）的设备都内置了获取<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5kcm9pZC5jb20vcGxheS1wcm90ZWN0Lw==" title="https://www.android.com/play-protect/">Google Play Protect<i class="fa fa-external-link"></i></span>。Google Play Protect一直保持你的设备工作,数据和应用程序安全。它能够扫描你的应用程序安装,甚至当你是离线状态,不管你从哪儿下载了它们。</p><h2 id="Go-和-谷歌"><a href="#Go-和-谷歌" class="headerlink" title="Go 和 谷歌"></a>Go 和 谷歌</h2><p>我们将重新设计大多数我们流行的Google应用程序去解决当地的需要。预安装在Android Oreo（Go版）设备,这套通过Google优化的应用程序包括Google Go,Google Assistant Go,YouTuBe Go,Google Map Go,Gmail Go,Gboard,Google Play,Chrome和新的File Go应用程序。</p><p>我们新的和重新想象的Google应用程序，我们将关注于使它们不仅仅更小,但是也光滑快速。比如说,Google Go——一款新的应用程序去查找里想要的信息——通过提升40%优化数据,重量大小不到5MB,并且使用简单、可点击的方式就能很快速的找到流行和趋势信息。对于Android(Go版)的Google Assistant,你能够快速的发送消息、打电话、设置闹钟以及更多利用你的声音和一个单一的屏幕触碰。</p><p>我们的存储节省功能是由Google扩展操作系统之外的一个全新的文件管理应用程序——<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmxvZy5nb29nbGUvdG9waWNzL25leHQtYmlsbGlvbi11c2Vycy9yZWFkeS1zZXQtZmlsZXMtZ28v" title="https://www.blog.google/topics/next-billion-users/ready-set-files-go/">File Go<i class="fa fa-external-link"></i></span>——帮助你清理空间，保持有组织。无论是来自你手机删除垃圾邮件的建议，重复的图像或者是未使用的应用程序,File Go是Android Oreo(Go版)的存储最大化功能的完美补充。</p><p><img alt="Blogpost_Play.width-1000.png" data-src="/images/Blogpost_Play.width-1000.png"></p><h2 id="Go-Play"><a href="#Go-Play" class="headerlink" title="Go Play"></a>Go Play</h2><p>在Google商店,你能够下载任意的应用程序,并且我们也创建了一个新的部分建议流行的应用程序，调整为入门设备上运行良好。</p><p>我们很高兴的看到我们大多数的合作伙伴使用了我们<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZGV2ZWxvcC9xdWFsaXR5LWd1aWRlbGluZXMvYnVpbGRpbmctZm9yLWJpbGxpb25zLmh0bWw=" title="https://developer.android.com/develop/quality-guidelines/building-for-billions.html">建了数十亿方针<i class="fa fa-external-link"></i></span>，要么优化现有的应用程序，要么去创建一个新的应用程序在入门级设备上运行良好。希望将他们的经验带给数十亿新的智能手机用户。</p><h2 id="准备-设置-Go"><a href="#准备-设置-Go" class="headerlink" title="准备.设置.Go"></a>准备.设置.Go</h2><p>在Android 8.1中推出Android Oreo(Go版)，合作伙伴将在不久就能够在全球的入门级设备上发布这个新版本，我们不能等待我们的合作伙伴的设备在未来的的几个月上架。</p><p>如果你是一个开发者，我们一起为下一个十亿人构建。</p><blockquote><p>以上是对Google官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://www.blog.google/products/android/introducing-android-oreo-go-edition/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introducing Android Oreo (Go edition) with the release of Android 8.1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自Android的创建，我们的使命是将计算的力量带给每一个人。作为一个全球操作系统，Android已经发展到全球超过20亿激活设备，印度的用户人数超过了美国。&lt;/p&gt;
&lt;p&gt;为了确保数十亿人能够访问到计算，入门级设备是功能齐全的智能手机，可以浏览网页和使用应用程序。在&lt;a href=&quot;https://www.blog.google/products/android/2bn-milestone/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;今年的Google I/O大会上&lt;/a&gt;,我们提前看了一个被我们称之为”Android Go”的项目，并让这个项目成为可能。我们激动的宣布这个软件体验——&lt;a href=&quot;https://www.android.com/versions/oreo-8-0/go-edition&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Oreo(Go版)&lt;/a&gt;——准备好了,将在明天作为Android 8.1发布的一个部分发布。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Oreo" scheme="https://shoewann0402.github.io/categories/Android/Android-Oreo/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Oreo Go" scheme="https://shoewann0402.github.io/tags/Android-Oreo-Go/"/>
    
      <category term="Android Go" scheme="https://shoewann0402.github.io/tags/Android-Go/"/>
    
  </entry>
  
</feed>
