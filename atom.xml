<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shoewann&#39;s Personal Blog</title>
  
  <subtitle>【声明:若页面包含的谷歌广告内容不当，影响到您，请立即离开/设置屏蔽/忽略，勿投诉本站！】</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shoewann0402.github.io/"/>
  <updated>2019-03-20T00:47:23.077Z</updated>
  <id>https://shoewann0402.github.io/</id>
  
  <author>
    <name>Shoewann</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Q 应用切换WiFi开关的限制</title>
    <link href="https://shoewann0402.github.io/2019/03/20/android-q-beta-enable-and-disable-wifi/"/>
    <id>https://shoewann0402.github.io/2019/03/20/android-q-beta-enable-and-disable-wifi/</id>
    <published>2019-03-20T00:34:49.000Z</published>
    <updated>2019-03-20T00:47:23.077Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android Q 不允许应用程序开/关WIFI</p></blockquote><hr><a id="more"></a><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>Android Q 将切断应用对Wi-Fi设置的访问权限，防止恶意软件滥用系统功能的访问权限。</p><h1 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h1><p>运行在Q上的应用程序将无法启用/禁用WIFI, <code>WifiManager.setWifiEnabled()</code>方法始将终返回false,该方法不被允许</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xw.androidqtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.net.wifi.WifiManager</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WifiActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tag: String = WifiActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> wifiManager: WifiManager? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_wifi)</span><br><span class="line">        wifiManager = <span class="keyword">this</span>.getSystemService(Context.WIFI_SERVICE) <span class="keyword">as</span> WifiManager?</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> isWifiEnabled = wifiManager!!.isWifiEnabled</span><br><span class="line">        Log.d(tag, <span class="string">"[默认状态]是否开启 :<span class="variable">$isWifiEnabled</span>"</span>)</span><br><span class="line">        <span class="keyword">when</span> (isWifiEnabled) &#123;</span><br><span class="line">            <span class="literal">true</span> -&gt; &#123;</span><br><span class="line">                Log.d(tag, <span class="string">"[关闭]WiFi，设置WiFi状态为: false"</span>)</span><br><span class="line">                wifiManager!!.isWifiEnabled = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">val</span> result = wifiManager!!.isWifiEnabled</span><br><span class="line">                Log.d(tag, <span class="string">"当前状态:<span class="variable">$result</span>"</span>)</span><br><span class="line">                <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                    Log.d(tag, <span class="string">"检查到当前是true[开启状态], 关闭WiFi: [失败]"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.d(tag, <span class="string">"检查到当前是false[关闭状态], 关闭WiFi: [成功]"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                Log.d(tag, <span class="string">"[开启]WiFi，设置WiFi状态为: true"</span>)</span><br><span class="line">                wifiManager!!.isWifiEnabled = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">val</span> result = wifiManager!!.isWifiEnabled</span><br><span class="line">                Log.d(tag, <span class="string">"当前状态:<span class="variable">$result</span>"</span>)</span><br><span class="line">                <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                    Log.d(tag, <span class="string">"检查当前是true[开启状态], 开启WiFi: [成功]"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.d(tag, <span class="string">"检查当前是false[关闭状态], 开启WiFi: [失败]"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>当WiFi默认是开启的情况下，需要代码关闭WiFi，输出日志:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-03-20 08:24:51.741 1213-1650/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.WifiActivity&#125; from uid 10505</span><br><span class="line">2019-03-20 08:24:51.779 11562-11562/? D/WifiActivity: [默认状态]是否开启 :true</span><br><span class="line">2019-03-20 08:24:51.779 11562-11562/? D/WifiActivity: [关闭]WiFi，设置WiFi状态为: false</span><br><span class="line">2019-03-20 08:24:51.781 1213-1650/? I/WifiService: setWifiEnabled not allowed for uid=10505</span><br><span class="line">2019-03-20 08:24:51.781 11562-11562/? D/WifiActivity: 当前状态:true</span><br><span class="line">2019-03-20 08:24:51.781 11562-11562/? D/WifiActivity: 检查到当前是true[开启状态], 关闭WiFi: [失败]</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>当WiFi默认是关闭的情况下，需要代码开启WiFi，输出日志:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-03-20 08:27:00.212 1213-3863/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.WifiActivity&#125; from uid 10505</span><br><span class="line">2019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: [默认状态]是否开启 :false</span><br><span class="line">2019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: [开启]WiFi，设置WiFi状态为: true</span><br><span class="line">2019-03-20 08:27:00.245 1213-5152/? I/WifiService: setWifiEnabled not allowed for uid=10505</span><br><span class="line">2019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: 当前状态:false</span><br><span class="line">2019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: 检查当前是false[关闭状态], 开启WiFi: [失败]</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>通过以上的示例可以看到，不论是开启还是关闭WiFi都没有效果，系统都将返回<code>false</code>，并输出<code>setWifiEnabled</code>不被允许的日志信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setWifiEnabled not allowed for uid= xxxx</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>使用设置面板提示用户启用和禁用Wi-Fi，<br>调用<code>Settings.Panel.ACTION_INTERNET_CONNECTIVITY</code><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(Intent(Settings.Panel.ACTION_INTERNET_CONNECTIVITY))</span><br></pre></td></tr></table></figure></p><blockquote><p>本文参考官方文档简单总结，感谢您的阅读。如有不足，欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android Q 不允许应用程序开/关WIFI&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="WIFI" scheme="https://shoewann0402.github.io/tags/WIFI/"/>
    
      <category term="setWifiEnabled" scheme="https://shoewann0402.github.io/tags/setWifiEnabled/"/>
    
      <category term="Settings Panel" scheme="https://shoewann0402.github.io/tags/Settings-Panel/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 设置面板</title>
    <link href="https://shoewann0402.github.io/2019/03/19/android-q-beta-settings-panel/"/>
    <id>https://shoewann0402.github.io/2019/03/19/android-q-beta-settings-panel/</id>
    <published>2019-03-19T10:15:56.000Z</published>
    <updated>2019-03-19T10:27:20.376Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android Q 引入了设置面板，它是一种API, 允许从应用程序上下文直接向用户展示设置。</p></blockquote><hr><a id="more"></a><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>避免了用户为了使用应用程序而需要进入<strong>设置</strong>来更改<strong>NFC</strong>或<strong>移动数据</strong>等内容。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>例如，假设用户在其设备处于飞行模式时打开Web浏览器。 在Android Q之前，该应用只能显示一条通用消息，要求用户打开“设置”以恢复连接。 使用Android Q，浏览器应用程序可以显示一个内联面板，显示关键的连接设置，如飞行模式，Wi-Fi（包括附近的网络）和移动数据。 使用此面板，用户无需离开应用即可恢复连接。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>这一新功能目前暂提供了<code>网络连接</code>、<code>NFC</code>、<code>音量</code>三个<strong>设置面板</strong>,使我们可以访问这三个不同的设置面板，所有这些面板都可以通过简单的<code>startActivity()</code>调用启动。</p><h2 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings.Panel.ACTION_INTERNET_CONNECTIVITY</span><br></pre></td></tr></table></figure><p><img src="/images/android-q-beta-settings-panel-wifi-1.png" alt="android-q-beta-settings-panel-wifi-1.png"></p><p><img src="/images/android-q-beta-settings-panel-wifi-2.png" alt="android-q-beta-settings-panel-wifi-1.png"></p><p>面板属性:</p><blockquote><ul><li>启用/禁用飞行模式</li><li>启用/禁用WIFI连接</li><li>启用/禁用移动数据</li><li>更改WIFI连接</li><li>导航到连接设置</li></ul></blockquote><h2 id="NFC"><a href="#NFC" class="headerlink" title="NFC"></a>NFC</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings.Panel.ACTION_NFC</span><br></pre></td></tr></table></figure><p><img src="/images/android-q-beta-settings-panel-nfc.png" alt="android-q-beta-settings-panel-nfc.png"></p><p>面板属性:</p><blockquote><ul><li>显示与近场通信（NFC）相关的所有设置。</li></ul></blockquote><h2 id="音量"><a href="#音量" class="headerlink" title="音量"></a>音量</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings.Panel.ACTION_VOLUME</span><br></pre></td></tr></table></figure><p><img src="/images/android-q-beta-settings-panel-volume.png" alt="android-q-beta-settings-panel-volume.png"></p><p>面板属性:</p><blockquote><ul><li>媒体音量</li><li>通话音量</li><li>铃声音量</li><li>闹钟音量</li></ul></blockquote><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xw.androidqtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.provider.Settings</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_settings_panel.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SettingsPanelActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tag: String = SettingsPanelActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_settings_panel)</span><br><span class="line">        </span><br><span class="line">        btnConnectivity.setOnClickListener &#123;</span><br><span class="line">            openSettings(Settings.Panel.ACTION_INTERNET_CONNECTIVITY)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnNFC.setOnClickListener &#123;</span><br><span class="line">            openSettings(Settings.Panel.ACTION_NFC)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnVolume.setOnClickListener &#123;</span><br><span class="line">            openSettings(Settings.Panel.ACTION_VOLUME)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">openSettings</span><span class="params">(panel: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        Log.d(tag, <span class="string">"panel:<span class="variable">$panel</span>"</span>)</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(panel)</span><br><span class="line">        startActivity(intent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9mZWF0dXJlcyNzZXR0aW5ncy1wYW5lbHM=" title="https://developer.android.google.cn/preview/features#settings-panels">官方文档<i class="fa fa-external-link"></i></span>及示例简单总结，感谢您的阅读。如有不足，欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android Q 引入了设置面板，它是一种API, 允许从应用程序上下文直接向用户展示设置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="Settings Panel" scheme="https://shoewann0402.github.io/tags/Settings-Panel/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 独立存储</title>
    <link href="https://shoewann0402.github.io/2019/03/17/android-q-beta-scoped-storage/"/>
    <id>https://shoewann0402.github.io/2019/03/17/android-q-beta-scoped-storage/</id>
    <published>2019-03-17T04:42:37.000Z</published>
    <updated>2019-03-26T15:04:49.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android Q 系统, 对应用存储空间访问进行了限制。</p></blockquote><hr><a id="more"></a><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>为了让用户更好地控制文件并限制文件混乱，Android Q 改变了应用程序访问设备外部存储上文件的方式</p><h1 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h1><blockquote><ul><li>使用更精细粒度、特殊媒体权限取代<code>READ_EXTERNAL_STORAGE</code> 和<code>WRITE_EXTERNAL_STORAGE</code> 权限</li></ul></blockquote><blockquote><ul><li>应用程序从外部存储设备访问自己的文件不需要特殊权限</li></ul></blockquote><h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>这些更改会影响您的应用保存和访问外部存储上的文件的方式。</p><p><img src="/images/android_q_file_access.png" alt="android_q_file_access.png"></p><h1 id="沙箱独立存储应用私有文件"><a href="#沙箱独立存储应用私有文件" class="headerlink" title="沙箱独立存储应用私有文件"></a>沙箱独立存储应用私有文件</h1><p>Android Q 为每一个应用在外部存储设备内采用了<code>沙箱独立存储</code>。比如<code>/sdcard</code>, 没有其他应用程序能够直接访问您应用程序沙箱内的文件，因为对于您的应用程序来说这些文件是私有的，您不再需要任何权限去访问和保存您自己外部存储中的文件，这一变化使维护用户文件的隐私变得更容易，并有助于减少应用程序所需的权限数量。</p><p><strong>【注意】如果用户手动卸载了应用程序，沙箱内的私有文件也会被清理</strong></p><p>通过<code>Context.getExternalFilesDir()</code>返回的位置是在外部存储上存储文件的最佳位置。因为这个位置在所有Android版本上的行为都是一致的。使用此方法时，请传入与要创建或打开的文件类型对应的媒体环境，比如说，访问或保存应用程序私有图片，调用<code>Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)</code></p><h1 id="分享媒体文件集"><a href="#分享媒体文件集" class="headerlink" title="分享媒体文件集"></a>分享媒体文件集</h1><p>如果您的应用程序创建的文件属于用户，用户希望在当应用程序被卸载之后这些文件能够被保留，然后保存到一个公共的媒体集，也称为共享集合。共享集合包括：<strong>图片&amp;视频、音乐以及下载</strong></p><h2 id="查看其他应用程序文件的权限"><a href="#查看其他应用程序文件的权限" class="headerlink" title="查看其他应用程序文件的权限"></a>查看其他应用程序文件的权限</h2><p>在这些共享集合中您的应用程序为了创建和变更它自己的文件不需要请求任何的权限。如果您的应用需要去创建和变更其他应用程序创建的文件，它必须首先要请求适当的权限</p><blockquote><ul><li>在<strong>图片&amp;视频</strong>共享集合中去访问其他应用的文件需要请求<code>READ_MEDIA_IMAGES</code>或者 <code>READ_MEDIA_VIDEO</code>权限，依赖您的应用程序需要去访问的文件类型</li></ul></blockquote><blockquote><ul><li>在<strong>音乐</strong>共享集合中去访问其他应用的文件需要请求<code>READ_MEDIA_AUDIO</code>权限</li></ul></blockquote><p>【注意】这里没有访问<strong>下载</strong>共享集合的权限。您的应用程序能够在这个集合里访问它自己的文件，对于访问这个集合里其他应用程序的文件，您必须使用系统文件选择器应用程序允许用户去选择一个文件</p><p>【注意】如果您的应用使用了<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vZ3VpZGUvdG9waWNzL3Byb3ZpZGVycy9kb2N1bWVudC1wcm92aWRlcg==" title="https://developer.android.google.cn/guide/topics/providers/document-provider">Storage Access Framework(存储访问框架)<i class="fa fa-external-link"></i></span>,它不需要去请求这些独立的媒体权限</p><h2 id="访问共享集合"><a href="#访问共享集合" class="headerlink" title="访问共享集合"></a>访问共享集合</h2><p>请求必要的权限之后，您的应用程序使用<code>MediaStore</code>API 访问这些集合</p><blockquote><ul><li><strong>图片 &amp; 视频</strong> 共享集合 —— 使用<code>MediaStore.Images</code>或<code>MediaStore.Video</code></li><li><strong>音乐</strong> 共享集合 —— 使用<code>MediaStore.Audio</code></li><li><strong>下载</strong> 共享集合 —— 使用<code>MediaStore.Downloads</code><br>【警告】对于新安装在Android Q上的应用程序，调用<code>getExternalStoragePublicDirectory</code>,只提供对应用程序存储在其隔离存储沙箱中的文件的访问。保持对其他应用程序文件的访问权限，更新应用程序的逻辑，使用<code>MediaStore</code>代替</li></ul></blockquote><h2 id="保留应用程序在共享集合中的文件"><a href="#保留应用程序在共享集合中的文件" class="headerlink" title="保留应用程序在共享集合中的文件"></a>保留应用程序在共享集合中的文件</h2><p>默认情况下，当用户卸载了您的应用程序，Android Q 会清理您保存在沙箱中的文件。当您应用程序被卸载时对于保留这些文件，使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vZ3VpZGUvdG9waWNzL3Byb3ZpZGVycy9kb2N1bWVudC1wcm92aWRlcg==" title="https://developer.android.google.cn/guide/topics/providers/document-provider">Storage Access Framework(存储访问框架)<i class="fa fa-external-link"></i></span>或者保存到一个共享集合。</p><p>要保留文件到共享集合，请在相关的MediaStore集合中插入新行，并按以下方式填充其列</p><blockquote><ul><li>最低限度，为<code>DISPLAY_NAME</code>和<code>MIME_TYPE</code>列提供值</li><li>可选性，您能够使用<code>PRIMARY_DIRECTORY</code>和<code>SECONDARY_DIRECTORY</code>列影响文件放置在磁盘上的位置。</li><li>不定义DATA列，这样，平台可以灵活地将文件保存在您的沙箱之外。</li></ul></blockquote><p>插入之后，您能够使用像<code>ContentResolver.openFileDescriptor()</code>读写数据到新创建的文件</p><p>如果用户在之后重新安装了您的应用，您的应用程序不会访问这些文件，除非它执行以下操作之一：</p><blockquote><ul><li>请求相应的集合权限</li><li>从存储访问框架向用户发送请求。<br>这种情况类似于应用程序尝试访问其他应用程序文件的情况。</li></ul></blockquote><h1 id="照片的特殊注意事项"><a href="#照片的特殊注意事项" class="headerlink" title="照片的特殊注意事项"></a>照片的特殊注意事项</h1><p>Android Q 添加了几个增强功能，让用户更好的控制在外部存储上他们照片的访问</p><h2 id="访问照片的位置"><a href="#访问照片的位置" class="headerlink" title="访问照片的位置"></a>访问照片的位置</h2><p>有一些照片在它们Exif元数据中包含了位置信息，允许用户查看照片的拍摄地。因为这些位置信息是敏感的，Android Q 默认情况下重新编辑了这些信息。这个位置信息的限制不同于适用于相机特性的限制。</p><p>【注意】如果您的应用程序是用户默认的照片管理应用程序，平台将会自动给予您应用程序访问照片中的位置信息。</p><p>如果您的应用程序需要访问一个照片的位置，需要完成如下步骤</p><p>1.添加新的权限<code>ACCESS_MEDIA_LOCATION</code>到您应用程序的清单中<br>2.从您的MediaStore对象，调用setRequireOriginal()，传入照片的URI</p><h2 id="展示用户图库照片"><a href="#展示用户图库照片" class="headerlink" title="展示用户图库照片"></a>展示用户图库照片</h2><p>如果您的应用程序是一个相机应用，它无法直接访问保存在<strong>图片&amp;视频</strong>共享集合中的照片，除非它是默认的照片管理应用，要将用户引导到图库应用程序，请使用<code>ACTION_REVIEW</code> intent意图。</p><h1 id="处理其他应用程序的文件"><a href="#处理其他应用程序的文件" class="headerlink" title="处理其他应用程序的文件"></a>处理其他应用程序的文件</h1><p>这个环节解释应用程序如何与存储在共享集合中的其他应用程序的文件进行交互。</p><h2 id="访问其他应用创建的文件"><a href="#访问其他应用创建的文件" class="headerlink" title="访问其他应用创建的文件"></a>访问其他应用创建的文件</h2><p>在一个外部存储设备上，访问和读取其他应用程序的已经保存的媒体文件，分为以下几步：</p><p>1.请求必要的权限，基于包含您要访问的文件的共享集合。<br>2.使用<code>ContentResolver</code>对象去查找并打开文件</p><p>【注意】<strong>ContentResolver</strong>类包含了一个新的方法，<strong>loadThumbnail()</strong>,提供给您应用预览文件。最好先调用<strong>loadThumbnail()</strong>,以便用户能够查看媒体文件快照无需您的应用程序加载所有文件本身。这个方法还允许更灵活的请求，比如请求特殊维度和取消请求的能力。</p><h2 id="写入其他应用创建的文件"><a href="#写入其他应用创建的文件" class="headerlink" title="写入其他应用创建的文件"></a>写入其他应用创建的文件</h2><p>通过保存文件到共享集合，您的应用程序将成为该文件的所有者。通常情况下，您的应用程序能够写入到共享集合的文件，除非您是这个文件的所有者。如果您的应用程序有正确的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9mZWF0dXJlcyNyb2xlcw==" title="https://developer.android.google.cn/preview/features#roles">角色<i class="fa fa-external-link"></i></span>分配给它，您也能够写入到其他应用程序自己的文件：</p><blockquote><ul><li>如果您的应用程序是用户默认的照片管理应用，你能够变更其他应用保存在<strong>图片&amp;视频</strong>共享集合里的图片文件</li><li>如果您的应用程序是用户默认的音乐应用，您能够变更其他应用程序保存在<strong>音乐</strong>共享集合里的音频文件</li></ul></blockquote><p>【注意】您的应用程序应该保持功能，无论它是默认的照片管理器或音乐应用程序。</p><p>要变更其他应用保存在外部存储设备中原始的媒体文件，完成如下步骤之一：</p><blockquote><ul><li>通过<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9mZWF0dXJlcy9yb2xlcyNjaGVjay1kZWZhdWx0LWFwcA==" title="https://developer.android.google.cn/preview/features/roles#check-default-app">角色指南<i class="fa fa-external-link"></i></span>检查您的应用是否是默认的图片管理应用或者默认的音乐管理应用</li><li>使用<code>ContentResolver</code>对象查找文件并变更它，当执行编辑/变更操作，捕获<code>RecoverableSecurityException</code>以便您能够请求用户授予您写入的特殊项</li></ul></blockquote><h1 id="访问特殊文件"><a href="#访问特殊文件" class="headerlink" title="访问特殊文件"></a>访问特殊文件</h1><p>在一些使用情况中，您的应用或许需要打开或者创建权限，它无需要有访问权限：</p><blockquote><ul><li>在照片编辑应用程序中，打开一张图片。</li><li>在商业产品应用中，保存文本文档到本地让用户选择</li></ul></blockquote><p>允许用户去选择特殊文件打开，或者选择特殊位置保存文件，对于这些解决方案，使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vZ3VpZGUvdG9waWNzL3Byb3ZpZGVycy9kb2N1bWVudC1wcm92aWRlcg==" title="https://developer.android.google.cn/guide/topics/providers/document-provider">存储访问框架<i class="fa fa-external-link"></i></span></p><h1 id="配套的app文件共享"><a href="#配套的app文件共享" class="headerlink" title="配套的app文件共享"></a>配套的app文件共享</h1><p>如果您管理一套需要互相访问彼此文件的应用程序，使用<code>content://</code>URIs,我们已经<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vdG9waWMvc2VjdXJpdHkvYmVzdC1wcmFjdGljZXMjcGVybWlzc2lvbnMtc2hhcmUtZGF0YQ==" title="https://developer.android.google.cn/topic/security/best-practices#permissions-share-data">建议作为安全性最佳实践。<i class="fa fa-external-link"></i></span></p><p>更多信息，请查阅文档如何<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vdHJhaW5pbmcvc2VjdXJlLWZpbGUtc2hhcmluZy9zZXR1cC1zaGFyaW5n" title="https://developer.android.google.cn/training/secure-file-sharing/setup-sharing">设置文件共享<i class="fa fa-external-link"></i></span></p><h1 id="升级设备上以前安装的应用程序的兼容性模式"><a href="#升级设备上以前安装的应用程序的兼容性模式" class="headerlink" title="升级设备上以前安装的应用程序的兼容性模式"></a>升级设备上以前安装的应用程序的兼容性模式</h1><p>限制外部存储中的文件访问应用于应用程序target目标版本是Android Q,或者运行在Android Q设备上最新安装的应用</p><p>当满足如下条件时，系统会将您的应用文件访问设置为兼容模式:</p><blockquote><ul><li>target version  &lt; = Android 9 (API 28)</li><li>您安装在设备上的应用从[ Android 9 ] –&gt; 升级到—&gt; [ Android Q ]</li></ul></blockquote><p>当您的应用程序进入兼容模式，以下文件访问行为适用：</p><blockquote><ul><li>您的应用程序能够访问<code>MediaStore</code>集合内所有的文件存储，甚至是您的应用程序没有创建的文件。</li><li>面向用户的是允许或拒绝您的应用程序访问整个外部存储的权限，而不是像<strong>图片&amp;视频</strong>或者<strong>音乐</strong>这样单独的共享集合</li></ul></blockquote><p>这个兼容模式直到您首次卸载您的应用程序仍然有效</p><p>【注意】如果您的应用程序之后在同一设备重新安装，兼容模式不会重新被激活</p><h1 id="识别特殊的外部存储设备"><a href="#识别特殊的外部存储设备" class="headerlink" title="识别特殊的外部存储设备"></a>识别特殊的外部存储设备</h1><p>SDK &lt; = Android 9 (API 28) —— 在所有的外部存储设备上的所有文件都显示在当个<code>&quot;external&quot;</code>(外部)卷标下</p><p>Android Q, 给每一个外部存储设备一个不一样的卷标，这意味着系统帮助您有效地组织和索引内容，它可以让您控制新内容的存储位置</p><p>【注意】主外部存储设备始终使用卷名“external”。</p><p>对于外部存储内唯一地标识特殊文件，您必须使用卷标名和ID一起。比如说，一个文件在主存储设备将是<code>content://media/external/images/media/12</code>，但是二级存储设备上名为FA23-3E92的相应文件将是<code>content://media/FA23-3E92/images/media/12</code></p><p>您能够在特殊的卷上，通过传入卷标名到特殊媒体集访问存储文件。比如说<code>MediaStore.Images.getContentUri()</code></p><h2 id="获取外部存储设备列表"><a href="#获取外部存储设备列表" class="headerlink" title="获取外部存储设备列表"></a>获取外部存储设备列表</h2><p>要获取所有当前可用的卷标名称列表，调用<code>call MediaStore.getAllVolumeNames()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> volumeNames: Set&lt;String&gt; = MediaStore.getAllVolumeNames(context)</span><br></pre></td></tr></table></figure><h2 id="设置一个虚拟的外部存储设备"><a href="#设置一个虚拟的外部存储设备" class="headerlink" title="设置一个虚拟的外部存储设备"></a>设置一个虚拟的外部存储设备</h2><p>在没有可移动外部存储的设备上，使用以下命令启用虚拟磁盘以进行测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell sm set-virtual-disk true</span><br></pre></td></tr></table></figure><h1 id="测试行为变化"><a href="#测试行为变化" class="headerlink" title="测试行为变化"></a>测试行为变化</h1><p>为了帮助您使应用程序与此新行为变化兼容，平台提供了多种方法来调整与更改相关的多个参数。</p><h2 id="切换行为更改"><a href="#切换行为更改" class="headerlink" title="切换行为更改"></a>切换行为更改</h2><p>要在Android Q Beta 1中启用此行为更改，请在终端窗口中执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell sm set-isolated-storage on</span><br></pre></td></tr></table></figure><p>运行此命令后，设备将重新启动。 如果没有，请等一下再尝试再次运行该命令。</p><p>要确认行为变化是否已生效，请使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop sys.isolated_storage_snapshot</span><br></pre></td></tr></table></figure><h1 id="测试兼容模式行为"><a href="#测试兼容模式行为" class="headerlink" title="测试兼容模式行为"></a>测试兼容模式行为</h1><p>测试应用程序时，可以通过在终端窗口中运行以下命令来启用外部文件存储访问的兼容性模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd appops set your-package-name android:legacy_storage allow</span><br></pre></td></tr></table></figure><p>要禁用兼容模式，请在Android Q上卸载并重新安装您的应用，或在终端窗口中运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd appops set your-package-name android:legacy_storage default</span><br></pre></td></tr></table></figure><h1 id="将外部存储作为文件管理器浏览"><a href="#将外部存储作为文件管理器浏览" class="headerlink" title="将外部存储作为文件管理器浏览"></a>将外部存储作为文件管理器浏览</h1><p>获得对外部存储中的目录的广泛访问,就像文件管理器应用程序可能做的那样,使用<code>ACTION_OPEN_DOCUMENT_TREE</code>意图，比如说，在GitHub上查看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvYW5kcm9pZC1EaXJlY3RvcnlTZWxlY3Rpb24=" title="https://github.com/googlesamples/android-DirectorySelection">android-DirectorySelection<i class="fa fa-external-link"></i></span>示例。</p><p>【警告】在Android Q中不推荐使用<strong>StorageVolume</strong>类中的<strong>createAccessIntent（）</strong> 方法，因此不应使用此方法浏览外部存储设备。 如果您这样做，运行Android Q设备的用户将无法在您的应用中查看保存在外部存储中的文件。</p><h1 id="测试示例"><a href="#测试示例" class="headerlink" title="测试示例"></a>测试示例</h1><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="测试-1-——-默认方式-getExternalStorageDirectory"><a href="#测试-1-——-默认方式-getExternalStorageDirectory" class="headerlink" title="测试 1 —— 默认方式 getExternalStorageDirectory"></a>测试 1 —— 默认方式 getExternalStorageDirectory</h3><p>定义一个Activity——<code>FileStorageActivity</code>，然后定义如下读写方法，通过界面上两个按钮触发，进行默认getExternalStorageDirectory路径下文件的读写测试，运行在Android Q 设备也无需在清单文件定义<code>READ_EXTERNAL_STORAGE</code> 和<code>WRITE_EXTERNAL_STORAGE</code>权限</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> file = File(Environment.getExternalStorageDirectory(), <span class="string">"测试Android Q文件.txt"</span>);</span><br><span class="line">        Log.d(tag, <span class="string">"file.exists():<span class="subst">$&#123;file.exists()&#125;</span> ， file.getAbsolutePath(): <span class="subst">$&#123;file.absolutePath&#125;</span>"</span>);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span><span class="symbol">@FileStorageActivity</span>, <span class="string">"SD卡目录下创建文件成功..."</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        <span class="keyword">val</span> fw = FileWriter(file);</span><br><span class="line">        fw.write(<span class="string">"我是测试Android Q文件写入的内容"</span>);</span><br><span class="line">        fw.close()</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span><span class="symbol">@FileStorageActivity</span>, <span class="string">"SD卡写入内容完成..."</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">        Log.d(tag, <span class="string">"SD卡写入内容完成..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> fr = FileReader(Environment.getExternalStorageDirectory().path+<span class="string">"/测试Android Q文件.txt"</span>);</span><br><span class="line">        <span class="keyword">val</span> r = BufferedReader(fr);</span><br><span class="line">        <span class="keyword">val</span> result = r.readLine();</span><br><span class="line">        Log.d(tag, <span class="string">"SD卡文件里面的内容:<span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-03-17 14:06:46.117 31140-31140/com.xw.androidqtest D/FileStorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/测试Android Q文件.txt</span><br><span class="line">2019-03-17 14:06:46.130 31140-31140/com.xw.androidqtest D/FileStorageActivity: SD卡写入内容完成...</span><br><span class="line">2019-03-17 14:06:50.346 31140-31140/com.xw.androidqtest D/FileStorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容</span><br></pre></td></tr></table></figure><p>查看/sdcard根下的文件，发现没有该文件，被系统自动存放在如下沙箱中</p><p><img src="/images/android-q-beta-file-test-1.png" alt="android-q-beta-file-test-1.png"></p><h3 id="测试-2-——-推荐方式-Context-getExternalFilesDir"><a href="#测试-2-——-推荐方式-Context-getExternalFilesDir" class="headerlink" title="测试 2 —— 推荐方式 Context.getExternalFilesDir()"></a>测试 2 —— 推荐方式 Context.getExternalFilesDir()</h3><p>测试将文件放入文档目录，传入<code>Environment.DIRECTORY_DOCUMENTS</code>到<code>getExternalFilesDir()</code>方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> context: Context = <span class="keyword">this</span><span class="symbol">@FileStorageActivity</span></span><br><span class="line">        <span class="keyword">val</span> file = File(context.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), <span class="string">"测试Android Q文件.txt"</span>);</span><br><span class="line">        Log.d(tag, <span class="string">"file.exists():<span class="subst">$&#123;file.exists()&#125;</span> ， file.getAbsolutePath(): <span class="subst">$&#123;file.absolutePath&#125;</span>"</span>);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span><span class="symbol">@FileStorageActivity</span>, <span class="string">"SD卡目录下创建文件成功..."</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        <span class="keyword">val</span> fw = FileWriter(file);</span><br><span class="line">        fw.write(<span class="string">"我是测试Android Q文件写入的内容"</span>);</span><br><span class="line">        fw.close()</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span><span class="symbol">@FileStorageActivity</span>, <span class="string">"SD卡写入内容完成..."</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">        Log.d(tag, <span class="string">"SD卡写入内容完成..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> context: Context = <span class="keyword">this</span><span class="symbol">@FileStorageActivity</span></span><br><span class="line">        <span class="keyword">val</span> fr = FileReader(context.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS).path + <span class="string">"/测试Android Q文件.txt"</span>);</span><br><span class="line">        <span class="keyword">val</span> r = BufferedReader(fr);</span><br><span class="line">        <span class="keyword">val</span> result = r.readLine();</span><br><span class="line">        Log.d(tag, <span class="string">"SD卡文件里面的内容:<span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-03-17 14:27:23.423 9511-9511/com.xw.androidqtest D/FileStorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/Android/data/com.xw.androidqtest/files/Documents/测试Android Q文件.txt</span><br><span class="line">2019-03-17 14:27:23.437 9511-9511/com.xw.androidqtest D/FileStorageActivity: SD卡写入内容完成...</span><br><span class="line">2019-03-17 14:27:27.696 9511-9511/com.xw.androidqtest D/FileStorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容</span><br></pre></td></tr></table></figure><p>文件所在位置：</p><p><img src="/images/android-q-beta-file-test-2.png" alt="android-q-beta-file-test-2.png"></p><p>更多示例，请参照<strong>以上内容</strong>或<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9wcml2YWN5L3Njb3BlZC1zdG9yYWdl" title="https://developer.android.google.cn/preview/privacy/scoped-storage">官方文档<i class="fa fa-external-link"></i></span>, 自行测试</p><hr><p><strong>2019-03-26 更新:</strong></p><p>得到反馈，测试 1 未能在android-10模拟器上复现成功，由于上面的测试我是在pixel 2真机上测试的，对此如下又在模拟器上进行了测试 （本次真机也同时测试了一遍）。</p><p>由于<strong>没有添加</strong>读写权限，在模拟器上运行抛出了异常 —-&gt; (真机没有任何异常)</p><p><img src="/images/android-q-beta-file-test-3.png" alt="android-q-beta-file-test-3.png"></p><p><img src="/images/android-q-beta-file-test-4.png" alt="android-q-beta-file-test-4.png"></p><p>于是<strong>添加</strong>读写权限，并<strong>动态授权</strong>，模拟器上运行无异常，但是确实写入的文件未能自动放入<strong>/Android/sandbox/com.xw.androidqtest</strong>目录下，位置没变还是在<strong>/storage/emulated/0/</strong>根目录下</p><p><img src="/images/android-q-beta-file-test-5.png" alt="android-q-beta-file-test-5.png"></p><p>针对以上的出现的问题，猜想应该是模拟器和真机之间的差异，大家怎么看？ 欢迎大家在评论处留言讨论</p><hr><blockquote><p>本文参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9wcml2YWN5L3Njb3BlZC1zdG9yYWdl" title="https://developer.android.google.cn/preview/privacy/scoped-storage">官方文档<i class="fa fa-external-link"></i></span>进行简单翻译及示例总结，感谢您的阅读。如有不足，欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android Q 系统, 对应用存储空间访问进行了限制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="Permission" scheme="https://shoewann0402.github.io/tags/Permission/"/>
    
      <category term="scoped" scheme="https://shoewann0402.github.io/tags/scoped/"/>
    
      <category term="sandbox" scheme="https://shoewann0402.github.io/tags/sandbox/"/>
    
      <category term="Shared collections" scheme="https://shoewann0402.github.io/tags/Shared-collections/"/>
    
      <category term="File" scheme="https://shoewann0402.github.io/tags/File/"/>
    
      <category term="external storage" scheme="https://shoewann0402.github.io/tags/external-storage/"/>
    
      <category term="behavior change" scheme="https://shoewann0402.github.io/tags/behavior-change/"/>
    
      <category term="media" scheme="https://shoewann0402.github.io/tags/media/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 后台启动Activity限制</title>
    <link href="https://shoewann0402.github.io/2019/03/16/android-q-beta-background-activity-starts/"/>
    <id>https://shoewann0402.github.io/2019/03/16/android-q-beta-background-activity-starts/</id>
    <published>2019-03-16T02:40:22.000Z</published>
    <updated>2019-03-17T04:55:54.707Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文针对Android Q 后台启动Activity简单总结</p></blockquote><a id="more"></a><p>Android Q对应用程序何时可以启动Activity进行了限制。</p><h1 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h1><p>这种行为的改变有助于减少用户的干扰，并让用户更好地控制屏幕上显示的内容。尤其是运行在Android Q上的应用程序，只有满足以下一个或多个条件才能启动Activity:</p><blockquote><ul><li>应用程序有一个可见的窗口，比如在前台一个的Activity。</li><li>一个在前台不同的应用程序发送了属于该应用程序的一个PendingIntent， 示例包括自定义选项卡提供者发送菜单项待定意图。</li><li>系统发送了一个属于该应用程序的PendingIntent，比如点击一条通知，只有应用程序可以启动UI的待处理意图才可以免除。</li><li>系统向应用程序发送一个广播，如<code>SECRET_CODE_ACTION</code>到应用程序。只有特定的广播，应用程序预计在UI启动时才会被豁免。</li></ul></blockquote><p>【注】出于Activity启动的目的，前台服务不将应用程序限定在前台。</p><h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>这个行为变化影响到所有运行在Android Q上的应用程序，即使是那些target版本是Android 9(API 28) 或者更低的，即使您的应用程序的target版本是Android 9或更低版本，并且最初安装在运行Android 9或更低版本的设备上，在设备升级到Android Q之后，行为更改仍然会生效。</p><p>但是，只要您的应用程序作为用户交互的直接结果启动Actvity，您的应用程序就很可能不会受到此更改的影响。</p><h1 id="警告信息"><a href="#警告信息" class="headerlink" title="警告信息"></a>警告信息</h1><p>在Beta 1中，如果你的应用程序运行在Android Q上，并试图从后台启动某个活动，平台允许该活动启动，但它会向logcat发送一条警告消息，并显示以下警告toast消息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This background activity start from package-name will be blocked in future Q builds.</span><br></pre></td></tr></table></figure><p>这则消息意思是: <strong>该后台activity从某包下启动，将在之后构建的Q版本中被屏蔽</strong></p><p>Android Q中与在后台启动Activity相关的限制与设备进入屏幕固定状态后系统阻止Activity启动的方式类似。</p><h1 id="改进方式"><a href="#改进方式" class="headerlink" title="改进方式"></a>改进方式</h1><p>几乎在所有情况下，后台应用程序都应创建通知，以便向用户提供信息，而不是直接启动Activity。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="复现警告"><a href="#复现警告" class="headerlink" title="复现警告"></a>复现警告</h2><p>为了测试复现警告消息，这里定义<code>MainActivity</code>和<code>BackgroundActivity</code>,在<code>MainActivity</code>的<code>onPause</code>方法中如下实现<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        <span class="keyword">val</span> timer = Timer()</span><br><span class="line">        <span class="keyword">val</span> timerTask = <span class="keyword">object</span> : TimerTask() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">                startActivity(Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>,BackgroundActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer.schedule(timerTask, <span class="number">5000</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>MainActivity</strong>启动之后，按Home键切换到Launcher，此时<strong>MainActivity</strong>将会执行<code>onPause</code>方法，在此方法中开启了一个定时器，模拟后台启动Activity</p><p>然后后台输出如下日志<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-03-16 10:03:10.599 1192-7709/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.BackgroundActivity&#125; from uid 10505</span><br><span class="line">2019-03-16 10:03:10.600 1192-7709/? W/ActivityTaskManager: Background activity start [callingPackage: com.xw.androidqtest; callingUid: 10505; isCallingUidForeground: false; isCallingUidPersistentSystemProcess: false; realCallingUid: 10505; isRealCallingUidForeground: false; isRealCallingUidPersistentSystemProcess: false; originatingPendingIntent: null; isBgStartWhitelisted: false; intent: Intent &#123; cmp=com.xw.androidqtest/.BackgroundActivity &#125;; callerApp: ProcessRecord&#123;b6f89ff 29017:com.xw.androidqtest/u0a505&#125;]</span><br><span class="line">2019-03-16 10:03:10.619 29017-29017/com.xw.androidqtest W/ActivityThread: handleWindowVisibility: no activity for token android.os.BinderProxy@8611b07</span><br><span class="line">2019-03-16 10:03:10.700 1192-1238/? I/ActivityTaskManager: Displayed com.xw.androidqtest/.BackgroundActivity: +96ms</span><br></pre></td></tr></table></figure></p><p>界面弹出了警告消息</p><p><img src="/images/warningMsg.png" alt="warningMsg"></p><p>参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9wcml2YWN5L2JhY2tncm91bmQtYWN0aXZpdHktc3RhcnQ=" title="https://developer.android.google.cn/preview/privacy/background-activity-start">官方文档<i class="fa fa-external-link"></i></span>，做如下处理</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>创建<strong>前台服务</strong>类，并在<code>onStartCommand</code>方法中创建一个<strong>前台通知</strong>,</p><p>以下是<strong>完整代码</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.xw.androidqtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.*</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.<span class="keyword">annotation</span>.RequiresApi</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.NotificationCompat</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForegroundService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tag: String = ForegroundService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        Log.d(tag, <span class="string">"ForegroundService OnCreate called"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        Log.d(tag, <span class="string">"ForegroundService onStartCommand called"</span>)</span><br><span class="line"></span><br><span class="line">        createNotificationChannel(<span class="string">"channelId"</span>, <span class="string">"channelName"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> fullScreenIntent = Intent(<span class="keyword">this</span>, BackgroundActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        <span class="keyword">val</span> fullScreenPendingIntent = PendingIntent.getActivity(</span><br><span class="line">            <span class="keyword">this</span>, <span class="number">0</span>,</span><br><span class="line">            fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> notificationBuilder = NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">"channelId"</span>)</span><br><span class="line">            .setSmallIcon(R.mipmap.ic_launcher_round)</span><br><span class="line">            .setContentTitle(getString(R.string.app_name))</span><br><span class="line">            .setContentText(<span class="string">"启动BackgroundActivity"</span>)</span><br><span class="line">            .setPriority(NotificationCompat.PRIORITY_HIGH)</span><br><span class="line">            .setCategory(NotificationCompat.CATEGORY_CALL)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use a full-screen intent only for the highest-priority alerts where you</span></span><br><span class="line">            <span class="comment">// have an associated activity that you would like to launch after the user</span></span><br><span class="line">            <span class="comment">// interacts with the notification. Also, if your app targets Android Q, you</span></span><br><span class="line">            <span class="comment">// need to request the USE_FULL_SCREEN_INTENT permission in order for the</span></span><br><span class="line">            <span class="comment">// platform to invoke this notification.</span></span><br><span class="line">            .setFullScreenIntent(fullScreenPendingIntent, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> incomingCallNotification = notificationBuilder.build()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The integer ID that you give to startForeground() must not be 0.</span></span><br><span class="line">        startForeground(<span class="number">1</span>, incomingCallNotification)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> START_STICKY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.O)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotificationChannel</span><span class="params">(channelId: <span class="type">String</span>, channelName: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> channel = NotificationChannel(</span><br><span class="line">            channelId,</span><br><span class="line">            channelName, NotificationManager.IMPORTANCE_NONE</span><br><span class="line">        )</span><br><span class="line">        channel.lightColor = Color.BLUE</span><br><span class="line">        channel.lockscreenVisibility = Notification.VISIBILITY_PRIVATE</span><br><span class="line">        <span class="keyword">val</span> service = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        service.createNotificationChannel(channel)</span><br><span class="line">        <span class="keyword">return</span> channelId</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        stopForeground(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>清单文件</code>注册权限<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.FOREGROUND_SERVICE"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- New Android Q permission --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.USE_FULL_SCREEN_INTENT"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>最后更新<code>onPause</code>方法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        <span class="keyword">val</span> timer = Timer()</span><br><span class="line">        <span class="keyword">val</span> timerTask = <span class="keyword">object</span> : TimerTask() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">                startService(Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, ForegroundService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer.schedule(timerTask, <span class="number">5000</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>运行输出日志：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-03-16 10:25:22.308 9112-9112/com.xw.androidqtest D/ForegroundService: ForegroundService OnCreate called</span><br><span class="line">2019-03-16 10:25:22.309 9112-9112/com.xw.androidqtest D/ForegroundService: ForegroundService onStartCommand called</span><br></pre></td></tr></table></figure></p><p>通知栏收到了发出的通知</p><p><img src="/images/warningMsgFix.png" alt="warningMsgFix"></p><p>点击通知进入了需要后台启动的<code>BackgroundActivity</code><br>日志内容 ：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-03-16 10:29:04.074 1192-4994/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.BackgroundActivity&#125; from uid 10505</span><br><span class="line">2019-03-16 10:29:04.074 1192-4994/? W/ActivityTaskManager: startActivity called from non-Activity context; forcing Intent.FLAG_ACTIVITY_NEW_TASK for: Intent &#123; cmp=com.xw.androidqtest/.BackgroundActivity &#125;</span><br><span class="line">2019-03-16 10:29:04.082 9112-9112/com.xw.androidqtest W/ActivityThread: handleWindowVisibility: no activity for token android.os.BinderProxy@46d3c48</span><br><span class="line">2019-03-16 10:29:04.084 1192-1251/? W/WindowManager: TaskSnapshotSurface.create: Failed to find main window for token=AppWindowToken&#123;6b40830 token=Token&#123;fb2f173 ActivityRecord&#123;7d079e2 u0 com.xw.androidqtest/.BackgroundActivity t800&#125;&#125;&#125;</span><br><span class="line">2019-03-16 10:29:04.143 1192-1238/? I/ActivityTaskManager: Displayed com.xw.androidqtest/.BackgroundActivity: +69ms</span><br></pre></td></tr></table></figure></p><h1 id="开启行为变化"><a href="#开启行为变化" class="headerlink" title="开启行为变化"></a>开启行为变化</h1><p>即使这种行为变化在默认情况下不会在Android Q Beta 1中生效，您也可以通过完成以下任务之一来模拟这种行为变化:</p><blockquote><ul><li>导航到“设置&gt;开发人员选项”，并禁用“允许后台活动启动”选项</li><li>在终端中执行如下命令<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global background_activity_starts_enabled <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="模拟测试"><a href="#模拟测试" class="headerlink" title="模拟测试"></a>模拟测试</h2><p>将代码还原成直接调用从后台启动Activity，设置好如上所叙述的操作，测试<br>效果图</p><p><img src="/images/warningQMsg.png" alt="warningQMsg"></p><p>与文章一开始测试不同之处就是: <strong>目前在Q Beta1上默认还是会启动起后台的Activity展示并显示toast消息，这次测试模拟了最终完全屏蔽的情况，不会调起后台的Activity</strong></p><blockquote><p>本文参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9wcml2YWN5L2JhY2tncm91bmQtYWN0aXZpdHktc3RhcnQ=" title="https://developer.android.google.cn/preview/privacy/background-activity-start">官方文档<i class="fa fa-external-link"></i></span>进行简单总结，感谢您的阅读。如有不足，欢迎指正</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文针对Android Q 后台启动Activity简单总结&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Activity" scheme="https://shoewann0402.github.io/tags/Activity/"/>
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="Background" scheme="https://shoewann0402.github.io/tags/Background/"/>
    
  </entry>
  
  <entry>
    <title>关于 Android Q 定位</title>
    <link href="https://shoewann0402.github.io/2019/03/15/about-android-q-beta-location/"/>
    <id>https://shoewann0402.github.io/2019/03/15/about-android-q-beta-location/</id>
    <published>2019-03-15T02:42:12.000Z</published>
    <updated>2019-03-17T08:03:29.094Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android Q Location 的简单总结</p></blockquote><a id="more"></a><hr><h2 id="以往情况"><a href="#以往情况" class="headerlink" title="以往情况"></a>以往情况</h2><blockquote><ul><li>Android API &lt; 23 : 无需动态请求，直接注册使用位置权限</li><li>Android API &gt; = 23 &amp;&amp; API &lt; = 28: 需要动态请求权限，并<strong>允许</strong>/<strong>拒绝</strong>权限</li></ul></blockquote><p>从之前来看，用户只有一个控件<code>允许</code>或<code>拒绝</code>应用程序访问设备位置，包括应用程序在使用时和不使用时的位置使用情况。</p><p>在Android Q上，Android团队对控件进行了改进</p><h2 id="有何变化"><a href="#有何变化" class="headerlink" title="有何变化"></a>有何变化</h2><p><img src="/images/android_q_location_test.png" alt="android_q_location_test.png"></p><p>从Android Q开始，用户有一个新选项，只有在使用该应用时才能让应用访问该位置; 换句话说，当应用程序在前台时。这意味着用户可以选择三种选项来为应用提供位置：</p><blockquote><ul><li><code>All the time</code> - 意味着APP任何时候都能访问到位置</li><li><code>While in use</code> - 意味着APP只有当在使用的时候才能访问到位置</li><li><code>Deny</code> - 意味着APP无法访问到位置</li></ul></blockquote><p>从Android Q Beta 1开始，此更改具有以下属性：</p><blockquote><ul><li>如果您在后台请求访问用户的位置，则会影响您的应用</li><li>通过使用新权限在后台访问位置并在没有后台位置更新的情况下确保优雅降级来进行缓解</li><li>Android Q上始终启用行为</li></ul></blockquote><h2 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_BACKGROUND_LOCATION"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果您的应用具有需要“始终”权限的功能</p><blockquote><ul><li>target version Q : 您需要为清单文件添加新的<code>ACCESS_BACKGROUND_LOCATION</code>权限</li></ul></blockquote><blockquote><ul><li>target version &lt;= Android 9 (API 28)  :  如果您请求<code>ACCESS_FINE_LOCATION</code>或<code>ACCESS_COARSE_LOCATION</code>中的任何一个，系统将会自动为您添加<code>ACCESS_BACKGROUND_LOCATION</code>权限</li></ul></blockquote><p>用户可以随时通过<code>设置</code>决定提供或删除这些位置权限。 要保持良好的用户体验，请将应用程序设计为在应用程序没有后台位置权限或没有任何位置访问权限时进行优雅处理。</p><blockquote><p><strong>注意</strong>：虽然您的应用可以请求并接收ACCESS_BACKGROUND_LOCATION，但用户可以通过选择您的应用仅应在前台访问位置信息来撤消此权限。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xw.androidqtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.Manifest</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.ActivityCompat</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_location.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocationActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> tag: String = LocationActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE_FOREGROUND = <span class="number">1</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE_BACKGROUND = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_location)</span><br><span class="line"></span><br><span class="line">        btnForeground.setOnClickListener &#123;</span><br><span class="line">            requestPermission()</span><br><span class="line">        &#125;</span><br><span class="line">        btnBackground.setOnClickListener &#123;</span><br><span class="line">            requestBackgroundPermission()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(requestCode: <span class="type">Int</span>, permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;, grantResults: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">            REQUEST_CODE_FOREGROUND -&gt; handlePermissionForForeground()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> permissionAccessCoarseLocationApproved = ActivityCompat</span><br><span class="line">            .checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_COARSE_LOCATION) ==</span><br><span class="line">                PackageManager.PERMISSION_GRANTED</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (permissionAccessCoarseLocationApproved) &#123;</span><br><span class="line">            handlePermissionForForeground()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(<span class="keyword">this</span>,</span><br><span class="line">                arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION), REQUEST_CODE_FOREGROUND)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestBackgroundPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> permissionAccessCoarseLocationApproved = ActivityCompat</span><br><span class="line">            .checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_COARSE_LOCATION) ==</span><br><span class="line">                PackageManager.PERMISSION_GRANTED</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (permissionAccessCoarseLocationApproved) &#123;</span><br><span class="line">            <span class="keyword">val</span> backgroundLocationPermissionApproved = ActivityCompat</span><br><span class="line">                .checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_BACKGROUND_LOCATION) ==</span><br><span class="line">                    PackageManager.PERMISSION_GRANTED</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (backgroundLocationPermissionApproved) &#123;</span><br><span class="line">                <span class="comment">// App can access location both in the foreground and in the background.</span></span><br><span class="line">                <span class="comment">// Start your service that doesn't have a foreground service type</span></span><br><span class="line">                <span class="comment">// defined.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// App can only access location in the foreground. Display a dialog</span></span><br><span class="line">                <span class="comment">// warning the user that your app must have all-the-time access to</span></span><br><span class="line">                <span class="comment">// location in order to function properly. Then, request background</span></span><br><span class="line">                <span class="comment">// location.</span></span><br><span class="line">                ActivityCompat.requestPermissions(<span class="keyword">this</span>,</span><br><span class="line">                    arrayOf(Manifest.permission.ACCESS_BACKGROUND_LOCATION), REQUEST_CODE_BACKGROUND)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// App doesn't have access to the user's location at all. Make full request</span></span><br><span class="line">            <span class="comment">// for permission.</span></span><br><span class="line">            ActivityCompat.requestPermissions(<span class="keyword">this</span>,</span><br><span class="line">                arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION,</span><br><span class="line">                    Manifest.permission.ACCESS_BACKGROUND_LOCATION), REQUEST_CODE_BACKGROUND)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handlePermissionForForeground</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(tag,<span class="string">"handlePermissionForForeground called"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上是对Android Q 位置变化的简单总结，更多使用方法请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcHJldmlldy9wcml2YWN5L2RldmljZS1sb2NhdGlvbg==" title="https://developer.android.google.cn/preview/privacy/device-location">官方文档<i class="fa fa-external-link"></i></span></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android Q Location 的简单总结&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
      <category term="Location" scheme="https://shoewann0402.github.io/tags/Location/"/>
    
      <category term="Permission" scheme="https://shoewann0402.github.io/tags/Permission/"/>
    
  </entry>
  
  <entry>
    <title>介绍 Android Q Beta版</title>
    <link href="https://shoewann0402.github.io/2019/03/14/introducing-android-q-beta/"/>
    <id>https://shoewann0402.github.io/2019/03/14/introducing-android-q-beta/</id>
    <published>2019-03-14T00:10:37.000Z</published>
    <updated>2019-03-14T02:16:29.575Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自: <span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOS8wMy9pbnRyb2R1Y2luZy1hbmRyb2lkLXEtYmV0YS5odG1s" title="https://android-developers.googleblog.com/2019/03/introducing-android-q-beta.html">Introducing Android Q Beta<i class="fa fa-external-link"></i></span></p></blockquote><a id="more"></a><p>2019年，移动创新比以往更加强大。新型科技从5G到边缘，再到边缘显示器，甚至是可折叠屏幕。<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmxvZy5nb29nbGUvcHJvZHVjdHMvYW5kcm9pZC9zaGFwaW5nLWZ1dHVyZS1tb2JpbGUtYW5kcm9pZC8=" title="https://www.blog.google/products/android/shaping-future-mobile-android/">Android正处于这个创新周期的中心<i class="fa fa-external-link"></i></span>，感谢数十亿设备的合作伙伴广泛的生态系统。Android帮助推动了硬件和软件的界限，带给用户全新的体验和功能。</p><p>随着移动生态系统的发展，Android着重于帮助用户利用最新的创新，确保用户的安全和隐私始终是首要任务，在像Google Pley Protect和运行时权限的基础上构建。Android Q 带来了额外的隐私和安全功能给用户，以及增强可折叠，用于连接新的APIs,新的媒体解码器和相机功能，NNAPI扩展，Vulkan 1.1支持，更快的应用程序启动，以及更多。</p><p>今天我们为早期采纳者发布了Android Q Beta 1 版本并为开发者发布SDK预览版。您今天可以通过<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9hbmRyb2lkL2JldGE=" title="https://www.google.com/android/beta">注册任意Pixel设备<i class="fa fa-external-link"></i></span>(包括原版的Pixel和Pixel XL,我们通过大众需求扩大了支持！)请<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWVkYmFjaw==" title="https://developer.android.com/preview/feedback">让我们知道您的想法！<i class="fa fa-external-link"></i></span>，继续阅读，了解Android Q中的内容，我们将在<span class="exturl" data-url="aHR0cHM6Ly9ldmVudHMuZ29vZ2xlLmNvbS9pby8=" title="https://events.google.com/io/">5月份的Google I / O<i class="fa fa-external-link"></i></span>上看到您，我们将分享更多内容。</p><h1 id="建立在Android的隐私保护之上"><a href="#建立在Android的隐私保护之上" class="headerlink" title="建立在Android的隐私保护之上"></a>建立在Android的隐私保护之上</h1><p>Android的设计以安全和隐私为中心,随着Android的成熟,我们增加了很多功能来保护用户,像<span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vc2VjdXJpdHkvZW5jcnlwdGlvbi9maWxlLWJhc2Vk" title="https://source.android.com/security/encryption/file-based">基于文件的加密<i class="fa fa-external-link"></i></span>、操作系统控制要求应用程序在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvdG9waWNzL3Blcm1pc3Npb25zL292ZXJ2aWV3" title="https://developer.android.com/guide/topics/permissions/overview">访问敏感资源之前请求权限<i class="fa fa-external-link"></i></span>、锁定<span class="exturl" data-url="aHR0cHM6Ly93d3cudGhldmVyZ2UuY29tLzIwMTgvMy83LzE3MDkxMTA0L2FuZHJvaWQtcC1wcmV2ZW50cy1hcHBzLXVzaW5nLW1pYy1jYW1lcmEtaWRsZS1iYWNrZ3JvdW5k" title="https://www.theverge.com/2018/3/7/17091104/android-p-prevents-apps-using-mic-camera-idle-background">相机/麦克风后台访问<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29tcHV0ZXJ3b3JsZC5jb20vYXJ0aWNsZS8zMjk3MDM5L2FuZHJvaWQtcGllLXNlY3VyaXR5LXNldHRpbmcuaHRtbA==" title="https://www.computerworld.com/article/3297039/android-pie-security-setting.html">锁定模式<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9zZWN1cml0eS5nb29nbGVibG9nLmNvbS8yMDE4LzEwL2dvb2dsZS1hbmQtYW5kcm9pZC1oYXZlLXlvdXItYmFjay1ieS5odG1s" title="https://security.googleblog.com/2018/10/google-and-android-have-your-back-by.html">加密备份<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5kcm9pZC5jb20vcGxheS1wcm90ZWN0Lw==" title="https://www.android.com/play-protect/">Google Play Protect<i class="fa fa-external-link"></i></span>(每天扫描超过500亿个应用程序，以识别潜在的有害应用程序并删除它们)以及更多。在Android Q中，我们已经做了更多的增强来保护我们的用户，其中许多增强是我们在Strobe项目中工作的一部分。</p><h2 id="给用户更多的位置控制"><a href="#给用户更多的位置控制" class="headerlink" title="给用户更多的位置控制"></a>给用户更多的位置控制</h2><p>使用Android Q，操作系统帮助用户更好地控制应用程序何时可以获得位置。就像之前的操作系统版本一样，应用程序只有在请求你的权限并得到你的许可后才能获得位置信息。</p><p>特别敏感的一件事是，应用程序在不使用的情况下(在后台)访问位置。Android Q 允许用户永远不允许应用程序查看自己的位置，只在应用程序正在使用(运行)或一直在使用(后台)时才允许。</p><p><img src="/images/android_q_loc_dialog.png" alt="android_q_loc_dialog"></p><p>例如，一个应用程序询问用户食品配送的位置是有意义的，用户可能希望授予它这样做的能力。但由于应用程序可能不需要当前正在使用的位置之外的位置，用户可能不想授予该访问权限。Android Q现在提供了更高级别的控制。请阅读<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5L2RldmljZS1sb2NhdGlvbg==" title="https://developer.android.com/preview/privacy/device-location">开发人员指南<i class="fa fa-external-link"></i></span>，了解有关如何使应用程序适应此新控件的详细信息。期待更多以用户为中心的改进出现在即将到来的beta中。我们的目标是非常敏感地，始终为开发人员提供尽可能多的通知和支持。</p><h2 id="Android-Q中更多的隐私保护"><a href="#Android-Q中更多的隐私保护" class="headerlink" title="Android Q中更多的隐私保护"></a>Android Q中更多的隐私保护</h2><p>除了位置的改变，我们还在进行进一步的更新，以确保透明度、用户控制权和个人数据的安全。</p><p>在Android Q 中，该操作系统让用户对应用程序有了更多的控制，控制对共享文件的访问。用户将能够通过新的运行时权限控制应用程序对照片、视频或音频集合的访问。对于下载，应用程序必须使用系统文件选择器，这允许用户决定应用程序可以访问哪些下载文件。对于开发人员来说，您的应用程序如何在外部存储上使用共享区域有一些变化。请确保阅读作用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5L3Njb3BlZC1zdG9yYWdl" title="https://developer.android.com/preview/privacy/scoped-storage">域存储(Scoped Storage)更改<i class="fa fa-external-link"></i></span>以获得详细信息。</p><p>我们还看到，当一个应用程序意外地跳到前台并占据焦点时，用户(和开发人员)会感到不安。为了减少这些干扰，Android Q将阻止应用程序在后台启动活动。如果你的应用程序在后台，需要迅速吸引用户的注意力——比如来电或闹钟——你可以使用高优先级通知，并提供全屏意图。有关更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5L2JhY2tncm91bmQtYWN0aXZpdHktc3RhcnRz" title="https://developer.android.com/preview/privacy/background-activity-starts">文档<i class="fa fa-external-link"></i></span>。</p><p>我们限制对不可重置设备标识符的访问，包括设备IMEI、序列号和类似标识符。阅读<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdHJhaW5pbmcvYXJ0aWNsZXMvdXNlci1kYXRhLWlkcw==" title="https://developer.android.com/training/articles/user-data-ids">最佳实践<i class="fa fa-external-link"></i></span>，以帮助您为用例选择正确的标识符，并在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5L2RhdGEtaWRlbnRpZmllcnM=" title="https://developer.android.com/preview/privacy/data-identifiers">这里<i class="fa fa-external-link"></i></span>查看详细信息。在默认情况下，当连接到不同的Wi-Fi网络时，我们还会随机设置设备的MAC地址——这在Android 9 Pie中是可选的。</p><p>我们提前把这些变化告诉你，这样你就可以有尽可能多的时间来准备。我们还努力为开发人员预先提供详细的信息，我们建议查看关于隐私更改的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5" title="https://developer.android.com/preview/privacy">详细文档<i class="fa fa-external-link"></i></span>，并立即开始测试。</p><h1 id="吸引用户的新方式"><a href="#吸引用户的新方式" class="headerlink" title="吸引用户的新方式"></a>吸引用户的新方式</h1><p>在Android Q中，我们启用了新的方式将用户带入你的应用程序，并在他们从其他应用程序过渡时简化体验。</p><h2 id="折叠和创新的新屏幕"><a href="#折叠和创新的新屏幕" class="headerlink" title="折叠和创新的新屏幕"></a>折叠和创新的新屏幕</h2><p>可折叠设备开辟了一些创新的经验和用例。为了帮助你的应用程序更好地利用这些和其他大屏幕设备，我们在Android Q中做了很多改进，包括onResume和onPause的改变，以支持多简历，并在你的应用程序有焦点时通知你。我们还更改了resizeableActivity manifest属性的工作方式，以帮助您管理应用程序在可折叠和大屏幕上的显示方式。为了让您开始在这些新设备上构建和测试，我们一直在努力更新Android模拟器，以支持多显示器类型切换——更多细节即将公布!</p><p><img src="/images/android_q_map.png" alt="android_q_map"></p><h2 id="分享快捷键"><a href="#分享快捷键" class="headerlink" title="分享快捷键"></a>分享快捷键</h2><p>当用户想在另一个应用程序中与他人分享照片等内容时，过程应该很快。在Android Q中，我们通过共享快捷方式让这一过程变得更快更简单，用户可以直接跳转到另一个应用程序来共享内容。开发人员可以发布共享目标，这些目标在应用程序中启动带有附加内容的特定活动，并在共享UI中显示给用户。因为它们是预先发布的，所以可以在启动时立即加载共享UI。</p><p><img src="/images/android_q_share.png" alt="android_q_share"></p><p>共享快捷方式机制类似于应用程序快捷方式的工作方式，因此我们扩展了<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvY29udGVudC9wbS9TaG9ydGN1dEluZm8=" title="https://developer.android.com/reference/android/content/pm/ShortcutInfo">ShortcutInfo API<i class="fa fa-external-link"></i></span>，以便更容易地集成这两个功能。新的ShareTarget AndroidX库也支持这个新的API。这允许应用程序使用新功能，同时允许pre-Q设备使用直接共享。您可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvYW5kcm9pZC1TaGFyaW5nU2hvcnRjdXRz" title="https://github.com/googlesamples/android-SharingShortcuts">这里<i class="fa fa-external-link"></i></span>找到带有源代码的早期示例应用程序。</p><h2 id="设置面板"><a href="#设置面板" class="headerlink" title="设置面板"></a>设置面板</h2><p>现在，您还可以通过一个新的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvcHJvdmlkZXIvU2V0dGluZ3MuUGFuZWw=" title="https://developer.android.com/reference/android/provider/Settings.Panel">设置面板API<i class="fa fa-external-link"></i></span>在应用程序上下文中直接显示关键系统设置，该API利用了我们在Android 9 Pie中引入的slice特性。</p><p>设置面板是一个浮动的UI，您可以从应用程序中调用它来显示用户可能需要的系统设置，比如internet连接、NFC和音频音量。例如，浏览器可以显示带有连接设置的面板，如飞机模式、Wi-Fi(包括附近的网络)和移动数据。没有必要离开应用程序;用户可以根据需要从面板管理设置。要显示设置面板，只需使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvcHJvdmlkZXIvU2V0dGluZ3MuUGFuZWwuaHRtbCNBQ1RJT05fSU5URVJORVRfQ09OTkVDVElWSVRZ" title="https://developer.android.com/reference/android/provider/Settings.Panel.html#ACTION_INTERNET_CONNECTIVITY">Settings.Panel actions<i class="fa fa-external-link"></i></span>其中一个新设置触发一个intent</p><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>在Android Q中，我们扩展了您的应用程序可以使用Android的连接堆栈并添加新的连接API。</p><p><img src="/images/android_q_connect.png" alt="android_q_connect"></p><h2 id="连接权限、隐私和安全性"><a href="#连接权限、隐私和安全性" class="headerlink" title="连接权限、隐私和安全性"></a>连接权限、隐私和安全性</h2><p>大多数用于扫描网络的api已经需要粗位置权限，但在Android Q 中，对于蓝牙、蜂窝网络和Wi-Fi，我们正在通过要求精细位置权限来增强对这些api的保护。如果你的应用只需要建立点对点连接或推荐网络，看看下面改进的Wi-Fi api——它们简化了连接，不需要位置许可。</p><p>除了Android Q在连接不同Wi-Fi网络时提供的随机MAC地址，我们还增加了新的Wi-Fi标准支持WP3和OWE，以提高家庭和工作网络以及开放/公共网络的安全性。</p><h2 id="改进的点对点和互联网连接"><a href="#改进的点对点和互联网连接" class="headerlink" title="改进的点对点和互联网连接"></a>改进的点对点和互联网连接</h2><p>在Android Q中，我们重构了Wi-Fi堆栈，以改善隐私和性能，但也改善了常见的用例，比如管理物联网设备和建议互联网连接——不需要位置许可。</p><p>网络连接api使得通过本地Wi-Fi管理物联网设备变得更加容易，可以实现配置、下载或打印等对等功能。应用程序通过指定首选的ssid和bssid作为<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvbmV0L05ldHdvcmtTcGVjaWZpZXIuaHRtbA==" title="https://developer.android.com/reference/android/net/NetworkSpecifier.html">WiFiNetworkSpecifiers<i class="fa fa-external-link"></i></span>间接启动连接请求。该平台自己处理Wi-Fi扫描，并在Wi-Fi选择器中显示匹配的网络。当用户选择时，平台会自动设置连接。</p><p>网络建议api允许应用程序在互联网连接方面显示用户更喜欢的Wi-Fi网络。应用程序通过提供网络和证书列表作为<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvbmV0L3dpZmkvV2lmaU5ldHdvcmtTdWdnZXN0aW9u" title="https://developer.android.com/reference/android/net/wifi/WifiNetworkSuggestion">WifiNetworkSuggestion<i class="fa fa-external-link"></i></span>来间接启动连接。该平台将基于过去的性能无缝连接时，在这些网络范围。</p><h2 id="Wi-Fi-性能模式"><a href="#Wi-Fi-性能模式" class="headerlink" title="Wi-Fi 性能模式"></a>Wi-Fi 性能模式</h2><p>现在你可以在Android Q中通过启用高性能和低延迟模式来请求自适应Wi-Fi。在低延迟对用户体验非常重要的情况下，如实时游戏、活动语音呼叫和类似的用例，这些将非常有用。</p><p>要使用新的性能模式，请使用WIFI_MODE_FULL_LOW_LATENCY或WIFI_MODE_FULL_HIGH_PERF调用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvbmV0L3dpZmkvV2lmaU1hbmFnZXIuaHRtbCNjcmVhdGVXaWZpTG9jayhpbnQsJTIwamF2YS5sYW5nLlN0cmluZw==" title="https://developer.android.com/reference/android/net/wifi/WifiManager.html#createWifiLock(int,%20java.lang.String">WifiManager.WifiLock.createWifiLock()<i class="fa fa-external-link"></i></span>)。在这些模式下，平台与设备固件协同工作，以满足功耗最低的要求。</p><h1 id="相机、媒体、图形"><a href="#相机、媒体、图形" class="headerlink" title="相机、媒体、图形"></a>相机、媒体、图形</h1><h2 id="动态深度格式的照片"><a href="#动态深度格式的照片" class="headerlink" title="动态深度格式的照片"></a>动态深度格式的照片</h2><p>许多移动设备上的相机可以通过模糊前景或背景来模拟较窄的景深。它们为图像中的不同点捕获深度元数据，并对图像应用静态模糊，然后丢弃深度元数据。</p><p>从Android Q开始，应用程序可以请求一个动态深度图像，该图像由一个JPEG、XMP元数据(与深度相关的元素相关)和一个深度和置信度地图组成，这些数据嵌入到宣传支持的设备的同一个文件中。</p><p>要求JPEG +动态深度图像可以让你在你的应用程序中提供专门的模糊和bokeh选项。你甚至可以使用这些数据来创建3D图像或支持AR摄影用例。我们正在使动态深度成为生态系统的一种开放格式，我们正在与我们的设备制造商合作伙伴合作，使其在运行Android Q及更高版本的设备上可用。</p><p><img src="/images/q_depth_image_x.jpg" alt="q_depth_image_x.jpg"></p><p><img src="/images/q_depth_image_xx.jpg" alt="q_depth_image_xx.jpg"></p><p><img src="/images/q_depth_image_xxx.jpg" alt="q_depth_image_xxx.jpg"></p><p>使用动态深度图像，你可以在你的应用程序中提供专门的模糊和背景虚化选项。</p><h2 id="新的音频和视频编解码器"><a href="#新的音频和视频编解码器" class="headerlink" title="新的音频和视频编解码器"></a>新的音频和视频编解码器</h2><p>Android Q引入了对开源视频编解码器<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQVYx" title="https://en.wikipedia.org/wiki/AV1">AV1<i class="fa fa-external-link"></i></span>的支持。这使得媒体供应商可以用<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQVYxI1F1YWxpdHlfYW5kX2VmZmljaWVuY3k=" title="https://en.wikipedia.org/wiki/AV1#Quality_and_efficiency">更少的带宽<i class="fa fa-external-link"></i></span>向Android设备传输高质量的视频内容。此外，Android Q支持使用<span class="exturl" data-url="aHR0cDovL29wdXMtY29kZWMub3JnLw==" title="http://opus-codec.org/">Opus<i class="fa fa-external-link"></i></span>进行音频编码，Opus是一种针对语音和音乐流媒体进行优化的编解码器，<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGlnaC1keW5hbWljLXJhbmdlX3ZpZGVvI0hEUjEwKw==" title="https://en.wikipedia.org/wiki/High-dynamic-range_video#HDR10+">HDR10+<i class="fa fa-external-link"></i></span>用于支持Opus的设备上的高动态范围视频。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvbWVkaWEvTWVkaWFDb2RlY0luZm8=" title="https://developer.android.com/reference/android/media/MediaCodecInfo">MediaCodecInfo API<i class="fa fa-external-link"></i></span>引入了一种更简单的方法来确定Android设备的视频呈现能力。对于任何给定的编解码器，都可以使用VideoCodecCapabilities.getSupportedPerformancePoints()获得支持的大小和帧速率列表。这允许您选择在任何给定设备上呈现的最佳质量的视频内容。</p><h2 id="Vulkan上的ANGLE"><a href="#Vulkan上的ANGLE" class="headerlink" title="Vulkan上的ANGLE"></a>Vulkan上的ANGLE</h2><p>为了使游戏和图形开发人员更加一致，我们正在为所有基于Vulkan的设备开发一个标准的、可更新的OpenGL驱动程序。在Android Q中，我们在Android设备的Vulkan之上添加了对<span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2FuZ2xlL2FuZ2xlLysvbWFzdGVyL1JFQURNRS5tZA==" title="https://chromium.googlesource.com/angle/angle/+/master/README.md">ANGLE<i class="fa fa-external-link"></i></span>的实验性支持。ANGLE是一个图形抽象层，用于实现高性能的OpenGL兼容性。通过angular，许多使用OpenGL ES的应用程序和游戏都可以利用Vulkan的性能和稳定性，并从Android设备上对ES的一致、独立于供应商的实现中获益。在Android Q中，我们计划支持OpenGL ES 2.0，下一步将支持ES 3.0。</p><p>我们将使用更多OpenGL功能、bug修复和性能优化来扩展实现。有关Android中当前角度支持的详细信息，如何使用它，以及我们未来的计划，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcyNhbmdsZQ==" title="https://developer.android.com/preview/features#angle">文档<i class="fa fa-external-link"></i></span>。您可以通过“设置”中的“开发人员选项”选择我们的初始支持来开始测试。今天就试试吧!</p><h2 id="Vulkan-无处不在"><a href="#Vulkan-无处不在" class="headerlink" title="Vulkan 无处不在"></a>Vulkan 无处不在</h2><p>我们正在继续扩大<span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvdnVsa2FuLw==" title="https://www.khronos.org/vulkan/">Vulkan<i class="fa fa-external-link"></i></span>对Android的影响，我们为高性能3D图形<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vbmRrL2d1aWRlcy9ncmFwaGljcy8=" title="https://developer.android.com/ndk/guides/graphics/">实现了<i class="fa fa-external-link"></i></span>低开销、跨平台的API。我们的目标是使Android上的Vulkan成为一个广泛支持的、一致的图形开发人员API。我们正在与我们的设备制造商合作伙伴共同努力，使Vulkan 1.1成为所有运行Android Q或更高版本的64位设备的要求，并成为所有32位设备的推荐标准。未来，这将有助于为应用程序和游戏提供统一的高性能图形API。</p><h2 id="神经网络-API-1-2"><a href="#神经网络-API-1-2" class="headerlink" title="神经网络 API 1.2"></a>神经网络 API 1.2</h2><p>自2017年推出神经网络API (NNAPI)以来，我们继续扩大支持的操作数量，并改进现有功能。在Android Q中，我们增加了60个新操作，包括ARGMAX, ARGMIN，量化LSTM，以及一系列的性能优化。这为加速更大范围的模型奠定了基础，比如用于目标检测和图像分割的模型。我们正在与硬件供应商和流行的机器学习框架(如<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcv" title="https://www.tensorflow.org/">TensorFlow<i class="fa fa-external-link"></i></span>)合作，优化和推出对NNAPI 1.2的支持。</p><h1 id="Android基础的加强"><a href="#Android基础的加强" class="headerlink" title="Android基础的加强"></a>Android基础的加强</h1><h2 id="ART-性能"><a href="#ART-性能" class="headerlink" title="ART 性能"></a>ART 性能</h2><p>Android Q对ART运行时进行了几项新的改进，帮助应用程序更快地启动并消耗更少的内存，而不需要开发人员做任何工作。</p><p>自Android Nougat以来，ART提供了<span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vZGV2aWNlcy90ZWNoL2RhbHZpay9qaXQtY29tcGlsZXI=" title="https://source.android.com/devices/tech/dalvik/jit-compiler">Profile Guided Optimization <i class="fa fa-external-link"></i></span>(PGO)，它通过识别和预编译代码中经常执行的部分，随着时间的推移加快了应用程序的启动速度。为了帮助最初的应用程序启动，谷歌Play现在提供了基于云的配置文件和apk。这些都是匿名的、聚合的艺术配置文件，可以让艺术在应用程序运行之前预先编译应用程序的某些部分，从而为整个优化过程提供了一个重要的起点。基于云的配置文件对所有应用程序都有好处，而且运行Android P或更高版本的设备已经可以使用这些配置文件。</p><p><img src="/images/android_q_art.png" alt="android_q_art"></p><p>我们还在继续改进ART本身。例如，在Android Q中，我们通过提前启动应用程序进程并将其移至安全容器来优化Zygote进程，因此可以立即启动。 我们将更多信息存储在应用程序的堆映像中，例如类，并使用线程来更快地加载映像。 我们还在ART的Concurrent Copying（CC）垃圾收集器中添加了Generational Garbage Collection。 分代CC更有效率，因为它分别收集年轻代对象，与全堆GC相比，成本更低，同时仍然可以回收大量空间。 这使得垃圾收集整体上在时间和CPU方面更加高效，减少了jank并帮助应用程序在低端设备上更好地运行。</p><h2 id="应用安全"><a href="#应用安全" class="headerlink" title="应用安全"></a>应用安全</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvaGFyZHdhcmUvYmlvbWV0cmljcy9wYWNrYWdlLXN1bW1hcnk=" title="https://developer.android.com/reference/android/hardware/biometrics/package-summary">BiometricPrompt<i class="fa fa-external-link"></i></span>是我们的统一认证框架，支持系统级的生物识别。在Android Q中，我们扩展了对被动身份验证方法(如face)的支持，并添加了隐式和显式身份验证流。在显式流中，用户必须在身份验证期间显式地确认TEE中的事务。隐式流是为使用被动身份验证的事务设计的轻量级替代方案。我们还改进了设备凭据在需要时的回退。</p><p>Android Q增加了对TLS 1.3的支持，<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWV0Zi5vcmcvYmxvZy90bHMxMy8=" title="https://www.ietf.org/blog/tls13/">TLS 1.3<i class="fa fa-external-link"></i></span>是对TLS标准的重大修订，包括性能优势和增强的安全性。 我们的基准测试表明，与TLS 1.2相比，使用TLS 1.3可以将安全连接的速度提高40％。 默认情况下，为所有TLS连接启用TLS 1.3。 有关详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcyN0bHMtMS4z" title="https://developer.android.com/preview/features#tls-1.3">文档<i class="fa fa-external-link"></i></span>。</p><h2 id="通过公共api的兼容性"><a href="#通过公共api的兼容性" class="headerlink" title="通过公共api的兼容性"></a>通过公共api的兼容性</h2><p>我们都关心的另一件事是确保应用程序在操作系统变化和发展的过程中运行顺畅。使用非sdk api的应用程序对用户有崩溃的风险，对开发人员有紧急推出的风险。在Android Q中，我们将继续从<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vYWJvdXQvdmVyc2lvbnMvcGllL3Jlc3RyaWN0aW9ucy1ub24tc2RrLWludGVyZmFjZXM=" title="https://developer.android.com/about/versions/pie/restrictions-non-sdk-interfaces">Android P开始<i class="fa fa-external-link"></i></span>的长期努力，将应用程序转向只使用公共api。我们知道将您的应用程序从非sdk api中移除需要时间，所以我们<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOC8wNi9hbi11cGRhdGUtb24tbm9uLXNkay1yZXN0cmljdGlvbnMtaW4uaHRtbA==" title="https://android-developers.googleblog.com/2018/06/an-update-on-non-sdk-restrictions-in.html">提前通知您<i class="fa fa-external-link"></i></span>。</p><p>在Android Q中，我们限制了对<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9ub24tc2RrLXEjZ3JleWxpc3Qtbm93LXJlc3RyaWN0ZWQ=" title="https://developer.android.com/preview/non-sdk-q#greylist-now-restricted">更多非sdk接口<i class="fa fa-external-link"></i></span>的访问，并要求您使用公共接口。为了帮助您进行转换并防止您的应用程序崩溃，我们只在您的应用程序针对Android q时启用这些限制。我们将根据您的请求继续添加公共替代api;如果没有符合您用例的公共API，请让<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0zMjg0MDMmYW1wO3RlbXBsYXRlPTEwMjcyNjc=" title="https://issuetracker.google.com/issues/new?component=328403&amp;template=1027267">我们知道<i class="fa fa-external-link"></i></span>。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZGlzdHJpYnV0ZS9iZXN0LXByYWN0aWNlcy9kZXZlbG9wL3Jlc3RyaWN0aW9ucy1ub24tc2RrLWludGVyZmFjZXMjdGVzdC1mb3Itbm9uLXNkaw==" title="https://developer.android.com/distribute/best-practices/develop/restrictions-non-sdk-interfaces#test-for-non-sdk">测试应用程序<i class="fa fa-external-link"></i></span>是否使用非sdk接口非常重要。我们建议使用StrictMode方法<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvb3MvU3RyaWN0TW9kZS5WbVBvbGljeS5CdWlsZGVyI2RldGVjdE5vblNka0FwaVVzYWdlKA==" title="https://developer.android.com/reference/android/os/StrictMode.VmPolicy.Builder#detectNonSdkApiUsage(">detectNonSdkApiUsage()<i class="fa fa-external-link"></i></span>)在应用程序通过反射或JNI访问非sdk api时发出警告。即使api此时被豁免(灰色列表)，最好还是为将来做好计划，并消除对它们的使用，以减少兼容性问题。有关Android Q中限制的更多细节，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9ub24tc2RrLXE=" title="https://developer.android.com/preview/non-sdk-q">开发人员指南<i class="fa fa-external-link"></i></span>。</p><h2 id="现代化安卓"><a href="#现代化安卓" class="headerlink" title="现代化安卓"></a>现代化安卓</h2><p>我们正在努力让所有应用程序充分利用最新版本Android的安全和性能特性。今年晚些时候，谷歌Play将要求你在新应用和更新中把应用的<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOS8wMi9leHBhbmRpbmctdGFyZ2V0LWFwaS1sZXZlbC1yZXF1aXJlbWVudHMuaHRtbA==" title="https://android-developers.googleblog.com/2019/02/expanding-target-api-level-requirements.html">targetSdkVersion设置为28<i class="fa fa-external-link"></i></span> (Android 9 Pie)。根据这些变化，Android Q将在用户首次运行针对API级别23 (Android Marshmallow)之前的平台的应用程序时，用对话框警告用户。下面是帮助您迁移应用程序的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZGlzdHJpYnV0ZS9iZXN0LXByYWN0aWNlcy9kZXZlbG9wL3RhcmdldC1zZGsuaHRtbA==" title="https://developer.android.com/distribute/best-practices/develop/target-sdk.html">资源清单<i class="fa fa-external-link"></i></span>。</p><p>我们还在推动生态系统为64位设备做好准备。今年晚些时候，谷歌Play将要求<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOS8wMS9nZXQteW91ci1hcHBzLXJlYWR5LWZvci02NC1iaXQuaHRtbA==" title="https://android-developers.googleblog.com/2019/01/get-your-apps-ready-for-64-bit.html">所有应用程序都支持64位<i class="fa fa-external-link"></i></span>。如果您的应用程序使用本地sdk或库，请记住，您需要提供这些sdk或库的64位兼容版本。有关如何准备的详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZGlzdHJpYnV0ZS9iZXN0LXByYWN0aWNlcy9kZXZlbG9wLzY0LWJpdA==" title="https://developer.android.com/distribute/best-practices/develop/64-bit">开发人员指南<i class="fa fa-external-link"></i></span>。</p><h1 id="开始使用Android-Q测试版"><a href="#开始使用Android-Q测试版" class="headerlink" title="开始使用Android Q测试版"></a>开始使用Android Q测试版</h1><p>对于可能影响您的应用程序的重要隐私特性，我们建议您立即开始测试。特别是，您希望启用和测试Android Q存储更改、新位置权限状态、后台应用程序启动的限制和设备标识符的限制。有关详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9wcml2YWN5" title="https://developer.android.com/preview/privacy">隐私文档<i class="fa fa-external-link"></i></span>。</p><p>首先，只需将您当前的应用程序从谷歌Play安装到运行Android Q Beta版的设备或Android<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3J1bi9tYW5hZ2luZy1hdmRzLmh0bWw=" title="https://developer.android.com/studio/run/managing-avds.html">虚拟设备<i class="fa fa-external-link"></i></span>上，并处理用户流。该应用程序应该运行良好，看起来很棒，并正确处理所有应用程序的Android Q<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9iZWhhdmlvci1jaGFuZ2VzLWFsbA==" title="https://developer.android.com/preview/behavior-changes-all">行为变化<i class="fa fa-external-link"></i></span>。如果你发现问题，我们建议你在当前的应用程序中修复它们，而不改变你的目标水平。查看<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9taWdyYXRpb24uaHRtbA==" title="https://developer.android.com/preview/migration.html">迁移指南<i class="fa fa-external-link"></i></span>中的步骤和建议的时间线。</p><h1 id="探索新特性和api"><a href="#探索新特性和api" class="headerlink" title="探索新特性和api"></a>探索新特性和api</h1><p>当你准备好了，深入Android Q，了解你可以在你的应用程序中使用的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcw==" title="https://developer.android.com/preview/features">新功能和api<i class="fa fa-external-link"></i></span>。以<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc2RrL2FwaV9kaWZmL3EtYmV0YTEvY2hhbmdlcy5odG1s" title="https://developer.android.com/sdk/api_diff/q-beta1/changes.html">API diff报告<i class="fa fa-external-link"></i></span>、Android Q Beta <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL3BhY2thZ2VzLmh0bWw=" title="https://developer.android.com/reference/packages.html">API参考<i class="fa fa-external-link"></i></span>和开发人员指南作为起点。另外，在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9pbmRleC5odG1s" title="https://developer.android.com/preview/index.html">Android Q Beta开发人员站点<i class="fa fa-external-link"></i></span>上，您可以找到<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9yZWxlYXNlLW5vdGVzLmh0bWw=" title="https://developer.android.com/preview/release-notes.html">发布说明<i class="fa fa-external-link"></i></span>和报告问题的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWVkYmFjay5odG1s" title="https://developer.android.com/preview/feedback.html">支持资源<i class="fa fa-external-link"></i></span>。</p><p>要使用Android Q进行构建，请下载Android Q Beta SDK和工具到Android Studio 3.3或更高版本中，并按照<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9zZXR1cC1zZGs=" title="https://developer.android.com/preview/setup-sdk">以下<i class="fa fa-external-link"></i></span>说明配置您的环境。如果你想要最新的修复Android Q相关的变化，我们建议你使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3ByZXZpZXcv" title="https://developer.android.com/studio/preview/">Android Studio 3.5<i class="fa fa-external-link"></i></span>或更高版本。</p><h1 id="我如何得到Android-Q测试版"><a href="#我如何得到Android-Q测试版" class="headerlink" title="我如何得到Android Q测试版?"></a>我如何得到Android Q测试版?</h1><p>这很简单——你可以在<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9hbmRyb2lkL2JldGE=" title="https://www.google.com/android/beta">这里注册<i class="fa fa-external-link"></i></span>，在任何像素设备上通过无线方式获得Android Q Beta更新(今年我们支持所有三代Pixel—Pixel3、Pixel2，甚至原始Pixel!)还<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9kb3dubG9hZA==" title="https://developer.android.com/preview/download">可以<i class="fa fa-external-link"></i></span>下载这些设备的系统映像。如果没有Pixel设备，可以使用Android模拟器，并通过Android Studio中的SDK Manager下载最新的模拟器系统镜像。</p><p>我们计划在整个预览过程中定期更新预览系统图像和SDK。随着Beta版程序的推进，我们将有更多的功能可以分享。</p><p>一如既往，你的反馈是至关重要的，所以请<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWVkYmFjay5odG1s" title="https://developer.android.com/preview/feedback.html">让我们知道你的想法<i class="fa fa-external-link"></i></span>——我们越早收到你的反馈，我们就能整合更多的反馈。当您发现问题时，请在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9idWc=" title="https://developer.android.com/preview/bug">这里报告<i class="fa fa-external-link"></i></span>。我们有单独的热门列表来归档<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0xOTA2MDImYW1wO3RlbXBsYXRlPTEyMjY1NzM=" title="https://issuetracker.google.com/issues/new?component=190602&amp;template=1226573">平台问题<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0xOTA2MDImYW1wO3RlbXBsYXRlPTEyMjczNzY=" title="https://issuetracker.google.com/issues/new?component=190602&amp;template=1227376">应用程序兼容性问题<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0xOTA2MDImYW1wO3RlbXBsYXRlPTEyMjc1ODM=" title="https://issuetracker.google.com/issues/new?component=190602&amp;template=1227583">第三方SDK问题<i class="fa fa-external-link"></i></span>。</p><blockquote><p>以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自: &lt;a href=&quot;https://android-developers.googleblog.com/2019/03/introducing-android-q-beta.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introducing Android Q Beta&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/categories/Android/Android-Q/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Q" scheme="https://shoewann0402.github.io/tags/Android-Q/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack WorkManager 稳定发布</title>
    <link href="https://shoewann0402.github.io/2019/03/06/android-jetpack-workmanager-stable/"/>
    <id>https://shoewann0402.github.io/2019/03/06/android-jetpack-workmanager-stable/</id>
    <published>2019-03-06T07:37:35.000Z</published>
    <updated>2019-03-11T09:33:32.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自: <span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOS8wMy9hbmRyb2lkLWpldHBhY2std29ya21hbmFnZXItc3RhYmxlLmh0bWw=" title="https://android-developers.googleblog.com/2019/03/android-jetpack-workmanager-stable.html">Android Jetpack WorkManager Stable Release<i class="fa fa-external-link"></i></span></p></blockquote><a id="more"></a><p><strong>使用WorkManager的方式简化您的后台管理</strong></p><p>今天我们非常高兴的宣布<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS93b3JrbWFuYWdlcg==" title="https://developer.android.com/topic/libraries/architecture/workmanager">Android Jetpack WorkManager<i class="fa fa-external-link"></i></span> 1.0 稳定版发布。我们想感谢许多在我们开发社区的您，一路上为我们给予反馈和bug记录 —— 我们到达了这里，感谢您的帮助！</p><p>当我们通过开发者看到面临的主要问题时，我们看见了做可靠的后台处理和友好的电量管理是一个巨大的挑战。这意味着定期刷新内容或者上传您的日志是复杂的。不同的Android版本为工作提供了不同的工具，它们每一个都有自己怪异的API。比如说，监听网络或者存储可用性以及自动重试您的任务涉及到大量工作。</p><p>我们对于这些挑战的回答是WorkManager。在Google <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1JcktvQkZMd1ROMA==" title="https://www.youtube.com/watch?v=IrKoBFLwTN0">I/O 2018<i class="fa fa-external-link"></i></span>上，我们介绍了Android Jetpack <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS93b3JrbWFuYWdlcg==" title="https://developer.android.com/topic/libraries/architecture/workmanager">WorkManager库<i class="fa fa-external-link"></i></span>的预览,并且从那之后在它上面迭代了额外的功能核和bug修复，感谢您宝贵的意见。</p><p>WorkManager的目标就是为了您操作后台使其简单。WorkManager考虑到了像电量优化、存储或者网络可用性的约束，同事当满足适当的条件它只能运行它的任务。它也知道去重试或者重新调度您的工作——即使您的设备或者app重启了。</p><p>我们相信ＷOrkManager是友好的，亲切的API,能够处理好Android最复杂的部分之一，您可以将焦点放在让您的App独特代码上。</p><h2 id="WorkManager-亮点"><a href="#WorkManager-亮点" class="headerlink" title="ＷorkManager 亮点"></a>ＷorkManager 亮点</h2><p>这里是WorkManager一些关键点：</p><blockquote><ul><li>让您设置约束，比如网络状态或者充电状态、任务在运行时</li><li>支持异步一次性和周期性</li><li>支持带输入和输出的链式任务</li><li>确保任务执行，及时APP或者设备重启</li><li>支持Android 4.0+ (API 14+)</li></ul></blockquote><p>观看和阅读下面去学习在您的APP里面什么时候以及如何使用WorkManager去简化管理后台工作</p><p><img src="/images/android_jetpack_introducing_workmanager.png" alt="android_jetpack_introducing_workmanager"></p><p><span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9wZV95cU0xNmhQUQ==" title="https://youtu.be/pe_yqM16hPQ">Android Jetpack: 介绍WorkManager<i class="fa fa-external-link"></i></span></p><h2 id="何时使用-WorkManager"><a href="#何时使用-WorkManager" class="headerlink" title="何时使用 WorkManager"></a>何时使用 WorkManager</h2><p>WorkManager是针对于能够被延期任务的最佳套件，但是即使是应用程序或者设备重启(比如: 使用后端服务定期同步数据以及上传日志或者分析数据) 也是仍然有望运行</p><p>对于像需要立即运行去发送即时消息或者APP在退出之后不需要立即运行的任务，去看看<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvYmFja2dyb3VuZC8=" title="https://developer.android.com/guide/background/">后台处理向导 <i class="fa fa-external-link"></i></span>了解哪一种解决方案满足您的需求。</p><h2 id="如何使用-WorkManager"><a href="#如何使用-WorkManager" class="headerlink" title="如何使用 WorkManager"></a>如何使用 WorkManager</h2><p>开始使用WorkManager API, 添加在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL2J1aWxkL2RlcGVuZGVuY2llcyNnb29nbGUtbWF2ZW4=" title="https://developer.android.com/studio/build/dependencies#google-maven">Google’s Maven repository<i class="fa fa-external-link"></i></span>上WorkManager可用的Java或者Kotlin依赖到您应用程序的<code>build.gradle</code>文件:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">def</span> work_version = <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java</span></span><br><span class="line">    implementation <span class="string">"android.arch.work:work-runtime:$work_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin KTX + coroutines</span></span><br><span class="line">    implementation <span class="string">"android.arch.work:work-runtime-ktx:$work_version"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>现在，只需要将<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWR4L3dvcmsvV29ya2Vy" title="https://developer.android.com/reference/androidx/work/Worker">Worker<i class="fa fa-external-link"></i></span>子类化并利用<strong>doWork()</strong>实现您的后台工作，并用WorkManager加入列队。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWorker</span></span>(ctx: Context, params: WorkerParameters)</span><br><span class="line">  : Worker(ctx, params) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> WorkerResult <span class="title">doWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//在这里完成一些需要在后台处理的工作</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">return</span> Result.success()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选, 添加像电源、网络可用性的约束</span></span><br><span class="line"><span class="keyword">val</span> constraints: Constraints = Constraints.Builder()</span><br><span class="line">     .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">                .setRequiredNetworkType(NetworkType.CONNECTED)</span><br><span class="line">                .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myWork = OneTimeWorkRequestBuilder&lt;MyWorker&gt;()</span><br><span class="line">                .setConstraints(constraints).build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，列队您的工作</span></span><br><span class="line">WorkManager.getInstance().enqueue(myWork)</span><br></pre></td></tr></table></figure><p>WorkManager当识别到您的设备正在充电且网络是可用时，它将负责运行您的任务。</p><h2 id="为何使用-WorkManager"><a href="#为何使用-WorkManager" class="headerlink" title="为何使用 WorkManager"></a>为何使用 WorkManager</h2><h3 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h3><p>WorkManager将利用正确的调度API:它使用了<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXBwL2pvYi9Kb2JTY2hlZHVsZXI=" title="https://developer.android.com/reference/android/app/job/JobScheduler">JobScheduler API<i class="fa fa-external-link"></i></span>在Android 6.0+ (API 23+)并且结合了之前版本上的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXBwL0FsYXJtTWFuYWdlcg==" title="https://developer.android.com/reference/android/app/AlarmManager">AlarmManager<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvY29udGVudC9Ccm9hZGNhc3RSZWNlaXZlcg==" title="https://developer.android.com/reference/android/content/BroadcastReceiver">BroadcastReceiver<i class="fa fa-external-link"></i></span></p><p>它也力求最佳行为，这样它就符合了在较新的Android API版本中引入系统优化去最大化电量和强制执行良好的APP行为。</p><p>比如说，当系统是进入了Doze 模式时，对于Android 6.0+(API 23+)的设备，WorkManager将在维护窗口期间调度后台工作。</p><h3 id="可靠的调度"><a href="#可靠的调度" class="headerlink" title="可靠的调度"></a>可靠的调度</h3><p>利用WorkManager,您能够简单的添加像网络可用性或者充电状态的约束。当约束满足您的工作将会运行，并且如果在运行的过程中它们失败了将会自动重试。比如说，如果您的任务要求网络可用，当网络不再可用时任务将会停止并且之后重试。</p><p>您也能够使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9saXZlZGF0YQ==" title="https://developer.android.com/topic/libraries/architecture/livedata">LiveData<i class="fa fa-external-link"></i></span>监控工作状态和检索工作结果。当您的任务完成时，这样可以通知您的UI。</p><p>您的工作失败了的情况下，您可用通过配置<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWR4L3dvcmsvQmFja29mZlBvbGljeQ==" title="https://developer.android.com/reference/androidx/work/BackoffPolicy">backoff(退避)<i class="fa fa-external-link"></i></span>的处理方式来控制您的工作重试方式</p><p>WorkManager也能够重新调度您的工作，如果一个应用程序或者设备重启发生了，使用本地数据库记录您的工作。</p><h3 id="控制您的工作方式"><a href="#控制您的工作方式" class="headerlink" title="控制您的工作方式"></a>控制您的工作方式</h3><p>我们明白每一个APP有不同的需求，您的任务也如此——甚至是在同一个APP内。WorkManager提供了简单但高度灵活的API表面，可以帮助您配置您的工作和运行它的方式。</p><p>利用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWR4L3dvcmsvT25lVGltZVdvcmtSZXF1ZXN0Lmh0bWw=" title="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest.html">OneTimeWorkRequest<i class="fa fa-external-link"></i></span>一次性调度或者<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWR4L3dvcmsvUGVyaW9kaWNXb3JrUmVxdWVzdA==" title="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest">PeriodicWorkRequest<i class="fa fa-external-link"></i></span>周期性调度</p><p>您也能够链接您的一次工作请求以按顺序或并行运行。如果任意链接工作失败，WorkManager力求确保剩下的工作链不会运行。阅读更多关于链接工作请求<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS93b3JrbWFuYWdlci9ob3ctdG8vY2hhaW4td29yay5tZA==" title="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/chain-work.md">这里<i class="fa fa-external-link"></i></span></p><p>如果您需要更多灵活性的WorkManager并行化方式以及消息工作，检出我们<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS93b3JrbWFuYWdlci9hZHZhbmNlZC90aHJlYWRpbmcubWQ=" title="https://developer.android.com/topic/libraries/architecture/workmanager/advanced/threading.md">高级线程向导<i class="fa fa-external-link"></i></span></p><h2 id="开发者有说什么"><a href="#开发者有说什么" class="headerlink" title="开发者有说什么"></a>开发者有说什么</h2><p><span class="exturl" data-url="aHR0cHM6Ly9wbGF5Lmdvb2dsZS5jb20vc3RvcmUvYXBwcy9kZXRhaWxzP2lkPWluLnJlZGJ1cy5hbmRyb2lk" title="https://play.google.com/store/apps/details?id=in.redbus.android">redBus<i class="fa fa-external-link"></i></span> ，最大在线巴士票务平台，分享他们使用WorkManager的经验，以简化他们在Android应用中收集用户反馈的方式：</p><blockquote><p><em>“随着我们扩展到其他国家，反馈对于readBus至关重要。一个用户给予了关于在redBus应用程序中功能至关重要的反馈，但是当应用程序尝试去上传反馈到后端，这儿或许没有足够的网络覆盖或者电量</em><br><em>WorkManager简化了redBus应用程序向后端提供信息的方式。WorkManager库处理像网络连接、电量参数的能力以及使用像AlarmManager或者JobScheduler适当的处理程序，使我们能够专注于构建业务逻辑并将执行复杂性卸载到WorkManager</em></p></blockquote><p>   ——  Dinesh Shanmugam</p><p>   Android Lead, redBus.in</p><h2 id="开始使用-WorkManager"><a href="#开始使用-WorkManager" class="headerlink" title="开始使用 WorkManager"></a>开始使用 WorkManager</h2><p>根据您后台任务的需要，检出我们<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS93b3JrbWFuYWdlci9iYXNpY3M=" title="https://developer.android.com/topic/libraries/architecture/workmanager/basics">开始使用向导<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9jb2RlbGFicy5kZXZlbG9wZXJzLmdvb2dsZS5jb20vY29kZWxhYnMvYW5kcm9pZC13b3JrbWFuYWdlci1rdC8jMA==" title="https://codelabs.developers.google.com/codelabs/android-workmanager-kt/#0">codelab<i class="fa fa-external-link"></i></span>动手去使用WorkManager库</p><p>我们欣赏您的反馈，包括您喜欢的新功能以及您希望看到的新功能</p><p>如果您发现了一个bug或者issue,随时<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD00MDk5MDYmYW1wO3RlbXBsYXRlPTEwOTQxOTc=" title="https://issuetracker.google.com/issues/new?component=409906&amp;template=1094197">提出问题<i class="fa fa-external-link"></i></span></p><blockquote><p>以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自: &lt;a href=&quot;https://android-developers.googleblog.com/2019/03/android-jetpack-workmanager-stable.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Jetpack WorkManager Stable Release&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Jetpack" scheme="https://shoewann0402.github.io/categories/Android/Jetpack/"/>
    
      <category term="WorkManager" scheme="https://shoewann0402.github.io/categories/Android/Jetpack/WorkManager/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Jetpack" scheme="https://shoewann0402.github.io/tags/Jetpack/"/>
    
      <category term="WorkManager" scheme="https://shoewann0402.github.io/tags/WorkManager/"/>
    
  </entry>
  
  <entry>
    <title>Android P 默认通过TLS保护用户</title>
    <link href="https://shoewann0402.github.io/2018/04/11/protecting-users-with-tls-by-default-in/"/>
    <id>https://shoewann0402.github.io/2018/04/11/protecting-users-with-tls-by-default-in/</id>
    <published>2018-04-11T14:29:28.000Z</published>
    <updated>2019-03-11T09:33:32.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOC8wNC9wcm90ZWN0aW5nLXVzZXJzLXdpdGgtdGxzLWJ5LWRlZmF1bHQtaW4uaHRtbA==" title="https://android-developers.googleblog.com/2018/04/protecting-users-with-tls-by-default-in.html">Protecting users with TLS by default in Android P<i class="fa fa-external-link"></i></span></p></blockquote><p>Android承诺去保持用户他们的设备和数据安全。保持数据安全之一的方式是,通过保护Android设备在进入或者离开中转传输层安全（TLS）的所有数据。正如我们在Android P开发者预览版中<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOC8wMy9wcmV2aWV3aW5nLWFuZHJvaWQtcC5odG1s" title="https://android-developers.googleblog.com/2018/03/previewing-android-p.html">宣布<i class="fa fa-external-link"></i></span>的那样，我们将进一步改善这些保护，通过阻止目标版本是Android P的应用程序来自默认允许未加密的连接。</p><a id="more"></a><p>这是我们为保护Android用户，多年来做出的各种改变。去阻止偶发的未加密连接，在Android Marshmallow(6.0)中我们介绍了android:usesCleartextTraffic清单属性。在Android Nougat(7.0),我们通过创建<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdHJhaW5pbmcvYXJ0aWNsZXMvc2VjdXJpdHktY29uZmlnLmh0bWw=" title="https://developer.android.com/training/articles/security-config.html">Network Security Config<i class="fa fa-external-link"></i></span>(网络安全配置)功能特性去扩展了这个属性，允许应用程序去表明它们不打算在没有加密的情况下发送网络流量。在Android Nougat(7.0)和Android Oreo(8.0)，我们仍然允许明文连接。</p><h1 id="我怎么更新我的应用程序？"><a href="#我怎么更新我的应用程序？" class="headerlink" title="我怎么更新我的应用程序？"></a>我怎么更新我的应用程序？</h1><p>如果你的应用程序对于所有的连接都使用了TLS，然后你不需要做什么了。如果你还没有，就去使用TLS去加密所有的连接更新你的应用程序。如果你仍然需要去使用明文进行连接,继续去阅读一下最佳做法。</p><h1 id="为什么我应该使用TLS？"><a href="#为什么我应该使用TLS？" class="headerlink" title="为什么我应该使用TLS？"></a>为什么我应该使用TLS？</h1><p>Android考虑到所有的网络可能有敌意，因此加密流量应该在所有时间对于所有的连接都被使用。移动设备尤其面临风险，因为它们经常会连接到许多不同的网络，比如在咖啡店的Wi-Fi</p><p>所有的流量应该被加密，无论内容是什么。作为任意一种未加密的连接能够注入内容被使用，对于那些可能弱势的客户端代码增加攻击面，或者攻击用户。更多信息，看我们过去的<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNi8wNC9wcm90ZWN0aW5nLWFnYWluc3QtdW5pbnRlbnRpb25hbC5odG1s" title="https://android-developers.googleblog.com/2016/04/protecting-against-unintentional.html">博客文章<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1mY1dWVjBIYWZ1ayZhbXA7dD0xcw==" title="https://www.youtube.com/watch?v=fcWVV0Hafuk&amp;t=1s">开发者高峰论坛<i class="fa fa-external-link"></i></span></p><h1 id="TLS是不是很慢？"><a href="#TLS是不是很慢？" class="headerlink" title="TLS是不是很慢？"></a>TLS是不是很慢？</h1><p><span class="exturl" data-url="aHR0cHM6Ly9pc3Rsc2Zhc3R5ZXQuY29tLw==" title="https://istlsfastyet.com/">不，它不是<i class="fa fa-external-link"></i></span></p><h1 id="我如何在我的应用程序中使用TLS"><a href="#我如何在我的应用程序中使用TLS" class="headerlink" title="我如何在我的应用程序中使用TLS ?"></a>我如何在我的应用程序中使用TLS ?</h1><p>只要你的服务器支持TLS, 只需要在你的应用程序和服务器响应中把URLs 从http://改变成https:// 。你的HTTP栈处理TLS握手，无需其他更多操作。</p><p>如果你是自己制作的Socket,使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2phdmF4L25ldC9zc2wvU1NMU29ja2V0RmFjdG9yeS5odG1s" title="https://developer.android.com/reference/javax/net/ssl/SSLSocketFactory.html">SSLSocketFactory<i class="fa fa-external-link"></i></span>去替代<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2phdmF4L25ldC9Tb2NrZXRGYWN0b3J5Lmh0bWw=" title="https://developer.android.com/reference/javax/net/SocketFactory.html">SocketFactory<i class="fa fa-external-link"></i></span><br>要格外小心去正确使用作为SSLSocket的socket，它不会去验证主机。你的应用程序需要做的是它自己的主机验证。优选通过调用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2phdmF4L25ldC9zc2wvSHR0cHNVUkxDb25uZWN0aW9uLmh0bWwjZ2V0RGVmYXVsdEhvc3RuYW1lVmVyaWZpZXIo" title="https://developer.android.com/reference/javax/net/ssl/HttpsURLConnection.html#getDefaultHostnameVerifier(">getDefaultHostnameVerifier()<i class="fa fa-external-link"></i></span>)期望的主机名。进一步，谨防<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2phdmF4L25ldC9zc2wvSG9zdG5hbWVWZXJpZmllci5odG1sI3ZlcmlmeShqYXZhLmxhbmcuU3RyaW5nLCUyMGphdmF4Lm5ldC5zc2wuU1NMU2Vzc2lvbg==" title="https://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html#verify(java.lang.String,%20javax.net.ssl.SSLSession">HostnameVerifier.verify()<i class="fa fa-external-link"></i></span>)在发生异常时不会抛出错误，但是相反的會返回一个boolean的结果，你必须明确的检查。</p><h1 id="我需要去使用一个明文去…"><a href="#我需要去使用一个明文去…" class="headerlink" title="我需要去使用一个明文去…"></a>我需要去使用一个明文去…</h1><p>当你应该对所有连接使用TLS，可能你需要去使用一个明文流量针对于遗留原因。比如连接到一些服务器。因此，改变你的应用程序的网络安全配置，以允许这些连接。</p><p>我们包括了一组示例配置，更多帮助查看<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdHJhaW5pbmcvYXJ0aWNsZXMvc2VjdXJpdHktY29uZmlnLmh0bWw=" title="https://developer.android.com/training/articles/security-config.html">network security config<i class="fa fa-external-link"></i></span>文档。</p><h1 id="允许明文连接到一个具体的域，你可以使用如下的配置作为一个向导："><a href="#允许明文连接到一个具体的域，你可以使用如下的配置作为一个向导：" class="headerlink" title="允许明文连接到一个具体的域，你可以使用如下的配置作为一个向导："></a>允许明文连接到一个具体的域，你可以使用如下的配置作为一个向导：</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">domain-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>insecure.example.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>insecure.cdn.example.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">domain-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="允许连接到任意不安全的域"><a href="#允许连接到任意不安全的域" class="headerlink" title="允许连接到任意不安全的域"></a>允许连接到任意不安全的域</h1><p>如果你的应用程序支持打开任意来自不安全URLs的内容，当支持明文连接到任意主机，你应该禁用明文连接到你自己的服务器。记住，对于这些通过<br>不安全连接接收到的数据你应该谨慎，它能够在传输的过程当中被篡改。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">domain-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>example.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">"true"</span>&gt;</span>cdn.example2.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">domain-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="我应该怎么更新我的库？"><a href="#我应该怎么更新我的库？" class="headerlink" title="我应该怎么更新我的库？"></a>我应该怎么更新我的库？</h1><p>如果你的库是直接创建安全/不安全的连接，确保它在打开任意明文连接之前通过检查<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvc2VjdXJpdHkvTmV0d29ya1NlY3VyaXR5UG9saWN5Lmh0bWwjaXNDbGVhcnRleHRUcmFmZmljUGVybWl0dGVkKGphdmEubGFuZy5TdHJpbmc=" title="https://developer.android.com/reference/android/security/NetworkSecurityPolicy.html#isCleartextTrafficPermitted(java.lang.String">isCleartextTrafficPermitted<i class="fa fa-external-link"></i></span>)来尊重应用程序明文设置。</p><blockquote><p>以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://android-developers.googleblog.com/2018/04/protecting-users-with-tls-by-default-in.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Protecting users with TLS by default in Android P&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android承诺去保持用户他们的设备和数据安全。保持数据安全之一的方式是,通过保护Android设备在进入或者离开中转传输层安全（TLS）的所有数据。正如我们在Android P开发者预览版中&lt;a href=&quot;https://android-developers.googleblog.com/2018/03/previewing-android-p.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;宣布&lt;/a&gt;的那样，我们将进一步改善这些保护，通过阻止目标版本是Android P的应用程序来自默认允许未加密的连接。&lt;/p&gt;
    
    </summary>
    
      <category term="TLS" scheme="https://shoewann0402.github.io/categories/TLS/"/>
    
      <category term="android p" scheme="https://shoewann0402.github.io/categories/TLS/android-p/"/>
    
    
      <category term="android p" scheme="https://shoewann0402.github.io/tags/android-p/"/>
    
      <category term="android security" scheme="https://shoewann0402.github.io/tags/android-security/"/>
    
      <category term="connection encryption" scheme="https://shoewann0402.github.io/tags/connection-encryption/"/>
    
      <category term="HTTPS" scheme="https://shoewann0402.github.io/tags/HTTPS/"/>
    
      <category term="network security" scheme="https://shoewann0402.github.io/tags/network-security/"/>
    
      <category term="TLS" scheme="https://shoewann0402.github.io/tags/TLS/"/>
    
      <category term="TLS by default" scheme="https://shoewann0402.github.io/tags/TLS-by-default/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 切换到D8 dexer</title>
    <link href="https://shoewann0402.github.io/2018/04/07/android-studio-switching-to-d8-dexer/"/>
    <id>https://shoewann0402.github.io/2018/04/07/android-studio-switching-to-d8-dexer/</id>
    <published>2018-04-07T01:58:21.000Z</published>
    <updated>2019-03-11T09:33:32.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxOC8wNC9hbmRyb2lkLXN0dWRpby1zd2l0Y2hpbmctdG8tZDgtZGV4ZXIuaHRtbA==" title="https://android-developers.googleblog.com/2018/04/android-studio-switching-to-d8-dexer.html">Android Studio switching to D8 dexer<i class="fa fa-external-link"></i></span></p></blockquote><a id="more"></a><h1 id="D8现在是默认的dex编译器"><a href="#D8现在是默认的dex编译器" class="headerlink" title="D8现在是默认的dex编译器"></a>D8现在是默认的dex编译器</h1><p>更快、更小的应用程序编译一直是Android工具团队的目标，那也是为什么我们此前宣布了<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8wOC9uZXh0LWdlbmVyYXRpb24tZGV4LWNvbXBpbGVyLW5vdy1pbi5odG1s" title="https://android-developers.googleblog.com/2017/08/next-generation-dex-compiler-now-in.html">D8<i class="fa fa-external-link"></i></span>,下一代的dex编译器。相比历史编译器-DX,D8运行更快并生成更小的.dex文件具有相当或者更佳的运行时性能。</p><p>我们最近宣布了D8成为Android Studio 3.1中默认的编译器。如果你之前还没有去尝试D8，我们希望你在切换的时候注意到更佳、更快的dex编译。</p><p>D8首次在Android Studio3.0中作为一个可选的功能被发出。除此之外我们自己也在严格测试，我们现在已经看到了它在各种各样的应用程序中良好的表现。最后，我们确信D8对于每一个开始在3.1中使用他的人来说都将良好运作。然而，如果你在使用的时候有什么问题，你现在能够通过在你的项目gradle.properties文件下一直设置如下还原到DX</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.enableD8=<span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>如果你确实遇到什么问题导致你禁用了D8，请<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0xOTI3MDgmYW1wO3RlbXBsYXRlPTg0MDUzMw==" title="https://issuetracker.google.com/issues/new?component=192708&amp;template=840533">让我们知道!<i class="fa fa-external-link"></i></span></p><h1 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h1><p>我们的目标是确保每一个人都能访问到快速、正确的dex编译器。因此避免冒着任一個用户的回归，我们将分为3个阶段去弃用DX</p><p>第一阶段打算防止过早的弃用DX。在这个阶段期间，DX将仍然可以在studio中使用。我们将修复它的关键性问题，但是不会再有新的功能特性了。这个阶段将会持续至少6个月，期间我们将打开任何一个D8的错误去决定如果是回归，将会阻止一些用户使用D8替换DX。第一个阶段直到团队解决完全部的迁移阻滞者问题才会结束。在这个窗口中我们将会特别注意到错误追踪器，因此如果你遭遇任何回归，<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvbmV3P2NvbXBvbmVudD0xOTI3MDgmYW1wO3RlbXBsYXRlPTg0MDUzMw==" title="https://issuetracker.google.com/issues/new?component=192708&amp;template=840533">请提出问题<i class="fa fa-external-link"></i></span>。</p><p>一旦我们将查看6个月的窗口没有了D8替换DX的主要回归问题，我们将进入第二阶段。这个阶段将会至少是一年，打算确保那些即使是复杂的项目都有大量时间去进行迁移。在这个阶段期间，我们仍然保持着DX可用，但是我们将它视为完全弃用，我们将不会修复它的任何问题。</p><p>再第三阶段也就是最后阶段，DX将会从Android Studio中移除。在此时，为了能继续使用DX去构建，你将需要使用一个legacy版本的Android Gradle插件。</p><blockquote><p>以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://android-developers.googleblog.com/2018/04/android-studio-switching-to-d8-dexer.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Studio switching to D8 dexer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Dex" scheme="https://shoewann0402.github.io/categories/Dex/"/>
    
      <category term="Android Studio" scheme="https://shoewann0402.github.io/categories/Dex/Android-Studio/"/>
    
    
      <category term="Android Studio" scheme="https://shoewann0402.github.io/tags/Android-Studio/"/>
    
      <category term="Dex" scheme="https://shoewann0402.github.io/tags/Dex/"/>
    
  </entry>
  
  <entry>
    <title>关于Android O 通知渠道总结</title>
    <link href="https://shoewann0402.github.io/2018/01/08/about-android-o-notification-channels/"/>
    <id>https://shoewann0402.github.io/2018/01/08/about-android-o-notification-channels/</id>
    <published>2018-01-08T02:56:22.000Z</published>
    <updated>2019-03-11T09:33:32.626Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于针对Android O 通知渠道的总结。 </p></blockquote><a id="more"></a><p>Android O 引入了通知渠道<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vZ3VpZGUvdG9waWNzL3VpL25vdGlmaWVycy9ub3RpZmljYXRpb25zLmh0bWwjTWFuYWdlQ2hhbm5lbHM=" title="https://developer.android.google.cn/guide/topics/ui/notifiers/notifications.html#ManageChannels">Notification Channels<i class="fa fa-external-link"></i></span>，更好的方便用户管理通知栏消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NotificationChannel</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationChannel</span> </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line"><span class="class">   ↳<span class="title">android</span>.<span class="title">app</span>.<span class="title">NotificationChannel</span></span></span><br></pre></td></tr></table></figure><p>距离上一次总结通知栏相关的东西好像有很久了，可以去<span class="exturl" data-url="aHR0cDovL3Nob2V3YW5uLnRvcC8yMDE2LzA1LzEyL0FuZHJvaWQtTm90aWZpY2F0aW9uLSVFOSU4MCU5QSVFNyU5RiVBNSVFNiVBMCVCNyVFNSVCQyU4RiVFNiU4MCVCQiVFNyVCQiU5My8=" title="http://shoewann.top/2016/05/12/Android-Notification-%E9%80%9A%E7%9F%A5%E6%A0%B7%E5%BC%8F%E6%80%BB%E7%BB%93/">这里查看<i class="fa fa-external-link"></i></span></p><p>今天我们从一个基本的通知示例开始，来总结下Android O 通知渠道相关的使用。</p><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建通知栏管理对象</span></span><br><span class="line">NotificationManager mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line"><span class="comment">//为了版本兼容  选择V7包下的NotificationCompat进行构造</span></span><br><span class="line">NotificationCompat.Builder builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//setTicker 在5.0以上不显示Ticker属性信息</span></span><br><span class="line">builder.setTicker(<span class="string">"状态栏显示的提示"</span>);;</span><br><span class="line"><span class="comment">//setContentTitle 通知栏通知的标题</span></span><br><span class="line">builder.setContentTitle(<span class="string">"内容标题"</span>);</span><br><span class="line"><span class="comment">//setContentText  通知栏通知的详细内容</span></span><br><span class="line">builder.setContentText(<span class="string">"内容文本信息"</span>);</span><br><span class="line"><span class="comment">//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）</span></span><br><span class="line">builder.setAutoCancel(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//setLargeIcon  通知消息上的大图标</span></span><br><span class="line">builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));</span><br><span class="line"><span class="comment">//setSmallIcon  通知上面的小图标</span></span><br><span class="line">builder.setSmallIcon(R.mipmap.ic_launcher);<span class="comment">//小图标</span></span><br><span class="line"><span class="comment">//创建一个意图</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"https://www.baidu.com"</span>));</span><br><span class="line">PendingIntent pIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">1</span>, intent, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//setContentIntent  将意图设置到通知上</span></span><br><span class="line">builder.setContentIntent(pIntent);</span><br><span class="line"><span class="comment">//通知默认的声音 震动 呼吸灯</span></span><br><span class="line">builder.setDefaults(NotificationCompat.DEFAULT_ALL);</span><br><span class="line"><span class="comment">//构建通知</span></span><br><span class="line">Notification notification = builder.build();</span><br><span class="line"><span class="comment">//将构建好的通知添加到通知管理器中，执行通知</span></span><br><span class="line">mNotificationManager.notify(<span class="number">0</span>, notification);</span><br></pre></td></tr></table></figure><p>这段代码很简单，已经添加了注释，没有什么可以说的。</p><h2 id="差异复现"><a href="#差异复现" class="headerlink" title="差异复现"></a>差异复现</h2><h3 id="SDK-lt-8-0-API-26"><a href="#SDK-lt-8-0-API-26" class="headerlink" title="SDK &lt; 8.0(API 26)"></a>SDK &lt; 8.0(API 26)</h3><p>这种情况，上面的示例代码是能无障碍的将通知消息显示出来。</p><h3 id="SDK-gt-8-0-API-26"><a href="#SDK-gt-8-0-API-26" class="headerlink" title="SDK &gt; = 8.0(API 26)"></a>SDK &gt; = 8.0(API 26)</h3><p>这种情况，上面的示例代码，是死活都不会把通知消息显示出来的。</p><p>在Android Oreo上的开发者选项中，新增加了一个<strong>show notification channel warnings</strong>的选项功能，可以通过<strong>Settings</strong> &gt; <strong>System</strong> &gt; <strong>Developer options</strong> 下找到开启。</p><p>再次运行代码后，界面上会弹出类似于下面的这样一个<strong>Toast</strong>,告知你的通知消息post失败，详细情况查看log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Developer warning for package &quot;com.shoewann.notificationsimple&quot; </span><br><span class="line">Failed to post notification on channel &quot;null&quot; </span><br><span class="line">See log for more details</span><br></pre></td></tr></table></figure><p>查看log是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E/NotificationService: No Channel found for pkg=com.shoewann.notificationsimple, channelId=null, id=0, tag=null, opPkg=com.shoewann.notificationsimple, callingUid=10083, userId=0, incomingUserId=0, notificationUid=10083, notification=Notification(channel=null pri=0 contentView=null vibrate=default sound=default tick defaults=0xffffffff flags=0x11 color=0x00000000 vis=PRIVATE)</span><br></pre></td></tr></table></figure><p>通过跟踪查看相关源代码，分析到了，在NotificationCompat这个类中的Builder方法。</p><p>在版本<strong>com.android.support:appcompat-v7:26.1.0</strong>的兼容库中，可以看到传一个参数的<strong>Builder(Context context)</strong>方法已经过期，使用传入两个参数的<strong>Builder(@NonNull Context context, @NonNull String channelId)</strong>新方法代替。</p><p><strong>注意</strong>：该新方法需要传入的这两个参数都是标注了<strong>@NonNull</strong>，也就是<strong>不能传入null</strong>或者<strong>未初始化的变量</strong>。</p><h2 id="兼容代码"><a href="#兼容代码" class="headerlink" title="兼容代码"></a>兼容代码</h2><p>通过以上的分析，也就是我们在Android Oreo上面使用Notification，就必须要为你的Notification创建一个Notification Channels(通知渠道)。</p><h3 id="创建通知渠道"><a href="#创建通知渠道" class="headerlink" title="创建通知渠道"></a>创建通知渠道</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">NotificationCompat.Builder builder = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    NotificationChannel channel = <span class="keyword">new</span> NotificationChannel(<span class="string">"通知渠道ID"</span>,</span><br><span class="line">                    <span class="string">"通知渠道名称"</span>, NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class="line">    channel.enableLights(<span class="keyword">true</span>); <span class="comment">//设置开启指示灯，如果设备有的话</span></span><br><span class="line">    channel.setLightColor(Color.RED); <span class="comment">//设置指示灯颜色</span></span><br><span class="line">    channel.setShowBadge(<span class="keyword">true</span>); <span class="comment">//设置是否显示角标</span></span><br><span class="line">    channel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE);<span class="comment">//设置是否应在锁定屏幕上显示此频道的通知</span></span><br><span class="line">    channel.setDescription(<span class="string">"通知渠道描述"</span>);<span class="comment">//设置渠道描述</span></span><br><span class="line">    channel.setVibrationPattern(<span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">600</span>&#125;);<span class="comment">//设置震动频率</span></span><br><span class="line">    channel.setBypassDnd(<span class="keyword">true</span>);<span class="comment">//设置是否绕过免打扰模式</span></span><br><span class="line">    mNotificationManager.createNotificationChannel(channel);</span><br><span class="line">    createNotificationChannelGroups();</span><br><span class="line">    setNotificationChannelGroups(channel);</span><br><span class="line">    builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>, <span class="string">"通知渠道ID"</span>);</span><br><span class="line">    builder.setBadgeIconType(BADGE_ICON_SMALL);<span class="comment">//设置显示角标的样式</span></span><br><span class="line">    builder.setNumber(<span class="number">3</span>);<span class="comment">//设置显示角标的数量</span></span><br><span class="line">    builder.setTimeoutAfter(<span class="number">5000</span>);<span class="comment">//设置通知被创建多长时间之后自动取消通知栏的通知。</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//setContentTitle 通知栏通知的标题</span></span><br><span class="line">builder.setContentTitle(<span class="string">"内容标题"</span>);</span><br><span class="line"><span class="comment">//setContentText  通知栏通知的详细内容</span></span><br><span class="line">builder.setContentText(<span class="string">"内容文本信息"</span>);</span><br><span class="line"><span class="comment">//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）</span></span><br><span class="line">builder.setAutoCancel(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//setLargeIcon  通知消息上的大图标</span></span><br><span class="line">builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));</span><br><span class="line"><span class="comment">//setSmallIcon  通知上面的小图标</span></span><br><span class="line">builder.setSmallIcon(R.mipmap.ic_launcher);<span class="comment">//小图标</span></span><br><span class="line"><span class="comment">//创建一个意图</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"https://www.baidu.com"</span>));</span><br><span class="line">PendingIntent pIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">1</span>, intent, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//setContentIntent  将意图设置到通知上</span></span><br><span class="line">builder.setContentIntent(pIntent);</span><br><span class="line"><span class="comment">//通知默认的声音 震动 呼吸灯</span></span><br><span class="line">builder.setDefaults(NotificationCompat.DEFAULT_ALL);</span><br><span class="line"><span class="comment">//构建通知</span></span><br><span class="line">Notification notification = builder.build();</span><br><span class="line"><span class="comment">//将构建好的通知添加到通知管理器中，执行通知</span></span><br><span class="line">mNotificationManager.notify(<span class="number">0</span>, notification);</span><br></pre></td></tr></table></figure><p>效果图:</p><p><img src="/images/android-o-notification-channel-1.png" alt="android-o-notification-channel-1"></p><p>向右滑动通知消息，可以显示延迟本条消息显示和设置选项</p><p><img src="/images/android-o-notification-channel-2.png" alt="android-o-notification-channel-2"></p><p>点击左边的延迟本条消息显示的时间</p><p><img src="/images/android-o-notification-channel-3.png" alt="android-o-notification-channel-3"></p><p>点击右边的设置选项，可以显示进入操作通知的设置入口</p><p><img src="/images/android-o-notification-channel-4.png" alt="android-o-notification-channel-4"></p><p>在桌面上的快捷方式上会显示角标</p><p><img src="/images/android-o-notification-channel-6.png" alt="android-o-notification-channel-6"></p><p>长按快捷方式，会在快捷方式旁边弹出通知栏窗口，显示通知栏消息等信息。</p><p><img src="/images/android-o-notification-channel-7.png" alt="android-o-notification-channel-7"></p><h3 id="移除通知渠道"><a href="#移除通知渠道" class="headerlink" title="移除通知渠道"></a>移除通知渠道</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    mNotificationManager.deleteNotificationChannel(<span class="string">"通知渠道ID"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳转到通知渠道设置"><a href="#跳转到通知渠道设置" class="headerlink" title="跳转到通知渠道设置"></a>跳转到通知渠道设置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);</span><br><span class="line">    intent.putExtra(Settings.EXTRA_CHANNEL_ID, <span class="string">"通知渠道ID"</span>);</span><br><span class="line">    intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName());</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/android-o-notification-channel-5.png" alt="android-o-notification-channel-5"></p><h3 id="创建通知渠道组"><a href="#创建通知渠道组" class="headerlink" title="创建通知渠道组"></a>创建通知渠道组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    mNotificationManager.createNotificationChannelGroup(<span class="keyword">new</span> NotificationChannelGroup(<span class="string">"通知渠道组ID"</span>, <span class="string">"通知渠道组名称"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定通知渠道组"><a href="#绑定通知渠道组" class="headerlink" title="绑定通知渠道组"></a>绑定通知渠道组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">    channel.setGroup(<span class="string">"通知渠道组ID"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文只是简要的总结了通知渠道的基本用法，还有更多的使用方法，请参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvYXBwL05vdGlmaWNhdGlvbkNoYW5uZWwuaHRtbA==" title="https://developer.android.google.cn/reference/android/app/NotificationChannel.html">Android官方文档-NotificationChannel<i class="fa fa-external-link"></i></span>。关于本文如有不足之处，欢迎指正，谢谢。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是关于针对Android O 通知渠道的总结。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Notification" scheme="https://shoewann0402.github.io/categories/Android/Notification/"/>
    
    
      <category term="Notification Channels" scheme="https://shoewann0402.github.io/tags/Notification-Channels/"/>
    
      <category term="Android O" scheme="https://shoewann0402.github.io/tags/Android-O/"/>
    
      <category term="通知渠道" scheme="https://shoewann0402.github.io/tags/%E9%80%9A%E7%9F%A5%E6%B8%A0%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>关于Android WindowManager行为变化</title>
    <link href="https://shoewann0402.github.io/2018/01/01/about-android-windowmanager-behavior-changes/"/>
    <id>https://shoewann0402.github.io/2018/01/01/about-android-windowmanager-behavior-changes/</id>
    <published>2018-01-01T04:25:14.000Z</published>
    <updated>2019-03-11T09:33:32.630Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于针对Android WindowManager悬浮窗行为变化的总结。</p></blockquote><a id="more"></a><h2 id="官方参考"><a href="#官方参考" class="headerlink" title="官方参考"></a>官方参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLmh0bWw=" title="https://developer.android.google.cn/reference/android/view/WindowManager.html"><strong>WindowManager</strong><i class="fa fa-external-link"></i></span><br>public interface WindowManager<br>implements ViewManager</p><p>android.view.WindowManager</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>首先创建一个简单的WindowManager悬浮窗，具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoewann.windowmanager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.PixelFormat;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.Gravity;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.shoewann.windowmanager.view.FloatView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        (findViewById(R.id.btn_show)).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                setUpFloatView();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpFloatView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WindowManager windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);</span><br><span class="line">        FloatView floatView = <span class="keyword">new</span> FloatView(getApplicationContext());</span><br><span class="line">        WindowManager.LayoutParams params = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">        params.type = WindowManager.LayoutParams.TYPE_PHONE;</span><br><span class="line">        params.format = PixelFormat.RGBA_8888;</span><br><span class="line">        params.gravity = Gravity.START | Gravity.TOP;</span><br><span class="line">        params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;</span><br><span class="line">        params.width = <span class="number">200</span>;</span><br><span class="line">        params.height = <span class="number">200</span>;</span><br><span class="line">        params.x = <span class="number">0</span>;</span><br><span class="line">        params.y = <span class="number">0</span>;</span><br><span class="line">        floatView.setImageResource(R.mipmap.ic_launcher_round);</span><br><span class="line">        windowManager.addView(floatView, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码简单易懂，这里就不再进行解释了。</p><p>最后不要忘记了，在AndroidManifest.xml添加所需要的权限。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SYSTEM_ALERT_WINDOW"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="行为变化"><a href="#行为变化" class="headerlink" title="行为变化"></a>行为变化</h2><h3 id="SDK-lt-Android-M"><a href="#SDK-lt-Android-M" class="headerlink" title="SDK &lt; Android M"></a>SDK &lt; Android M</h3><p>以上的示例代码，在这种情况下(比如Kitkat 4.4)的设备上现在就已经可以成功创建出一个系统悬浮窗了。</p><p>运行，效果图如下</p><p><img src="/images/windowmanager-k.png" alt="windowmanager-k"></p><h3 id="SDK-gt-Android-M"><a href="#SDK-gt-Android-M" class="headerlink" title="SDK &gt;= Android M"></a>SDK &gt;= Android M</h3><p>到了Android M 之后的设备，也就是targetSdkVersion要指定23(及其以上)，程序就会崩溃，抛出如下异常信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">                  Process: com.shoewann.windowmanager, PID: 3120</span><br><span class="line">                  android.view.WindowManager$BadTokenException: Unable to add window android.view.ViewRootImpl$W@c1fda7 -- permission denied for this window type</span><br><span class="line">                      at android.view.ViewRootImpl.setView(ViewRootImpl.java:591)</span><br><span class="line">                      at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:310)</span><br><span class="line">                      at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:85)</span><br><span class="line">                      at com.shoewann.windowmanager.MainActivity.setUpFloatView(MainActivity.java:39)</span><br><span class="line">                      at com.shoewann.windowmanager.MainActivity$1.onClick(MainActivity.java:21)</span><br><span class="line">                      at android.view.View.performClick(View.java:5198)</span><br><span class="line">                      at android.view.View$PerformClick.run(View.java:21147)</span><br><span class="line">                      at android.os.Handler.handleCallback(Handler.java:739)</span><br><span class="line">                      at android.os.Handler.dispatchMessage(Handler.java:95)</span><br><span class="line">                      at android.os.Looper.loop(Looper.java:148)</span><br><span class="line">                      at android.app.ActivityThread.main(ActivityThread.java:5417)</span><br><span class="line">                      at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">                      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)</span><br><span class="line">                      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)</span><br></pre></td></tr></table></figure><p><strong>参考</strong>:<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvTWFuaWZlc3QucGVybWlzc2lvbi5odG1sI1dSSVRFX1NFVFRJTkdT" title="https://developer.android.google.cn/reference/android/Manifest.permission.html#WRITE_SETTINGS">SYSTEM_ALERT_WINDOW<i class="fa fa-external-link"></i></span></p><blockquote><p>Note: If the app targets API level 23 or higher, the app user must explicitly grant this permission to the app through a permission management screen. The app requests the user’s approval by sending an intent with action ACTION_MANAGE_OVERLAY_PERMISSION. The app can check whether it has this authorization by calling Settings.canDrawOverlays().</p></blockquote><p>官方的解释是，如果你的应用程序目标API等级为23或者更高版本，在使用SYSTEM_ALERT_WINDOW权限时，需要先调用Settings.canDrawOverlays()来判断一下是否允许创建悬浮窗，如果允许的话就可以创建了，不允许的话还要发送一个action值为ACTION_MANAGE_OVERLAY_PERMISSION的Intent来让用户同意创建悬浮窗。</p><p>针对该行为变化，对上面的示例代码进行了修改,添加<strong>权限请求</strong>，以兼容Android M：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoewann.windowmanager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.graphics.PixelFormat;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.provider.Settings;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.Gravity;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.shoewann.windowmanager.view.FloatView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        (findViewById(R.id.btn_show)).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!commonROMPermissionCheck(MainActivity.<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    requestAlertWindowPermission();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setUpFloatView();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpFloatView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"setUpFloatView() called"</span>);</span><br><span class="line">        WindowManager windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);</span><br><span class="line">        FloatView floatView = <span class="keyword">new</span> FloatView(getApplicationContext());</span><br><span class="line">        WindowManager.LayoutParams params = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">        params.type = WindowManager.LayoutParams.TYPE_PHONE;</span><br><span class="line">        params.format = PixelFormat.RGBA_8888;</span><br><span class="line">        params.gravity = Gravity.START | Gravity.TOP;</span><br><span class="line">        params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;</span><br><span class="line">        params.width = <span class="number">200</span>;</span><br><span class="line">        params.height = <span class="number">200</span>;</span><br><span class="line">        params.x = <span class="number">0</span>;</span><br><span class="line">        params.y = <span class="number">0</span>;</span><br><span class="line">        floatView.setImageResource(R.mipmap.ic_launcher_round);</span><br><span class="line">        windowManager.addView(floatView, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_CODE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断权限</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">commonROMPermissionCheck</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"commonROMPermissionCheck() called with: context = ["</span> + context + <span class="string">"]"</span>);</span><br><span class="line">        Boolean result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class clazz = Settings.class;</span><br><span class="line">                Method canDrawOverlays = clazz.getDeclaredMethod(<span class="string">"canDrawOverlays"</span>, Context.class);</span><br><span class="line">                result = (Boolean) canDrawOverlays.invoke(<span class="keyword">null</span>, context);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(TAG, Log.getStackTraceString(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请权限</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestAlertWindowPermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"requestAlertWindowPermission() called"</span>);</span><br><span class="line">        <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</span><br><span class="line">            intent.setData(Uri.parse(<span class="string">"package:"</span> + getPackageName()));</span><br><span class="line">            startActivityForResult(intent, REQUEST_CODE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//处理回调</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Settings.canDrawOverlays(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"onActivityResult granted"</span>);</span><br><span class="line">                    setUpFloatView();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"onActivityResult denied"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行,效果图如下</p><p><img src="/images/windowmanager-m.png" alt="windowmanager-m"></p><h4 id="SDK-gt-Android-O"><a href="#SDK-gt-Android-O" class="headerlink" title="SDK &gt;= Android O"></a>SDK &gt;= Android O</h4><p>到了Android O 的设备运行上面在M上二次修改的动态请求权限的代码，程序抛出运行时异常，随后崩溃，这又是为什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">                  Process: com.shoewann.windowmanager, PID: 17929</span><br><span class="line">                  android.view.WindowManager$BadTokenException: Unable to add window android.view.ViewRootImpl$W@d422e7c -- permission denied for window type 2002</span><br><span class="line">                      at android.view.ViewRootImpl.setView(ViewRootImpl.java:789)</span><br><span class="line">                      at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:356)</span><br><span class="line">                      at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:93)</span><br><span class="line">                      at com.shoewann.windowmanager.MainActivity.setUpFloatView(MainActivity.java:54)</span><br><span class="line">                      at com.shoewann.windowmanager.MainActivity$1.onClick(MainActivity.java:34)</span><br><span class="line">                      at android.view.View.performClick(View.java:6294)</span><br><span class="line">                      at android.view.View$PerformClick.run(View.java:24770)</span><br><span class="line">                      at android.os.Handler.handleCallback(Handler.java:790)</span><br><span class="line">                      at android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class="line">                      at android.os.Looper.loop(Looper.java:164)</span><br><span class="line">                      at android.app.ActivityThread.main(ActivityThread.java:6494)</span><br><span class="line">                      at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">                      at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)</span><br><span class="line">                      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)</span><br></pre></td></tr></table></figure><p>查阅Android Oreo官方文档，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vYWJvdXQvdmVyc2lvbnMvb3Jlby9hbmRyb2lkLTguMC1jaGFuZ2VzLmh0bWwjY3d0" title="https://developer.android.google.cn/about/versions/oreo/android-8.0-changes.html#cwt">Alert windows行为变化<i class="fa fa-external-link"></i></span></p><p>应用程序使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvTWFuaWZlc3QucGVybWlzc2lvbi5odG1sI1NZU1RFTV9BTEVSVF9XSU5ET1c=" title="https://developer.android.google.cn/reference/android/Manifest.permission.html#SYSTEM_ALERT_WINDOW">SYSTEM_ALERT_WINDOW<i class="fa fa-external-link"></i></span>权限时，不再支持如下窗口类型在其他应用和系统窗口之上显示警告窗口了：</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfUEhPTkU=" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_PHONE">TYPE_PHONE<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfUFJJT1JJVFlfUEhPTkU=" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_PRIORITY_PHONE">TYPE_PRIORITY_PHONE<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfU1lTVEVNX0FMRVJU" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_SYSTEM_ALERT">TYPE_SYSTEM_ALERT<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfU1lTVEVNX09WRVJMQVk=" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_SYSTEM_OVERLAY">TYPE_SYSTEM_OVERLAY<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfU1lTVEVNX0VSUk9S" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_SYSTEM_ERROR">TYPE_SYSTEM_ERROR<i class="fa fa-external-link"></i></span></li></ul></blockquote><p>应用必须使用一个被叫做<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfQVBQTElDQVRJT05fT1ZFUkxBWQ==" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_APPLICATION_OVERLAY">TYPE_APPLICATION_OVERLAY<i class="fa fa-external-link"></i></span>类型的新窗口类型替代。</p><p>当使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfQVBQTElDQVRJT05fT1ZFUkxBWQ==" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_APPLICATION_OVERLAY">TYPE_APPLICATION_OVERLAY<i class="fa fa-external-link"></i></span>类型的窗口为你的应用程序去显示警告窗口，请记住新窗口的如下特征：</p><blockquote><ul><li>一个应用程序的警告窗口总是显示在系统窗口之下，比如状态栏和输入法。</li><li>系统能够移除和重置窗口大小，使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfQVBQTElDQVRJT05fT1ZFUkxBWQ==" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_APPLICATION_OVERLAY">TYPE_APPLICATION_OVERLAY<i class="fa fa-external-link"></i></span>类型的窗口去提高屏幕演示</li><li>通过打开通知栏窗帘，用户能够访问设置去屏蔽一个应用通过<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vcmVmZXJlbmNlL2FuZHJvaWQvdmlldy9XaW5kb3dNYW5hZ2VyLkxheW91dFBhcmFtcy5odG1sI1RZUEVfQVBQTElDQVRJT05fT1ZFUkxBWQ==" title="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams.html#TYPE_APPLICATION_OVERLAY">TYPE_APPLICATION_OVERLAY<i class="fa fa-external-link"></i></span>窗口类型去显示警告窗口的显示</li></ul></blockquote><p>针对该行为变化，对上面的示例代码进行了修改，以兼容Android O：</p><p>更改<strong>TYPE_PHONE</strong>为<strong>TYPE_APPLICATION_OVERLAY</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-  params.type = WindowManager.LayoutParams.TYPE_PHONE;</span><br><span class="line">+  params.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;</span><br></pre></td></tr></table></figure><p>运行,效果图如下</p><p><img src="/images/windowmanager-o.png" alt="windowmanager-o"></p><blockquote><p>以上就是简单的对Android WindowManager悬浮窗行为变化的简单总结。如有不足，欢迎指正，谢谢。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是关于针对Android WindowManager悬浮窗行为变化的总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="WindowManager" scheme="https://shoewann0402.github.io/categories/Android/WindowManager/"/>
    
    
      <category term="Android O" scheme="https://shoewann0402.github.io/tags/Android-O/"/>
    
      <category term="WindowManager" scheme="https://shoewann0402.github.io/tags/WindowManager/"/>
    
      <category term="Android M" scheme="https://shoewann0402.github.io/tags/Android-M/"/>
    
  </entry>
  
  <entry>
    <title>Android 模拟器快速启动和主要功能</title>
    <link href="https://shoewann0402.github.io/2017/12/19/quick-boot-top-features-in-android/"/>
    <id>https://shoewann0402.github.io/2017/12/19/quick-boot-top-features-in-android/</id>
    <published>2017-12-19T03:13:19.000Z</published>
    <updated>2019-03-11T09:33:32.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8xMi9xdWljay1ib290LXRvcC1mZWF0dXJlcy1pbi1hbmRyb2lkLmh0bWw=" title="https://android-developers.googleblog.com/2017/12/quick-boot-top-features-in-android.html">Quick Boot &amp; the Top Features in the Android Emulator<i class="fa fa-external-link"></i></span></p></blockquote><p>今天我们很高兴的宣布Android模拟器快速启动。使用快速启动，您能在6秒内启动模拟器。快速启动通过快照模拟器会话来工作，因此您能够在几秒钟内重新加载。快速启动是在Android Studio 3.0 canary更新通道首次发布，我们很高兴的的在今天的更新中将这一个功能作为稳定版本发布。</p><a id="more"></a><p>除了这个新功能以外，我们也想突出显示最近发布的一些主要功能，自从<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNS8xMi9hbmRyb2lkLXN0dWRpby0yMC1wcmV2aWV3LWFuZHJvaWQuaHRtbA==" title="https://android-developers.googleblog.com/2015/12/android-studio-20-preview-android.html">两年前<i class="fa fa-external-link"></i></span>对Android模拟器进行了改造，我们继续将焦点放在改善速度、兼容性和添加一些丰富的功能，加速您的应用程序开发和测试。随着最近所有的变化，今天绝对值得去更新Android模拟器到最新版并使用它。</p><h2 id="主要的5个功能"><a href="#主要的5个功能" class="headerlink" title="主要的5个功能"></a>主要的5个功能</h2><blockquote><ul><li><strong>快速启动</strong> —— 今天作为一个稳定功能发布，快速启动允许您在6秒之内恢复您的Android模拟器会话。首次您开始启动Android模拟器的Android虚拟设备，它必须执行冷启动(就像启动设备一样)，但是随后的启动速度很快，系统将会恢复在您最后关闭模拟器时的状态(像唤醒设备一样)。我们通过完全重新设计旧式仿真器快照架构，使用虚拟传感器和GPU加速工作来完成了这个。无需额外的请求，因为快速启动在Android模拟器v27.0.2版本上是默认开启的。</li></ul></blockquote><p><img src="/images/image2.gif" alt="image2.gif"></p><blockquote><ul><li><strong>Android CTS 兼容性</strong> —— 每发布一个版本的Android SDK，我们都将确保Android模拟器已经为您的应用程序做好了需要的开发准备，从测试向后兼容的Android KitKat到集成了最新APIs的开发者预览版。对于增加模拟器系统镜像产品的质量和可靠性，我们现在从Android Nougat (API 24) 或者更高的对<span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vY29tcGF0aWJpbGl0eS8=" title="https://source.android.com/compatibility/">Android 兼容性的测试套件<i class="fa fa-external-link"></i></span>(CTS)构建有资格的最终版Android系统镜像 — 相同的测试套件官方Android物理设备必须通过。</li></ul></blockquote><blockquote><ul><li><strong>Google Play支持</strong> —— 我们知道大多数的应用程序开发者使用Google play 服务，在Android模拟器系统镜像上是很难保持服务的最新。为了解决这个问题，我们现在提供的Android系统镜像包括了Play商店的应用程序。Google Play 服务现开始从Android Nougat (API 24)可以使用了。这些新的模拟器镜像，您可以从您模拟器里面的Play 应用商店里面更新Google Play服务，正如您会在物理设备上操作的一样。还有就是，您现在能够使用Google Play应用商店测试结束到结束安装、更新和购买流程。</li></ul></blockquote><blockquote><ul><li><strong>性能提高</strong> —— 使模拟器更快速以及性能是我们团队正在进行的一个目标。我们持续的观察运行在您的开发机器上的模拟器对性能的影响，尤其是内存使用情况。使用最新版的Android模拟器，我们现在按需求分配RAM(内存)，而不是在您的AVD中定义最大的内存大小去分配和固定内存。对于Linux (KVM) 、macOS® (Hypervisor.内核)我们通过挖掘本地虚拟管理程序来实现这个，以及对Microsoft® Windows®增强Intel® HAXM (v6.2.1 或者更高版本)，它使用新的按需要分配内存。</li></ul></blockquote><p>额外的还有，再过去的几个版本中，我们有改善CPU和I/O性能，同时增强了GPU的性能，包括了对OpenGL ES 3.0的支持。看一下像ADB推送这样常见的任务，突出了Android CPU和I/O管道的改进：</p><p><img src="/images/image5.png" alt="image5.png"></p><p>对于GPU性能，我们创建了一个简单的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9ncHUtZW11bGF0aW9uLXN0cmVzcy10ZXN0" title="https://github.com/google/gpu-emulation-stress-test">GPU仿真压力测试应用程序<i class="fa fa-external-link"></i></span>去测量时间的推移。我们发现最最新版本的模拟器能够渲染比之前更高速的帧率，它是少数模拟器之一能够准确的按照Android规范去渲染OpenGL ES。</p><p><img src="/images/image1.gif" alt="image1.gif"></p><p><img src="/images/gpu_emulator_stress_test_chart.png" alt="gpu_emulator_stress_test_chart.png"></p><h2 id="更多的功能点"><a href="#更多的功能点" class="headerlink" title="更多的功能点"></a>更多的功能点</h2><p>除了这些主要的功能以外，这儿还有一大堆额外的功能，我们在过去的一年中已经添加到了Android 模拟器，您可能还不知道：</p><blockquote><ul><li><strong>Wi-Fi支持</strong> —— 从API 24的系统镜像开始，您能创建一个包含了连接到一个虚拟的数据网络和一个虚拟的Wi-Fi访问点的AVD</li></ul></blockquote><blockquote><ul><li><strong>Google cast 的支持</strong> —— 当使用一个Google Play 系统镜像，您能够在相同的Wi-Fi网络下够投屏幕和音频内容到Chromecast设备。</li></ul></blockquote><blockquote><ul><li><strong>拖拽APKs和文件</strong> —— 简单的拖拽一个apk到Android模拟器的窗口去触发一个app应用程序的安装。您也能够拖拽任意其它文件，并在您的Android虚拟设备里的/Downloads文件夹下发现它们。</li></ul></blockquote><blockquote><ul><li><strong>主机复制&amp;粘贴</strong> —— 您能够复制&amp;粘贴文本在Android模拟器和您的开发机器之间。</li></ul></blockquote><blockquote><ul><li><strong>虚拟的两个手指捏&amp;缩放</strong> —— 当您的应用程序像集成了Google Maps，按下Ctrl键(在Microsoft® Windows®或者Linux上)或者⌘ (在macOS®上)，并在屏幕上出现手指叠加以帮助捏和缩放操作。</li></ul></blockquote><blockquote><ul><li><strong>GPS位置</strong> —— 手动选择一个GPS点或者在Android模拟器的位置下选项卡下设置GPS点。</li></ul></blockquote><blockquote><ul><li><strong>虚拟传感器</strong> —— 在扩展控制面板上是一个支持传感器专用的页面，包括了加速度，方向，接近度以及更多</li></ul></blockquote><blockquote><ul><li><strong>摄像头支持</strong> —— 您能够使用一个摄像头或者您的笔记本内置的摄像头作为一个在AVD里面虚拟的摄像头。在AVD设置页面里面的高级设置页面验证您的相机设置。</li></ul></blockquote><blockquote><ul><li><strong>主机键盘</strong> —— 您能够使用您真实的键盘去输入文本内容到Android虚拟设备。</li></ul></blockquote><blockquote><ul><li><strong>虚拟短信和拨号</strong> —— 在扩展控制面板，您能够触发一个虚拟的短信或者拨号的去测试您应用里电话的依赖。</li></ul></blockquote><blockquote><ul><li><strong>屏幕缩放</strong> —— 在主工具栏，点击放大镜图标进入放大模式，然后选择一个您需要检测的屏幕区域。</li></ul></blockquote><blockquote><ul><li><strong>窗口重置大小</strong> —— 简单的拖拽Android模拟器窗口的一个角去改变您想要的大小</li></ul></blockquote><blockquote><ul><li><strong>网络代理的支持</strong> —— 通过到代理选项卡下的设置页面，添加一个自定义的HTTP代理到您的Android模拟器会话。</li></ul></blockquote><blockquote><ul><li><strong>Bug 报告</strong> —— 您能够通过使用在扩展控制面板的Bug报告部分，快速的为您的应用程序生成一个bug报告，并分享到您的团队或者发送反馈到Google</li></ul></blockquote><p>了解更多关于Android模拟器的内容，参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3J1bi9lbXVsYXRvci5odG1s" title="https://developer.android.com/studio/run/emulator.html">模拟器文档<i class="fa fa-external-link"></i></span></p><h2 id="从这里开始"><a href="#从这里开始" class="headerlink" title="从这里开始"></a>从这里开始</h2><p>这些所有的功能和改善都可以使用了，去下载并现在使用Android 模拟器v27.0.2+，您能够从Android Studio中的SDK Manager里面获得。对于一个快速的体验，我们建议您创建和运行x86版本的模拟器系统镜像，使用最新版本的Android 模拟器，安装 Intel® HAXM(如果适用)和显卡驱动。</p><p>我们感谢您反馈任何您喜欢的意见建议，问题或者您希望看到的功能。如果您发现了一个bug、issue或者有一个功能请求随时<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3JlcG9ydC1idWdzLmh0bWwjZW11bGF0b3ItYnVncw==" title="https://developer.android.com/studio/report-bugs.html#emulator-bugs">提出问题<i class="fa fa-external-link"></i></span>,我们无疑没有完成，但是我们希望您对到目前为止的改进感到兴奋。</p><blockquote><p>以上是对Google官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://android-developers.googleblog.com/2017/12/quick-boot-top-features-in-android.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Quick Boot &amp;amp; the Top Features in the Android Emulator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们很高兴的宣布Android模拟器快速启动。使用快速启动，您能在6秒内启动模拟器。快速启动通过快照模拟器会话来工作，因此您能够在几秒钟内重新加载。快速启动是在Android Studio 3.0 canary更新通道首次发布，我们很高兴的的在今天的更新中将这一个功能作为稳定版本发布。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Emulator" scheme="https://shoewann0402.github.io/categories/Android/Android-Emulator/"/>
    
    
      <category term="Android Studio" scheme="https://shoewann0402.github.io/tags/Android-Studio/"/>
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Emulator" scheme="https://shoewann0402.github.io/tags/Android-Emulator/"/>
    
  </entry>
  
  <entry>
    <title>GDD China 2017之旅</title>
    <link href="https://shoewann0402.github.io/2017/12/18/gdd-china-2017-in-shanghai-trip-record/"/>
    <id>https://shoewann0402.github.io/2017/12/18/gdd-china-2017-in-shanghai-trip-record/</id>
    <published>2017-12-18T15:34:51.000Z</published>
    <updated>2019-03-11T09:33:32.654Z</updated>
    
    <content type="html"><![CDATA[<p>2016年，那个时候我还在上海。去年的GDD上海场我没有去参加，当时是有些遗憾；今年2017年的GDD如期而至，两天都在上海举办，而我已经不在上海，回到了成都。这时的我决定去参加，因为我是谷歌爱好者，梦寐有机会去参加一次谷歌总部的活动，既然出国不行，那在国内举办活动更近了，并且这次大会我可以和我一直只能在电视和社交软件上的关注的谷歌大佬面对面，更不容错过！</p><a id="more"></a><p>通过GDD大会邮件的报名、筛选，我有幸成为了大会的嘉宾之一，GDD China 2017 活动举办的时间越来越近了。12月12日下午下班，没来得及吃饭，我就直奔机场，踏上成都飞往上海的航程。21：00的飞机，到上海已经23:10分，然后深夜地铁已经结束运营了，只好乘坐的士到以前上海的同事住的地方，已经是第二天凌晨12:00多了。</p><p>13日，GDD China 2017大会举办的第一天，地点在上海跨国采购会展中心。迎着朝阳，我来到了会场地点。首先需要通过安检方可进入会场，在会场外，随处可见Google的元素，Android机器人、Google Map定位图标，GDD China 2017大会代表中国元素的图案，旗帜，还有一些帐篷。会展大楼入口上面贴着醒目的“<strong>Google Developer Days China 2017</strong>”的Logo</p><p><img src="/images/mmexport1513120781516.jpg" alt="aa"></p><p><img src="/images/IMG_20171213_080050.jpg" alt="bb"></p><p>走进会场内，一楼进门口正对的是大会3D的Logo，从左侧看是Google，从右侧看是GDD2017，旁边是签到处，我排好队在签到处提供了签到二维码领到了大会的证件以及Google的纪念礼包，里面包含了DIY音响、贴纸等。之后，到了二楼领了同声传译机，去了三楼的会场层。</p><p>我来的还算比较早，在三楼有Google各种产品的展台，AndroidThings&amp;IoT、Android Wear、Android Assistant、Codelab、GDG等等。时间越来越近了，大会参加的人也越来越多了，10:00大会即将开始，我们进入了主会场听取大会的开幕主题演讲。主会场容纳了2000-3000人，随着代表着中国元素的舞蹈拉开了GDD China 2017大会的序幕。</p><p><img src="/images/IMG_20171213_081434.jpg" alt="cc"></p><p><img src="/images/IMG_20171213_083451.jpg" alt="dd"></p><p>这种气氛仿佛是就是在Google I/O现场，我见到了Google产品总监Andrew Bowers, Google大中华区总裁石博盟(Scott Beaumont),还有李飞飞博士，Google Cloud人工智能和机器学习首席科学家，两次提到了“AI 没有国界，AI 福祉亦无边界。”，并当场宣布了：谷歌AI中国中心的成立。现场如爆裂般的欢呼。</p><p><img src="/images/IMG_20171213_104152.jpg" alt="ee"></p><p>主会场的主题演讲之后，接下来两天的活动也算正式开始了。<br>听了一场由Pete LePage演讲的主题分享之后，就到了午餐时间。在每个活动现场的展会证上都有两天的用餐券，免费提供午餐，在会场的一楼。会场数千人从会场到就餐区，享受Google提供的西式自助餐带来的惬意。</p><p><img src="/images/IMG_20171213_113848.jpg" alt="ff"></p><p>午餐之后，距离下午的分会场活动开始还有一段时间，就在会场转了转。Google的产品展示区，你可以通过下载APP玩游戏活动糖果、通过使用Google翻译扫描明细片上地点的名称在大会现场找到当地的邮票就可以活动谷歌的抱枕、还有单人/多人的QuickDraw、根据你弹奏的曲目自动通过人工智能的方式做出一段相似的旋律、在3D空间内体验艺术的宇宙大爆炸、Tensorflow通过采集人脸数据，自动识别人脸、物联网设备的猜拳和作画等</p><p><img src="/images/IMG_20171213_122106.jpg" alt="gg"></p><p><img src="/images/IMG_20171213_122202.jpg" alt="hh"></p><p><img src="/images/IMG_20171213_122319.jpg" alt="ii"></p><p><img src="/images/IMG_20171213_122329.jpg" alt="jj"></p><p><img src="/images/IMG_20171213_122545.jpg" alt="kk"></p><p><img src="/images/IMG_20171213_122555.jpg" alt="ll"></p><p>很多很多只能在Google总部体验到的产品，都能在现场体验到。在AndroidThings展台和分会场领取一张AndroidThings的兑换券，就能去兑换一套价值不菲的AndroidThings开发套件。通过扫描证件后面的二维码反馈大会意见和建议成功就能获得Google定制的电脑包一个，不过到最后我都没有去领。</p><p><img src="/images/IMG_20171213_145635.jpg" alt="mm"></p><p>下午参加了几场分会场的活动，其中也包含了比较熟悉的演讲嘉宾Daniel Galpin、Hoi lam、Wayne Piekarski、Laurence Moroney。</p><p><img src="/images/IMG_20171213_150238.jpg" alt="nn"></p><p>本次大会还发布了Tensorflow中文网站 —— tensorflow.google.cn，并创建了Tensorflow公众号，为中国开发者提供了Tensorflow的新闻和技术资源。</p><p>After Party，晚宴时间。仿照I/O的方式，主会场变成了party场地，台下有香槟红酒、可乐雪碧、蛋糕水果自助餐，街机电竞游戏，投篮球比赛。台上乐队尽情演奏，灯光和LED显示屏伴随着音乐也嗨了起来，在音乐声中大家也慢慢的散场，每个人都提着Google提供的大礼包，结束了第一天的活动。</p><p><img src="/images/IMG_20171213_183932.jpg" alt="oo"></p><p><img src="/images/wx_camera_1513162978228.jpg" alt="pp"></p><p>14日，GDD大会的第二天，也是最后一天。今天的目标除了听大会喜欢的演讲嘉宾分享技术上新东西，复习和学习以外，还有——当然是找演讲嘉宾他们合影了。</p><p>这两天的活动，由于部分主题人数爆满，临时新增加了分会场，像人工智能、机器学习、Google Cloud等等，虽然我是主要做Android Mobile开发的，但在这次大会上我没有去听Android Oreo相关的话题，应该最多的还是AndroidThings、Tensorflow相关的。</p><p><img src="/images/wx_camera_1513215610762.jpg" alt="qq"></p><p>最后，<br>荣幸的是，我成功的和Laurence Moroney、Wayne Piekarski合影了。<br>遗憾的是，我错过了Daniel Galpin、Hoi lam、还有Ankur Kotwal的交流。</p><p><img src="/images/20171215_095625-COLLAGE.jpg" alt="rr"></p><p>Laurence Moroney说14日当天晚上要离开，准备回去过圣诞节！Merry Christmas ~</p><p>Wayne Piekarski握了一个手，问我最后一场是他的演讲，要去不去参加，我说当然。</p><p>在离开会场时Wayne还给我发androidThings的卡劵去领，我说我已经有一个了，然后挥手道别,两天的GDD活动结束了，我体会到了很多，很多收获和感想。特别是Andrew Bowers和Anna D Goldie，中文讲的真好。</p><p>正如stormzhang说的那样：如果你没去GDD，那真是一种遗憾。</p><p>GDD 明年见 ~</p><blockquote><p>以上就是个人第一次参加GDD活动的一个简单总结</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016年，那个时候我还在上海。去年的GDD上海场我没有去参加，当时是有些遗憾；今年2017年的GDD如期而至，两天都在上海举办，而我已经不在上海，回到了成都。这时的我决定去参加，因为我是谷歌爱好者，梦寐有机会去参加一次谷歌总部的活动，既然出国不行，那在国内举办活动更近了，并且这次大会我可以和我一直只能在电视和社交软件上的关注的谷歌大佬面对面，更不容错过！&lt;/p&gt;
    
    </summary>
    
      <category term="GDD" scheme="https://shoewann0402.github.io/categories/GDD/"/>
    
    
      <category term="GDD" scheme="https://shoewann0402.github.io/tags/GDD/"/>
    
      <category term="GDD China 2017" scheme="https://shoewann0402.github.io/tags/GDD-China-2017/"/>
    
      <category term="Google Developer Days" scheme="https://shoewann0402.github.io/tags/Google-Developer-Days/"/>
    
  </entry>
  
  <entry>
    <title>介绍Android Oreo(Go版)与Android8.1的发布</title>
    <link href="https://shoewann0402.github.io/2017/12/05/Introducing-android-oreo-go-edition/"/>
    <id>https://shoewann0402.github.io/2017/12/05/Introducing-android-oreo-go-edition/</id>
    <published>2017-12-05T13:11:50.000Z</published>
    <updated>2019-03-11T09:33:32.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmxvZy5nb29nbGUvcHJvZHVjdHMvYW5kcm9pZC9pbnRyb2R1Y2luZy1hbmRyb2lkLW9yZW8tZ28tZWRpdGlvbi8=" title="https://www.blog.google/products/android/introducing-android-oreo-go-edition/">Introducing Android Oreo (Go edition) with the release of Android 8.1<i class="fa fa-external-link"></i></span></p></blockquote><p>自Android的创建，我们的使命是将计算的力量带给每一个人。作为一个全球操作系统，Android已经发展到全球超过20亿激活设备，印度的用户人数超过了美国。</p><p>为了确保数十亿人能够访问到计算，入门级设备是功能齐全的智能手机，可以浏览网页和使用应用程序。在<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmxvZy5nb29nbGUvcHJvZHVjdHMvYW5kcm9pZC8yYm4tbWlsZXN0b25lLw==" title="https://www.blog.google/products/android/2bn-milestone/">今年的Google I/O大会上<i class="fa fa-external-link"></i></span>,我们提前看了一个被我们称之为”Android Go”的项目，并让这个项目成为可能。我们激动的宣布这个软件体验——<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5kcm9pZC5jb20vdmVyc2lvbnMvb3Jlby04LTAvZ28tZWRpdGlvbg==" title="https://www.android.com/versions/oreo-8-0/go-edition">Android Oreo(Go版)<i class="fa fa-external-link"></i></span>——准备好了,将在明天作为Android 8.1发布的一个部分发布。</p><a id="more"></a><p>具有512MB到1GB内存的Android Oreo设备将随着Go的全面优化而来,这个Android Oreo(Go版)体验是由三个关键部分组成：</p><ul><li><p><strong>操作系统：</strong>对于操作系统的性能和存储提高,数据管理功能和内置安全优势。</p></li><li><p><strong>Google 应用：</strong>一组新的Google应用程序,设计更轻且与首次上网的人的独特需求相关。</p></li><li><p><strong>Google Play商店：</strong>一款调整版本的Google Play商店允许你下载任意的应用程序,但是也突出了在你设备上设计最好的应用程序。</p></li></ul><h2 id="Go-大，性能更快，更多存储，数据管理和安全性"><a href="#Go-大，性能更快，更多存储，数据管理和安全性" class="headerlink" title="Go 大，性能更快，更多存储，数据管理和安全性"></a>Go 大，性能更快，更多存储，数据管理和安全性</h2><p>我们增强了Android Oreo（Go版）在入门级设备上对于速度和可靠性，意味着在Android Oreo（Go版）的设备上运行的平均应用程序现在快了15%，这儿有很多这样各种各样的优化——它们真的加起来了。如果所有的入门级Android设备启动应用程序的速度提高15%,将节约全球累计100万小时的时间——每天！</p><p>入门级设备,一旦你考虑到操作系统的大小和预装的应用程序，它们通常有着非常小的存储空间可以使用。对于那些想要更大空间为了他们的音乐、应用程序以及照片的人来说这个就很沮丧了。因此，我们将优化Android Oreo（Go版）并增强我们预安装的Google应用程序占用至少50%的空间。最终的结果是，我们已经将入门级设备上面的可用空间增加了一倍。</p><p><img src="/images/Screen_Shot_2017-12-05_at_11.54.52_AM.width-1000.png" alt="Screen_Shot_2017-12-05_at_11.54.52_AM.width-1000.png"></p><p>设备运行了Android Oreo（Go版）也伴随了默认开启的Google的数据节省器功能的到来。比如说,在Chrome中的数据节省器每年节约了平均每个用户超过600MB的数据。你也能够通过使用我们内置的数据节省功能管理在后台使用数据的应用程序，给你更多控制你的数据是如何被使用的。</p><p>Android Oreo是Android最安全的版本,因此当你购买一款Android Oreo（Go版）的设备，你将能够获得所有相同的安全功能,并且当然所有的Android Oreo（Go版）的设备都内置了获取<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5kcm9pZC5jb20vcGxheS1wcm90ZWN0Lw==" title="https://www.android.com/play-protect/">Google Play Protect<i class="fa fa-external-link"></i></span>。Google Play Protect一直保持你的设备工作,数据和应用程序安全。它能够扫描你的应用程序安装,甚至当你是离线状态,不管你从哪儿下载了它们。</p><h2 id="Go-和-谷歌"><a href="#Go-和-谷歌" class="headerlink" title="Go 和 谷歌"></a>Go 和 谷歌</h2><p>我们将重新设计大多数我们流行的Google应用程序去解决当地的需要。预安装在Android Oreo（Go版）设备,这套通过Google优化的应用程序包括Google Go,Google Assistant Go,YouTuBe Go,Google Map Go,Gmail Go,Gboard,Google Play,Chrome和新的File Go应用程序。</p><p>我们新的和重新想象的Google应用程序，我们将关注于使它们不仅仅更小,但是也光滑快速。比如说,Google Go——一款新的应用程序去查找里想要的信息——通过提升40%优化数据,重量大小不到5MB,并且使用简单、可点击的方式就能很快速的找到流行和趋势信息。对于Android(Go版)的Google Assistant,你能够快速的发送消息、打电话、设置闹钟以及更多利用你的声音和一个单一的屏幕触碰。</p><p>我们的存储节省功能是由Google扩展操作系统之外的一个全新的文件管理应用程序——<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmxvZy5nb29nbGUvdG9waWNzL25leHQtYmlsbGlvbi11c2Vycy9yZWFkeS1zZXQtZmlsZXMtZ28v" title="https://www.blog.google/topics/next-billion-users/ready-set-files-go/">File Go<i class="fa fa-external-link"></i></span>——帮助你清理空间，保持有组织。无论是来自你手机删除垃圾邮件的建议，重复的图像或者是未使用的应用程序,File Go是Android Oreo(Go版)的存储最大化功能的完美补充。</p><p><img src="/images/Blogpost_Play.width-1000.png" alt="Blogpost_Play.width-1000.png"></p><h2 id="Go-Play"><a href="#Go-Play" class="headerlink" title="Go Play"></a>Go Play</h2><p>在Google商店,你能够下载任意的应用程序,并且我们也创建了一个新的部分建议流行的应用程序，调整为入门设备上运行良好。</p><p>我们很高兴的看到我们大多数的合作伙伴使用了我们<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZGV2ZWxvcC9xdWFsaXR5LWd1aWRlbGluZXMvYnVpbGRpbmctZm9yLWJpbGxpb25zLmh0bWw=" title="https://developer.android.com/develop/quality-guidelines/building-for-billions.html">建了数十亿方针<i class="fa fa-external-link"></i></span>，要么优化现有的应用程序，要么去创建一个新的应用程序在入门级设备上运行良好。希望将他们的经验带给数十亿新的智能手机用户。</p><h2 id="准备-设置-Go"><a href="#准备-设置-Go" class="headerlink" title="准备.设置.Go"></a>准备.设置.Go</h2><p>在Android 8.1中推出Android Oreo(Go版)，合作伙伴将在不久就能够在全球的入门级设备上发布这个新版本，我们不能等待我们的合作伙伴的设备在未来的的几个月上架。</p><p>如果你是一个开发者，我们一起为下一个十亿人构建。</p><blockquote><p>以上是对Google官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://www.blog.google/products/android/introducing-android-oreo-go-edition/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introducing Android Oreo (Go edition) with the release of Android 8.1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自Android的创建，我们的使命是将计算的力量带给每一个人。作为一个全球操作系统，Android已经发展到全球超过20亿激活设备，印度的用户人数超过了美国。&lt;/p&gt;
&lt;p&gt;为了确保数十亿人能够访问到计算，入门级设备是功能齐全的智能手机，可以浏览网页和使用应用程序。在&lt;a href=&quot;https://www.blog.google/products/android/2bn-milestone/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;今年的Google I/O大会上&lt;/a&gt;,我们提前看了一个被我们称之为”Android Go”的项目，并让这个项目成为可能。我们激动的宣布这个软件体验——&lt;a href=&quot;https://www.android.com/versions/oreo-8-0/go-edition&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Oreo(Go版)&lt;/a&gt;——准备好了,将在明天作为Android 8.1发布的一个部分发布。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android Oreo" scheme="https://shoewann0402.github.io/categories/Android/Android-Oreo/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Oreo Go" scheme="https://shoewann0402.github.io/tags/Android-Oreo-Go/"/>
    
      <category term="Android Go" scheme="https://shoewann0402.github.io/tags/Android-Go/"/>
    
  </entry>
  
  <entry>
    <title>公布架构组件1.0稳定</title>
    <link href="https://shoewann0402.github.io/2017/11/07/announcing-architecture-components-10/"/>
    <id>https://shoewann0402.github.io/2017/11/07/announcing-architecture-components-10/</id>
    <published>2017-11-07T09:09:47.000Z</published>
    <updated>2019-03-11T09:33:32.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8xMS9hbm5vdW5jaW5nLWFyY2hpdGVjdHVyZS1jb21wb25lbnRzLTEwLmh0bWw=" title="https://android-developers.googleblog.com/2017/11/announcing-architecture-components-10.html">Announcing Architecture Components 1.0 Stable<i class="fa fa-external-link"></i></span></p></blockquote><p>Android运行在数十亿台设备上,从高端手机到飞机座椅靠背。在这个庞大的设备范围Android操作系统积极的管理资源已取得了良好的表现，有的时候能构建出强大复杂的应用程序。</p><p>为了使它变得更加简单，我们在Google I/O大会上启动了一个预览版的架构组件，在应用程序架构上提供指导。包括了像生命周期管理和数据持久化等通用任务的库。总而言之，这些基础的组件通过较少的代码样本去写模块化应用程序使它成为可能。因此开发者们能够关注于创新而不是重新造轮子 —— 并且我们希望在未来保持在这个基础上去构建。</p><a id="more"></a><p>今天我们很高兴的宣布了<code>Room</code>和<code>Lifecycle</code><span class="exturl" data-url="aHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9hcmNo" title="http://developer.android.com/arch">架构组件<i class="fa fa-external-link"></i></span>库到了1.0稳定。这些API已经为生产应用程序和库做好了准备，是我们建议开发者寻找架构用程序架构的帮助以及本地存储(尽管这里这里是建议，但是不要求)。<code>Lifecycle</code>现在也能够和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL3N1cHBvcnQtbGlicmFyeS9pbmRleC5odG1s" title="https://developer.android.com/topic/libraries/support-library/index.html">支持库<i class="fa fa-external-link"></i></span>集成，因此你能够使用像AppCompatActivity这样标准的类去使用它们。</p><p>尽管我们在今天声明它们稳定，公测的组件已经在应用程序中一起使用了，有数十亿次安装。顶端开发者，像Zappos,已经能花费更多的时间去感谢架构组件什么是最重要的:<br><img src="/images/zappos-logo.jpg" alt="zappos-logo.jpg"></p><p><em>在Android架构组件发布之前，我们有自己的ViewModel实现，我们使用Loaders和Dependency注入，通过更改配置去保存我们的ViewModel。我们最近切换到了Android架构组件ViewModel实现，所有的样板都消失了。我们发现我们可以花费更多的时间在设计、业务逻辑以及测试上面，在写样板和担心Android生命周期上的问题也会少一点了</em></p><p><em>我们也开始去使用LiveData将它直接勾进Android生命周期里。我们使用它去回收和展示网络数据，并且不必再去关心网络呼叫订阅管理 —— Zappos公司Android软件工程师大卫亨利</em></p><p>架构组件提供了一个示例，灵活而适用的方法让开发者们免去了一些共同问题，因此他们能够关注于构建更棒的体验，这个是依靠于应用程序架构向导的核心构建块。</p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>每一个android开发者必须要处理操作系统开始、停止以及销毁它们的活动。这就意味着管理组件的状态——比如观察被使用去更新UI界面——如同你移动通过生命周期一样。<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9saWZlY3ljbGUuaHRtbA==" title="https://developer.android.com/topic/libraries/architecture/lifecycle.html">Lifecycle<i class="fa fa-external-link"></i></span>(生命周期)能够创建<em>生命周期-感知</em>组件来管理它们自己的生命周期，减少泄漏或者崩溃的可能性。Lifecycle库是像LiveData等其它架构组件的基础</p><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9saXZlZGF0YS5odG1s" title="https://developer.android.com/topic/libraries/architecture/livedata.html">LiveData<i class="fa fa-external-link"></i></span>(动态数据)是一个支持数据并提供更新可观察的生命周期-感知。你的UI代码订阅更改并提供LiveData一个参考到<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXJjaC9saWZlY3ljbGUvTGlmZWN5Y2xlLmh0bWw=" title="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.html">Lifecycle<i class="fa fa-external-link"></i></span>。因为LiveData是生命周期-感知，当它的生命周期被开始或者被恢复，它将提供更新，但是当生命周期主被销毁，则停止提供更新。LiveData是一个简单的方式去构建被动的UI界面，更安全更高效。</p><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS92aWV3bW9kZWwuaHRtbA==" title="https://developer.android.com/topic/libraries/architecture/viewmodel.html">ViewModel<i class="fa fa-external-link"></i></span>(视图模型)像Activity和Fragment一样从生命周期的实体分离视图数据和逻辑的所有权。一个ViewModel是被保留的直到与它相关联的Acitivty和Fragment永久的被抛弃——这就意味着视图数据能够像一个Fragment由于旋转而重新被创建幸存。ViewModel不仅仅是消除生命周期共同问题，它们帮助构建更模块化方便测试。</p><h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><p>几乎所有的应用都需要在本地存储数据，当自从版本1开始Android绑定了SQLite和平台，直接使用它是很痛苦的。<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9yb29tLmh0bWw=" title="https://developer.android.com/topic/libraries/architecture/room.html">Room<i class="fa fa-external-link"></i></span>(房间)是一个简单的对象映射层，利用较少的样板提供满功率的SQLite。特性像编译时间查询验证并内置迁移，使构建一个强大的持久层更加容易。当与LiveData集成，让Room提供数据库支持、可观察的生命周期感知。Room对于管理本地存储，融合了简单、强大和稳健。我们希望你能够尝试它一下。</p><h2 id="App架构向导以及更多"><a href="#App架构向导以及更多" class="headerlink" title="App架构向导以及更多"></a>App架构向导以及更多</h2><p>最后但并不是不重要的，我们创建了一个<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9ndWlkZS5odG1s" title="https://developer.android.com/topic/libraries/architecture/guide.html">应用程序架构指南<i class="fa fa-external-link"></i></span> 为所有的开发者提供实用的核心原则，有关使用架构组件的具体指南，因为我们从你们那儿清楚的听到了一致的答复指南是重要的。今天我们适当的更新了<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20v" title="https://developer.android.com/">开发者文档<i class="fa fa-external-link"></i></span>去指出架构组件。我们在<span class="exturl" data-url="aHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9hcmNo" title="http://developer.android.com/arch">架构组件站点<i class="fa fa-external-link"></i></span>也有一套丰富的视频、代码实验室和示例应用程序可用，来获得更多。</p><h2 id="看这个空间"><a href="#看这个空间" class="headerlink" title="看这个空间"></a>看这个空间</h2><p>尽管第一组架构组件现在是稳定，我们知道这儿还有更多工作需要做。在过去的几个月中，我们听取了<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9mZWVkYmFjay5odG1s" title="https://developer.android.com/topic/libraries/architecture/feedback.html">你的反馈<i class="fa fa-external-link"></i></span>进行了提高，我们也在最近启动了一个新的架构组件,<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9wYWdpbmcuaHRtbA==" title="https://developer.android.com/topic/libraries/architecture/paging.html">PagedList<i class="fa fa-external-link"></i></span>，对于alpha,回应你们的反馈，用RecyclerView处理大数据集太困难了，这仅仅是开始——我们有更多基本的组件在开发，我们将在期待在接下来的几个月中宣布。</p><p>我们对架构组件的期望是让开发者在移动设备上能够专注于提供独特的全新体验。我们很荣幸我们能够最终宣布它们作为正式生产使用,我们要感谢社区，一路上给了一些很棒的反馈，我们期待这继续讨论这篇文章的评论。最后，对于那些等待这个正式启动的人来说，<span class="exturl" data-url="aHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9hcmNo" title="http://developer.android.com/arch">从今天开始<i class="fa fa-external-link"></i></span></p><blockquote><p>以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://android-developers.googleblog.com/2017/11/announcing-architecture-components-10.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Announcing Architecture Components 1.0 Stable&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android运行在数十亿台设备上,从高端手机到飞机座椅靠背。在这个庞大的设备范围Android操作系统积极的管理资源已取得了良好的表现，有的时候能构建出强大复杂的应用程序。&lt;/p&gt;
&lt;p&gt;为了使它变得更加简单，我们在Google I/O大会上启动了一个预览版的架构组件，在应用程序架构上提供指导。包括了像生命周期管理和数据持久化等通用任务的库。总而言之，这些基础的组件通过较少的代码样本去写模块化应用程序使它成为可能。因此开发者们能够关注于创新而不是重新造轮子 —— 并且我们希望在未来保持在这个基础上去构建。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Architecture Components" scheme="https://shoewann0402.github.io/categories/Android/Architecture-Components/"/>
    
    
      <category term="Develop" scheme="https://shoewann0402.github.io/tags/Develop/"/>
    
      <category term="Android Developer" scheme="https://shoewann0402.github.io/tags/Android-Developer/"/>
    
      <category term="Announcements" scheme="https://shoewann0402.github.io/tags/Announcements/"/>
    
      <category term="Architecture Components" scheme="https://shoewann0402.github.io/tags/Architecture-Components/"/>
    
      <category term="Best Practices" scheme="https://shoewann0402.github.io/tags/Best-Practices/"/>
    
  </entry>
  
  <entry>
    <title>介绍Android即时应用SDK 1.1</title>
    <link href="https://shoewann0402.github.io/2017/10/13/introducing-android-instant-apps-sdk-11/"/>
    <id>https://shoewann0402.github.io/2017/10/13/introducing-android-instant-apps-sdk-11/</id>
    <published>2017-10-13T02:43:19.000Z</published>
    <updated>2019-03-11T09:33:32.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8xMC9pbnRyb2R1Y2luZy1hbmRyb2lkLWluc3RhbnQtYXBwcy1zZGstMTEuaHRtbA==" title="https://android-developers.googleblog.com/2017/10/introducing-android-instant-apps-sdk-11.html">Introducing Android Instant Apps SDK 1.1<i class="fa fa-external-link"></i></span></p></blockquote><p>自从我们在Google I/O上面<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8wNS9hbmRyb2lkLWluc3RhbnQtYXBwcy1pcy1vcGVuLXRvLWFsbC5odG1s" title="https://android-developers.googleblog.com/2017/05/android-instant-apps-is-open-to-all.html">公开启动<i class="fa fa-external-link"></i></span>,我们已经努力工作去提升开发者构建即时应用的体验。今天我们激动的宣布Android即时应用SDK1.1可用。一些高度请求的功能，像提升NDK的支持、配置APKs以此减少二进制的大小，以及一个全新的API，当用户从一个即时应用程序过渡到已安装好应用程序，去保持用户的上下文。</p><a id="more"></a><h2 id="介绍配置APKs"><a href="#介绍配置APKs" class="headerlink" title="介绍配置APKs"></a>介绍配置APKs</h2><p>对于一个非常棒的即时应用体验，应用二进制需要精益和良好的结构。这也是为什么我们要介绍配置APKs</p><p>配置APKs允许开发者隔离设备－验证资源和依赖在APKs里面的本地库。对于一个应用使用配置APKs,Android即时应用核心将只会加载资源和本地库相关的给用户的设备，从而减少即时应用程序在设备上的总大小。</p><p>我们当前支持配置APKs的显示密度，CPU的体系结构(ABI),以及语言。这些，我们看到在已加载的二进制大小平均降低了10%。给定应用程序的实际节省依赖于资源文件数和本地库，能够被配置。</p><p>以一个示例来说，一个用户在一部LDPI屏幕密度的ARM设备上设置了中文语言，接收与设备无关的代码和资源，然后只能获取配置APKs是ARM本地库、中文语言、以及LDPI资源。它们将不能够接收到其他任意的配置APKs，比如x86的库，西班牙语言的字符串，或者HDPI的资源。</p><p>为你的应用设置配置APKs只需要简单的改变你的gradle文件的设置。跟随我们<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvaW5zdGFudC1hcHBzL2d1aWRlcy9jb25maWctc3BsaXRzLmh0bWw=" title="https://developer.android.com/topic/instant-apps/guides/config-splits.html">公开的文档<i class="fa fa-external-link"></i></span>步骤。</p><h2 id="安装之后的持久化用户上下文"><a href="#安装之后的持久化用户上下文" class="headerlink" title="安装之后的持久化用户上下文"></a>安装之后的持久化用户上下文</h2><p>在Android奥尼奥，即时版本应用的内置存储可以直接用于安装版本应用程序。这次发布的SDK,我们能够在旧版本的Android核心上启用这个功能，包括棒棒糖、棉花糖、和牛轧糖的设备。</p><p>提取即时应用程序的内置存储，安装应用程序现在能够调用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vYW5kcm9pZC9yZWZlcmVuY2UvY29tL2dvb2dsZS9hbmRyb2lkL2dtcy9pbnN0YW50YXBwcy9JbnN0YW50QXBwc0NsaWVudCNnZXRJbnN0YW50QXBwRGF0YSg=" title="https://developers.google.com/android/reference/com/google/android/gms/instantapps/InstantAppsClient#getInstantAppData(">InstantAppsClient.getInstantAppData()<i class="fa fa-external-link"></i></span>)使用即时应用程序Google Play服务API，以及获得一个即时应用程序内置存储的ZIP文件。</p><p>检出我们<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvYW5kcm9pZC1pbnN0YW50LWFwcHM=" title="https://github.com/googlesamples/android-instant-apps">示例代码<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vYW5kcm9pZC9yZWZlcmVuY2UvY29tL2dvb2dsZS9hbmRyb2lkL2dtcy9pbnN0YW50YXBwcy9JbnN0YW50QXBwc0NsaWVudCNnZXRJbnN0YW50QXBwRGF0YSg=" title="https://developers.google.com/android/reference/com/google/android/gms/instantapps/InstantAppsClient#getInstantAppData(">文档<i class="fa fa-external-link"></i></span>)获取如何使用这个API的更多详细。</p><h2 id="开始构建你的Android即时应用"><a href="#开始构建你的Android即时应用" class="headerlink" title="开始构建你的Android即时应用"></a>开始构建你的Android即时应用</h2><p>在最新版的SDK上构建你的即时应用程序是简单的，只需要在Android Studio里面打开SDK Manager，然后升级你的Instant App Development SDK到1.1.0。我们迫不及待的想看到你为即时应用程序构建这些新的功能特性。</p><blockquote><p>以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://android-developers.googleblog.com/2017/10/introducing-android-instant-apps-sdk-11.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introducing Android Instant Apps SDK 1.1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自从我们在Google I/O上面&lt;a href=&quot;https://android-developers.googleblog.com/2017/05/android-instant-apps-is-open-to-all.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;公开启动&lt;/a&gt;,我们已经努力工作去提升开发者构建即时应用的体验。今天我们激动的宣布Android即时应用SDK1.1可用。一些高度请求的功能，像提升NDK的支持、配置APKs以此减少二进制的大小，以及一个全新的API，当用户从一个即时应用程序过渡到已安装好应用程序，去保持用户的上下文。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
    
      <category term="Android Studio" scheme="https://shoewann0402.github.io/tags/Android-Studio/"/>
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Develop" scheme="https://shoewann0402.github.io/tags/Develop/"/>
    
      <category term="Android Instant Apps" scheme="https://shoewann0402.github.io/tags/Android-Instant-Apps/"/>
    
      <category term="Play Console" scheme="https://shoewann0402.github.io/tags/Play-Console/"/>
    
      <category term="Studio" scheme="https://shoewann0402.github.io/tags/Studio/"/>
    
  </entry>
  
  <entry>
    <title>谷歌助理能够帮助您控制Android媒体应用程序</title>
    <link href="https://shoewann0402.github.io/2017/10/12/the-google-assistant-can-help-control/"/>
    <id>https://shoewann0402.github.io/2017/10/12/the-google-assistant-can-help-control/</id>
    <published>2017-10-11T17:43:41.000Z</published>
    <updated>2019-03-11T09:33:32.662Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8xMC90aGUtZ29vZ2xlLWFzc2lzdGFudC1jYW4taGVscC1jb250cm9sLmh0bWw=" title="https://android-developers.googleblog.com/2017/10/the-google-assistant-can-help-control.html">The Google Assistant can help control your Android media apps<i class="fa fa-external-link"></i></span></p></blockquote><p>谷歌助理可用贯穿通了手机，音响，安卓电视以及更多。它能够帮助用户在一天中完成更多的工作 —— 这儿它们需要添加一些事情到去完成的列表，打开电灯，或者播放一首歌曲。</p><p>音乐是特别的,助理有大量的提供。它能够通过设备(“播放摇滚乐”)理解媒体命令，并支持媒体控制(像暂停、跳过、快进、赞成)，用户也能通过谷歌助理控制安卓媒体播放。例如，您告诉谷歌助理”暂停回放”，无需抬起手指就能暂停回放。或者说”在Universal音乐播放器上播放摇滚乐”来播放音乐</p><a id="more"></a><p>为了让用户在使用您的媒体应用中的谷歌助理时能够控制回放，您可以使用<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2dvb2dsZS1kZXZlbG9wZXJzL3VuZGVyc3RhbmRpbmctbWVkaWFzZXNzaW9uLXBhcnQtMS0zLWU0ZDI3MjVmMThlNA==" title="https://medium.com/google-developers/understanding-mediasession-part-1-3-e4d2725f18e4">MediaSession<i class="fa fa-external-link"></i></span>API去让这件事发生。我们建议您在制作应用程序与Google Assistant的集成时，使用MediaSession。</p><h2 id="在您的应用程序中如何使用MediaSession-？"><a href="#在您的应用程序中如何使用MediaSession-？" class="headerlink" title="在您的应用程序中如何使用MediaSession ？"></a>在您的应用程序中如何使用MediaSession ？</h2><p>您必须实现一个MediaSession,在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvdG9waWNzL21lZGlhLWFwcHMvaW50ZXJhY3Rpbmctd2l0aC1hc3Npc3RhbnQuaHRtbCN1c2VfYV9tZWRpYV9zZXNzaW9u" title="https://developer.android.com/guide/topics/media-apps/interacting-with-assistant.html#use_a_media_session">与谷歌助理进行交互时<i class="fa fa-external-link"></i></span>处理所描述的一组规定的动作。</p><p>这里是一些示例项目，能够帮您开始在您的媒体应用程序里面使用MediaSession</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvYW5kcm9pZC1NZWRpYUJyb3dzZXJTZXJ2aWNlLw==" title="https://github.com/googlesamples/android-MediaBrowserService/">媒体浏览器服务示例<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvYW5kcm9pZC1Vbml2ZXJzYWxNdXNpY1BsYXllcg==" title="https://github.com/googlesamples/android-UniversalMusicPlayer">Universal 音乐播放器示例<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvbGVhbmJhY2stYXNzaXN0YW50" title="https://github.com/googlesamples/leanback-assistant">助理与Leanback样本集成示例<i class="fa fa-external-link"></i></span></li></ul></blockquote><p>对于想了解学习更多关于MediaSession，这里有一些好的资源：</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2dvb2dsZS1kZXZlbG9wZXJzL3VuZGVyc3RhbmRpbmctbWVkaWFzZXNzaW9uLXBhcnQtMS0zLWU0ZDI3MjVmMThlNA==" title="https://medium.com/google-developers/understanding-mediasession-part-1-3-e4d2725f18e4">理解MediaSession<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZ3VpZGUvdG9waWNzL21lZGlhLWFwcHMvd29ya2luZy13aXRoLWEtbWVkaWEtc2Vzc2lvbi5odG1s" title="https://developer.android.com/guide/topics/media-apps/working-with-a-media-session.html">使用MediaSession<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8xMC92aWRlby1wbGF5YmFjay13aXRoLWdvb2dsZS1hc3Npc3RhbnQtb24uaHRtbA==" title="https://android-developers.googleblog.com/2017/10/video-playback-with-google-assistant-on.html">使用谷歌助理在安卓电视上进行视频回放<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="谷歌助理如何使用MediaSession？"><a href="#谷歌助理如何使用MediaSession？" class="headerlink" title="谷歌助理如何使用MediaSession？"></a>谷歌助理如何使用MediaSession？</h2><p>谷歌助理使用MediaSession时和其他外部控制器(比如安卓可穿戴设备)相同的方式使用MediaSession。每一个控制器都会导致您的应用程序状态变化。<br>并且这儿需要有一个方式去响应这些变化。这就是MediaSession的发挥作用的地方。</p><p>通过使用MediaSession,谷歌助理能够控制您的应用程序的媒体播放，以及保持同步其当前状态</p><h2 id="如何使用MediaSession测试我的应用程序？"><a href="#如何使用MediaSession测试我的应用程序？" class="headerlink" title="如何使用MediaSession测试我的应用程序？"></a>如何使用MediaSession测试我的应用程序？</h2><p>一旦您实现了MediaSession您将可能想去测试，如何在您的应用程序以外去控制媒体播放，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvYW5kcm9pZC1tZWRpYS1jb250cm9sbGVy" title="https://github.com/googlesamples/android-media-controller">媒体控制器测试<i class="fa fa-external-link"></i></span>工具被创建去模拟外部控制您的媒体播放，您可以验证当其他应用程序(比如谷歌助理)与您的应用程序就行互动时，它将可以按预期方式工作。</p><blockquote><p>以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://android-developers.googleblog.com/2017/10/the-google-assistant-can-help-control.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Google Assistant can help control your Android media apps&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;谷歌助理可用贯穿通了手机，音响，安卓电视以及更多。它能够帮助用户在一天中完成更多的工作 —— 这儿它们需要添加一些事情到去完成的列表，打开电灯，或者播放一首歌曲。&lt;/p&gt;
&lt;p&gt;音乐是特别的,助理有大量的提供。它能够通过设备(“播放摇滚乐”)理解媒体命令，并支持媒体控制(像暂停、跳过、快进、赞成)，用户也能通过谷歌助理控制安卓媒体播放。例如，您告诉谷歌助理”暂停回放”，无需抬起手指就能暂停回放。或者说”在Universal音乐播放器上播放摇滚乐”来播放音乐&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Android Assistant" scheme="https://shoewann0402.github.io/tags/Android-Assistant/"/>
    
      <category term="MediaSession" scheme="https://shoewann0402.github.io/tags/MediaSession/"/>
    
  </entry>
  
  <entry>
    <title>Google发布Google I/O 2017 安卓源代码</title>
    <link href="https://shoewann0402.github.io/2017/08/19/google-releases-source-for-google-io-md/"/>
    <id>https://shoewann0402.github.io/2017/08/19/google-releases-source-for-google-io-md/</id>
    <published>2017-08-19T05:45:31.000Z</published>
    <updated>2019-03-11T09:33:32.654Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8wOC9nb29nbGUtcmVsZWFzZXMtc291cmNlLWZvci1nb29nbGUtaW8uaHRtbA==" title="https://android-developers.googleblog.com/2017/08/google-releases-source-for-google-io.html">Google releases source for Google I/O 2017 for Android<i class="fa fa-external-link"></i></span></p></blockquote><p>今天我们发布官方<span class="exturl" data-url="aHR0cHM6Ly9wbGF5Lmdvb2dsZS5jb20vc3RvcmUvYXBwcy9kZXRhaWxzP2lkPWNvbS5nb29nbGUuc2FtcGxlcy5hcHBzLmlvc2NoZWQmYW1wO2hsPWVu" title="https://play.google.com/store/apps/details?id=com.google.samples.apps.iosched&amp;hl=en">Google I/O 2017<i class="fa fa-external-link"></i></span> Android应用程序<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9pb3NjaGVk" title="https://github.com/google/iosched">源代码<i class="fa fa-external-link"></i></span></p><p>今年这个应用基本上修改了现有的功能，并且添加了一些新的功能。它也利用了<span class="exturl" data-url="aHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tLw==" title="https://firebase.google.com/">Firebase<i class="fa fa-external-link"></i></span>去拓展技术堆栈。在这篇文章中，我们将高亮在这个应用程序的几个显著变化，以及它们设计的注意实事项。</p><a id="more"></a><p>对于2017版本最多突出的新功能是事件<strong>约束</strong>系统，这样被设计有助于节省参会者的时间，并提供精简的会议体验。注册参会能够在之前预约会话并添加到等待列表中。在会议期间，一个预约提供了加快进入会议，而不用长时间去等待。预约的数据将会和参会者会议徽章同步，允许事件工作人员使用NFC手机验证预约，不仅仅是预约功能非常受欢迎，但是预约数据帮助了事件工作人员在I/O大会之前和之间改变会话室的大小，以次来适应实际的座位需求。</p><p>预约的功能是使用<span class="exturl" data-url="aHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL3Byb2R1Y3RzL2RhdGFiYXNlLw==" title="https://firebase.google.com/products/database/">Firebase实时数据库<i class="fa fa-external-link"></i></span>(RTDB)和<span class="exturl" data-url="aHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL3Byb2R1Y3RzL2Z1bmN0aW9ucy8=" title="https://firebase.google.com/products/functions/">Firebase云功能<i class="fa fa-external-link"></i></span>实现的。RTDB提供了通过用户的设备简单的同步——我们仅仅是在我们的代码中实现了一个监听来接收更新数据库。RTDB也提供了开箱即用离线支持，允许会议数据当在旅行是面对间歇性网络连接也可以使用。云端功能在后台处理用户预约的请求过程，使用交易去确保状态的正确性(防止恶作剧用户抓住太多的座位！)并和事件系统徽章通信。</p><p>对去年而言，我们使用了内容提供者(ContentProvider)作为一个抽象层覆盖所有应用数据，也就意味着我们必须指出如何使用内容提供者去整合RTDB数据。我们需要在有两个本地缓存数据之间进行协商：1）来源于内容提供者访问现存本地SQLite数据库，2）通过RTDB被创建的本地缓存去促进离线访问。我们决定在内容提供者之下整合所有的应用数据：无论何时在RTDB里用户预约的数据改变，我们将更新内容提供者，使它成为在任何时间应用程序数据的唯一真实来源。这就意味着我们需要去在一个唯一的屏幕对RTDB保持打开连接，会话详细信息界面，用户可能正在积极地管理他们的预约。预约数据通过内容提供着支持显示在应用程序的其他部分。在离线模式下，或者是在与RTDB的片断或延迟连接的情况下，我们能够从内容提供着获取用户的最后一个预约的已知状态。</p><p>我们还必须指出将RTDB整合到整个IOSched同步逻辑中的良好模式，尤其是自从RTDB伴随着非常不同的同步模式，而不是我们在应用程序中使用的ping-fetch方法。我们决定去继续使用<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2VuZHBvaW50cy8=" title="https://cloud.google.com/endpoints/">云端点<i class="fa fa-external-link"></i></span>通过设备去同步用户的数据，网络和iOS客户端（数据本身存储在<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2FwcGVuZ2luZS9kb2NzL3N0YW5kYXJkL2phdmEvZGF0YXN0b3JlLw==" title="https://cloud.google.com/appengine/docs/standard/java/datastore/">数据存储区<i class="fa fa-external-link"></i></span>中)。当RTDB提供了开箱即用数据同步，我们想确保所有设备上的用户预约数据都是最新的，<em>甚至当应用程序不是在前台时</em>，我们利用云功能去整合RTDB预约数据到同步流：一旦用户改变了在RTDB中预约数据，该功能更新了端点，触发了<span class="exturl" data-url="aHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL3Byb2R1Y3RzL2Nsb3VkLW1lc3NhZ2luZy8=" title="https://firebase.google.com/products/cloud-messaging/">Firebase云消息<i class="fa fa-external-link"></i></span>下游消息到所有用户的设备上，然后调度数据同步。</p><p>今年的应用程序还推出了一个<strong>Feed</strong>功能去通知用户关于I/O的逐个小时的发展(大多数应用的用户是远程的，Feed只是他们进入会议的一个窗口)，Feed也是通过RTDB提供动力，数据使用了一个简单的CMS推送到服务器。我们使用了一个云功能去监控RTDB feed数据;当feed数据在服务器被更新，云功能就会发送一条云消息下游消息到客户端，视觉上为用户呈现新的Feed项。</p><p>在2015和2016年里，我们为IOSched已经通过了一个MVP架构，我们在今年继续使用。这个架构提供我们很好的分离关注，方便测试，并且大致来说使我们的代码更清洁和更容易去维护。对于Feed功能，我们决定利用一个更轻量级的MVP去实验实现，灵感来源于<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZXNhbXBsZXMvYW5kcm9pZC1hcmNoaXRlY3R1cmU=" title="https://github.com/googlesamples/android-architecture">Android Architecture Blueprints<i class="fa fa-external-link"></i></span>,它提供了必要的模块化，同时非常容易概念化。这里的目标是教学和实践:我们想为开发者展示替代MVP模式，我们也想去展示一个适合我们对此功能的需求的架构。</p><p>首次，IOSched大量使用了<span class="exturl" data-url="aHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvcmVtb3RlLWNvbmZpZy8=" title="https://firebase.google.com/docs/remote-config/">Firebase远程配置<i class="fa fa-external-link"></i></span>。以往，我们发现了自己当非会话数据——无线信息不能够去通知用户，穿梭时间表，折扣代码等等。- 在会议之前或会议期间改变。强制一个应用升级更新是不可行的，我们只想让应用内默认值可以更新。使用远程配置很容易的就为我们解决了这个问题。</p><p>在最后，我们最终得到一个三层系统，通知用户有关变更:</p><blockquote><ul><li>会议数据和用户数据的改变是来源于云消息和数据同步(ping和fetch模型)去进行通信。</li></ul></blockquote><blockquote><ul><li>Feed数据的变化是来源于RTDB的控制</li></ul></blockquote><blockquote><ul><li>更改应用内的产量来源于远程配置的控制</li></ul></blockquote><h2 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h2><p>即使我们正在发布2017的代码，我们在未来几个月仍然有工作领先于我们，我们将在后台进程(并使我们的应用程序“O”符合)中去更新代码去遵循现代模式。并且在未来，我们将采用Android的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL2FyY2hpdGVjdHVyZS9pbmRleC5odG1s" title="https://developer.android.com/topic/libraries/architecture/index.html">架构组件<i class="fa fa-external-link"></i></span>去简化应用程序的整体设计，开发者可以按照<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9pb3NjaGVk" title="https://github.com/google/iosched">GitHub<i class="fa fa-external-link"></i></span>上的代码进行更改。</p><blockquote><p>以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://android-developers.googleblog.com/2017/08/google-releases-source-for-google-io.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google releases source for Google I/O 2017 for Android&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们发布官方&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.google.samples.apps.iosched&amp;amp;hl=en&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google I/O 2017&lt;/a&gt; Android应用程序&lt;a href=&quot;https://github.com/google/iosched&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今年这个应用基本上修改了现有的功能，并且添加了一些新的功能。它也利用了&lt;a href=&quot;https://firebase.google.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Firebase&lt;/a&gt;去拓展技术堆栈。在这篇文章中，我们将高亮在这个应用程序的几个显著变化，以及它们设计的注意实事项。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Google I/O" scheme="https://shoewann0402.github.io/categories/Android/Google-I-O/"/>
    
    
      <category term="Android" scheme="https://shoewann0402.github.io/tags/Android/"/>
    
      <category term="Google I/O" scheme="https://shoewann0402.github.io/tags/Google-I-O/"/>
    
      <category term="source code" scheme="https://shoewann0402.github.io/tags/source-code/"/>
    
  </entry>
  
  <entry>
    <title>Android O开发者预览版4可用,官方Android O即将到来！</title>
    <link href="https://shoewann0402.github.io/2017/07/25/developer-preview-4-now-available/"/>
    <id>https://shoewann0402.github.io/2017/07/25/developer-preview-4-now-available/</id>
    <published>2017-07-25T06:00:03.000Z</published>
    <updated>2019-03-11T09:33:32.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8wNy9kZXZlbG9wZXItcHJldmlldy00LW5vdy1hdmFpbGFibGUuaHRtbA==" title="https://android-developers.googleblog.com/2017/07/developer-preview-4-now-available.html">Developer Preview 4 now available, official Android O coming soon!<i class="fa fa-external-link"></i></span></p></blockquote><p>当我们在Android O平台上完成最后的首尾工作时，我们在今天推出了开发者预览版4去帮助您确保您的应用程序已经准备好了。</p><p>这个版本是我们<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9taWdyYXRpb24uaHRtbA==" title="https://developer.android.com/preview/migration.html">在今年夏天晚些时候<i class="fa fa-external-link"></i></span>为消费者启动官方Android O平台之前的最后一个预览版本，借此机会去尽快结束您的测试并发布您的更新，给用户一个平稳过渡到Android O</p><a id="more"></a><p>如果您有一个设备已经在<span class="exturl" data-url="aHR0cDovL3d3dy5hbmRyb2lkLmNvbS9iZXRh" title="http://www.android.com/beta">Android Beta Program<i class="fa fa-external-link"></i></span>上面注册了，您将会在接下来的几天收到一个到开发者预览版4的更新升级。如果您还没有注册您的设备，仅仅访问<span class="exturl" data-url="aHR0cDovL3d3dy5hbmRyb2lkLmNvbS9iZXRh" title="http://www.android.com/beta">Android Beta 站点<i class="fa fa-external-link"></i></span>去注册并获取更新升级。</p><p>在即将到来的Android O 正式发布版本上查看更多信息！！！</p><h1 id="这次升级了什么？"><a href="#这次升级了什么？" class="headerlink" title="这次升级了什么？"></a>这次升级了什么？</h1><p>开发者预览版4是Android O的发布候选版本，您能够使用它及时为即将发布的官方版本发布完成您的开发和测试。它包括了最终版本的系统行为、bug修复和优化，最终版的APIs(Api Level 26)已经在<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8wNi9hbmRyb2lkLW8tYXBpcy1hcmUtZmluYWwtZ2V0LXlvdXItYXBwcy5odG1s" title="https://android-developers.googleblog.com/2017/06/android-o-apis-are-final-get-your-apps.html">开发者预览版3<i class="fa fa-external-link"></i></span>上面可以使用了。</p><p>今天我们发布了开发者预览版4设备系统镜像，并和正式版的Android 26.0.0支持库。在接下来的几天的路上增加了SDK的更新升级、tools和Android模拟器系统进行。</p><p>我们也介绍了一个新版本的<span class="exturl" data-url="aHR0cDovL2RldmVsb3BlcnMuYW5kcm9pZC5jb20vdGVzdGluZw==" title="http://developers.android.com/testing">Android测试支持库<i class="fa fa-external-link"></i></span>，包括了像Android Test Orchestrator,多进程 Espresso以及更多的新特性。查看详细即将到来。</p><h1 id="在Android-O上测试您的应用"><a href="#在Android-O上测试您的应用" class="headerlink" title="在Android O上测试您的应用"></a>在Android O上测试您的应用</h1><p>今天开发者预览版4系统镜像给您了一个优秀的方式在接近于最终版本的Android O上面去测试您当前的应用。通过现在的测试，您能够确保您的应用提供您想作为一个用户开始去升级到官方Android O平台的体验。</p><p>在<span class="exturl" data-url="aHR0cDovL2FuZHJvaWQuY29tL2JldGE=" title="http://android.com/beta">Android Beta Program<i class="fa fa-external-link"></i></span>上面去注册一个以支持的设备，并在今天通过OTA云端升级的方式获取更新，从Google play安装您当前的应用程序，并测试用户流。应用程序应该能够运行并且看起来很棒，您应该处理Android O的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9iZWhhdmlvci1jaGFuZ2VzLmh0bWw=" title="https://developer.android.com/preview/behavior-changes.html">行为变化<i class="fa fa-external-link"></i></span>配置——在特定，特别要注意<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9iZWhhdmlvci1jaGFuZ2VzLmh0bWwjYWJsbA==" title="https://developer.android.com/preview/behavior-changes.html#abll">后台位置限制<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy9ub3RpZmljYXRpb24tY2hhbm5lbHMuaHRtbA==" title="https://developer.android.com/preview/features/notification-channels.html">通知渠道<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9iZWhhdmlvci1jaGFuZ2VzLmh0bWwjbmV0d29ya2luZy1hbGw=" title="https://developer.android.com/preview/behavior-changes.html#networking-all">网络<i class="fa fa-external-link"></i></span>的改变、<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9iZWhhdmlvci1jaGFuZ2VzLmh0bWwjc2VjdXJpdHktYWxs" title="https://developer.android.com/preview/behavior-changes.html#security-all">安全<i class="fa fa-external-link"></i></span>以及<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9iZWhhdmlvci1jaGFuZ2VzLmh0bWwjcHJpdmFjeS1hbGw=" title="https://developer.android.com/preview/behavior-changes.html#privacy-all">标示符<i class="fa fa-external-link"></i></span>。</p><p>一旦您解决了任意问题，利用当前目标等级发布您的应用更新，以便用户他们在接收到Android O的时候可以使用。</p><h1 id="利用Android-O特性和APIs提高您的应用"><a href="#利用Android-O特性和APIs提高您的应用" class="headerlink" title="利用Android O特性和APIs提高您的应用"></a>利用Android O特性和APIs提高您的应用</h1><p>用户在运行最新版本的Android,在下载应用程序、消费内容，并进行购买方面通常是最活跃的。他们也是对于在他们喜欢的应用关于支持最新版本Android特性发声最多的。利用Android O,用户期待着像<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy9ub3RpZmljYXRpb24tY2hhbm5lbHMuaHRtbA==" title="https://developer.android.com/preview/features/notification-channels.html">通知渠道<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy9ub3RpZmljYXRpb24tYmFkZ2VzLmh0bWw=" title="https://developer.android.com/preview/features/notification-badges.html">点<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy9waW5uaW5nLXNob3J0Y3V0cy13aWRnZXRzLmh0bWw=" title="https://developer.android.com/preview/features/pinning-shortcuts-widgets.html">快捷方式固定<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9hcGktb3ZlcnZpZXcuaHRtbCNvcGlw" title="https://developer.android.com/preview/api-overview.html#opip">画中画<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy9hdXRvZmlsbC5odG1sI29wdGltaXppbmdfeW91cl9hcHBfZm9yX2F1dG9maWxs" title="https://developer.android.com/preview/features/autofill.html#optimizing_your_app_for_autofill">自动填充<i class="fa fa-external-link"></i></span>以及其他。这些特性也能随着时间的推移，更多用户升级到Android O，有助于增加与应用的互动。</p><p><img src="/images/android-o-dp-4-2.gif" alt="android-o-dp-4-2"></p><p><img src="/images/android-o-dp-4-3.gif" alt="android-o-dp-4-3"></p><p>利用Android的特性提高您的应用程序能够帮助您推动和用户的互动，提供新的互动，给他们更多的控制和安全，并提高性能，功能特性像<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy9hZGFwdGl2ZS1pY29ucy5odG1s" title="https://developer.android.com/preview/features/adaptive-icons.html">图标适配<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy9kb3dubG9hZGFibGUtZm9udHMuaHRtbA==" title="https://developer.android.com/preview/features/downloadable-fonts.html">可下载字体<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy9hdXRvc2l6aW5nLXRleHR2aWV3Lmh0bWw=" title="https://developer.android.com/preview/features/autosizing-textview.html">自动大小的文本控件<i class="fa fa-external-link"></i></span>能够简化您的开发和最小化您的APK大小。电池对于用户也是一个最关心的，因此他们将欣赏您的应用程序已经对于<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy9iYWNrZ3JvdW5kLmh0bWw=" title="https://developer.android.com/preview/features/background.html">后台执行限制<i class="fa fa-external-link"></i></span>进行了优化，和其他<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9iZWhhdmlvci1jaGFuZ2VzLmh0bWwjby1hcHBz" title="https://developer.android.com/preview/behavior-changes.html#o-apps">O应用程序的重要系统行为的变化<i class="fa fa-external-link"></i></span>。</p><p>访问<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9pbmRleC5odG1s" title="https://developer.android.com/preview/index.html">O开发者预览站点<i class="fa fa-external-link"></i></span>去学习关于所有的新特性以及API，并如何编译它们到您的应用程序中。</p><h1 id="利用Android-Studio-加速您的开发"><a href="#利用Android-Studio-加速您的开发" class="headerlink" title="利用Android Studio 加速您的开发"></a>利用Android Studio 加速您的开发</h1><p>当您已经准备去构建Android O了，我们建议您升级到最新版的<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8wNS9hbmRyb2lkLXN0dWRpby0zLTAtY2FuYXJ5MS5odG1s" title="https://android-developers.googleblog.com/2017/05/android-studio-3-0-canary1.html">Android Studio 3.0<i class="fa fa-external-link"></i></span>,从<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3ByZXZpZXcvaW5kZXguaHRtbA==" title="https://developer.android.com/studio/preview/index.html">canary 通道<i class="fa fa-external-link"></i></span>下载可用。除了从<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3ByZXZpZXcvZmVhdHVyZXMvYW5kcm9pZC1wcm9maWxlci5odG1s" title="https://developer.android.com/studio/preview/features/android-profiler.html">性能分析工具<i class="fa fa-external-link"></i></span>去提高应用程序，支持<span class="exturl" data-url="aHR0cDovL2FuZHJvaWQtZGV2ZWxvcGVycy5nb29nbGVibG9nLmNvbS8yMDE3LzA1L2FuZHJvaWQtYW5ub3VuY2VzLXN1cHBvcnQtZm9yLWtvdGxpbi5odG1s" title="http://android-developers.googleblog.com/2017/05/android-announces-support-for-kotlin.html">Kotlin程序语言<i class="fa fa-external-link"></i></span>,并且Gradle构建优化，Android Studio3.0利用<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8wNS9hbmRyb2lkLWluc3RhbnQtYXBwcy1pcy1vcGVuLXRvLWFsbC5odG1s" title="https://android-developers.googleblog.com/2017/05/android-instant-apps-is-open-to-all.html">即时应用<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy93b3JraW5nLXdpdGgtZm9udHMuaHRtbA==" title="https://developer.android.com/preview/features/working-with-fonts.html">XML字体<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy9kb3dubG9hZGFibGUtZm9udHMuaHRtbA==" title="https://developer.android.com/preview/features/downloadable-fonts.html">可下载字体<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWF0dXJlcy9hZGFwdGl2ZS1pY29ucy5odG1s" title="https://developer.android.com/preview/features/adaptive-icons.html">图标适配<i class="fa fa-external-link"></i></span>使它开发起来更方便。</p><p>我们也建议升级到正式版的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdG9waWMvbGlicmFyaWVzL3N1cHBvcnQtbGlicmFyeS9yZXZpc2lvbnMuaHRtbA==" title="https://developer.android.com/topic/libraries/support-library/revisions.html">Android支持库26.0.0<i class="fa fa-external-link"></i></span>,现在从<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL2J1aWxkL2RlcGVuZGVuY2llcy5odG1sI2dvb2dsZS1tYXZlbg==" title="https://developer.android.com/studio/build/dependencies.html#google-maven">Google的Maven仓库<i class="fa fa-external-link"></i></span>到最新版本的SDK和工具以及模拟器系统镜像可用，在接下来的这几天可用了。</p><p>您能够升级您的项目的编译SDK版本到API 26去针对官方Android O API进行编译。我们也建议的您升级您的应用程序的目标sdk版本到API 26去选择和测试您的应用与Android O具体的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9iZWhhdmlvci1jaGFuZ2VzLmh0bWw=" title="https://developer.android.com/preview/behavior-changes.html">行为更改<i class="fa fa-external-link"></i></span>。对于如何设置环境去使用Android O进行编译查看详细的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9taWdyYXRpb24uaHRtbCNiZmE=" title="https://developer.android.com/preview/migration.html#bfa">迁移指南<i class="fa fa-external-link"></i></span>。</p><h1 id="发布您的应用升级到Google-Play"><a href="#发布您的应用升级到Google-Play" class="headerlink" title="发布您的应用升级到Google Play"></a>发布您的应用升级到Google Play</h1><p>Google Play对于应用程序针对编译或者目标API 26是开启的，当您准备好了，您就能够发布您的APK更新升级到您的alpha、beta或者产品通道。</p><p>确保您升级的应用运行在Android O上的和您之前的旧版本一样好。我们建议您使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vZGlzdHJpYnV0ZS9lbmdhZ2UvYmV0YS5odG1s" title="https://developer.android.com/distribute/engage/beta.html">Google Play的beta测试特性<i class="fa fa-external-link"></i></span>去从一个小部分用户获取最早的反馈。然后做一个分阶段的推出。我们期待看到您的应用更新！</p><h1 id="如何获取开发者预览版4"><a href="#如何获取开发者预览版4" class="headerlink" title="如何获取开发者预览版4"></a>如何获取开发者预览版4</h1><p>如果您还没有准备好，获取开发者预览版4是很简单的！只需要访问<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLmNvbS9iZXRh" title="https://android.com/beta">android.com/beta<i class="fa fa-external-link"></i></span>并选择您已经注册的手机或者平板。和往常一样，您也能够下载和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9kb3dubG9hZC5odG1s" title="https://developer.android.com/preview/download.html">手动刷入这个升级<i class="fa fa-external-link"></i></span>。Android O 开发者预览版是对于Pixel, Pixel XL, Pixel C, Nexus 5X, Nexus 6P, Nexus Player以及Android模拟器可用。当我们发布官方Android O版本的时候，已注册的设备将会自动更新。</p><p>感谢您在整个预览中的所有投入，继续去分享您的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcHJldmlldy9mZWVkYmFjay5odG1s" title="https://developer.android.com/preview/feedback.html">反馈和请求<i class="fa fa-external-link"></i></span>,我们很爱它！</p><blockquote><p>以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://android-developers.googleblog.com/2017/07/developer-preview-4-now-available.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Developer Preview 4 now available, official Android O coming soon!&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我们在Android O平台上完成最后的首尾工作时，我们在今天推出了开发者预览版4去帮助您确保您的应用程序已经准备好了。&lt;/p&gt;
&lt;p&gt;这个版本是我们&lt;a href=&quot;https://developer.android.com/preview/migration.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在今年夏天晚些时候&lt;/a&gt;为消费者启动官方Android O平台之前的最后一个预览版本，借此机会去尽快结束您的测试并发布您的更新，给用户一个平稳过渡到Android O&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="Android O" scheme="https://shoewann0402.github.io/categories/Android/Android-O/"/>
    
      <category term="Android Studio" scheme="https://shoewann0402.github.io/categories/Android/Android-O/Android-Studio/"/>
    
    
      <category term="Android O" scheme="https://shoewann0402.github.io/tags/Android-O/"/>
    
      <category term="AndroidO" scheme="https://shoewann0402.github.io/tags/AndroidO/"/>
    
      <category term="Developer Preview" scheme="https://shoewann0402.github.io/tags/Developer-Preview/"/>
    
      <category term="Android O Developer Preview" scheme="https://shoewann0402.github.io/tags/Android-O-Developer-Preview/"/>
    
      <category term="DP4" scheme="https://shoewann0402.github.io/tags/DP4/"/>
    
  </entry>
  
  <entry>
    <title>Android Things Hackster社区</title>
    <link href="https://shoewann0402.github.io/2017/07/01/android-things-hackster-community/"/>
    <id>https://shoewann0402.github.io/2017/07/01/android-things-hackster-community/</id>
    <published>2017-07-01T00:06:34.000Z</published>
    <updated>2019-03-11T09:33:32.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自: <span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLWRldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAxNy8wNi9hbmRyb2lkLXRoaW5ncy1oYWNrc3Rlci1jb21tdW5pdHkuaHRtbA==" title="https://android-developers.googleblog.com/2017/06/android-things-hackster-community.html">Android Things Hackster Community<i class="fa fa-external-link"></i></span></p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdGhpbmdzL2luZGV4Lmh0bWw=" title="https://developer.android.com/things/index.html">Android Things<i class="fa fa-external-link"></i></span>通过提供相同的Android开发工具、一流的Android框架和Google APIs使开发者在移动设备上取得成功，建立连接到嵌入式设备更加容易。自从12月初启动了预览版，社区已经将一些惊人的想法转变成了使用平台上面令人兴奋的原型。</p><a id="more"></a><p>对于使这些制作者和开发者能够使用Android Things去分享和相互学习，我们与<span class="exturl" data-url="aHR0cHM6Ly9oYWNrc3Rlci5pby8=" title="https://hackster.io/">Hackster.io<i class="fa fa-external-link"></i></span>合作去创建一个社区，有志向的物联网开发者能够去展示他们的项目并通过其他人的工作获得启发。Hackster.io是一个有20万工程师和开发者的社区，专门去构建硬件连接互联网的项目。他们也通过直播研讨会设计比赛寻求教育和挑战成员。</p><p>我们急切的想看到你提出来的项目。更重要的是，我们是很兴奋的去看到你的工作怎么样启发其他开发者用Android Things去创建一些很棒的东西。访问我们<span class="exturl" data-url="aHR0cHM6Ly9oYWNrc3Rlci5pby9nb29nbGU=" title="https://hackster.io/google">Hackster.io社区<i class="fa fa-external-link"></i></span>去看一下其他人已经构建好了的惊人的项目，并在今天加入社区！</p><p><img src="/images/android-things-hackster-io-page.png" alt="android-things-hackster-io-page.png"></p><h2 id="Android-Things-在线研讨会"><a href="#Android-Things-在线研讨会" class="headerlink" title="Android Things 在线研讨会"></a>Android Things 在线研讨会</h2><p>2017年7月7日上午10点，我们将和Hackster.io合作主持一场名为<strong>Android Things引导物联网产品</strong>的在线研讨会。在此期间，你将学习到我们如何设计Android Things，去解决尝试构建物联网产品的开发者遇到的许多痛苦的经历。你将也就机会去发送有关平台和生态系统的问题，<span class="exturl" data-url="aHR0cHM6Ly9hdHRlbmRlZS5nb3Rvd2ViaW5hci5jb20vcmVnaXN0ZXIvMzc3MjQ5OTU0NTA0OTE2NzEwNw==" title="https://attendee.gotowebinar.com/register/3772499545049167107">今天注册<i class="fa fa-external-link"></i></span>加入我们这个激动人心的活动！</p><blockquote><p>以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自: &lt;a href=&quot;https://android-developers.googleblog.com/2017/06/android-things-hackster-community.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Things Hackster Community&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/things/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Things&lt;/a&gt;通过提供相同的Android开发工具、一流的Android框架和Google APIs使开发者在移动设备上取得成功，建立连接到嵌入式设备更加容易。自从12月初启动了预览版，社区已经将一些惊人的想法转变成了使用平台上面令人兴奋的原型。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://shoewann0402.github.io/categories/Android/"/>
    
      <category term="AndroidThings" scheme="https://shoewann0402.github.io/categories/Android/AndroidThings/"/>
    
      <category term="IoT" scheme="https://shoewann0402.github.io/categories/Android/AndroidThings/IoT/"/>
    
    
      <category term="Android Things" scheme="https://shoewann0402.github.io/tags/Android-Things/"/>
    
      <category term="IoT" scheme="https://shoewann0402.github.io/tags/IoT/"/>
    
      <category term="hackster" scheme="https://shoewann0402.github.io/tags/hackster/"/>
    
  </entry>
  
</feed>
