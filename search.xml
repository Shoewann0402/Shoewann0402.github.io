<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 11 (R) 分区存储]]></title>
    <url>%2F2020%2F03%2F17%2Fandroid-R-scoped-storage%2F</url>
    <content type="text"><![CDATA[Android 在 Q 上引入了分区存储，对外部存储访问收拢了宽裕的权限，对存储数据文件的读写进行了限制，那么 Android R 上又有哪些变化呢 ? 本文就让我们一起来了解一下 , Let’s go ~ 讲 R 上分区存储变化之前，我们先来回顾一下 Q 上相关内容 Android 10 / Q 先回顾Android中存储可以分为两大类: 私有存储和共享存储 私有存储 (Private Storage) : 每个应用在内部存储种都拥有自己的私有目录(/data/data/packageName)，其它应用看不到，彼此也无法访问到该目录 共享存储 (Shared Storage) : 除了私有存储以外，其他的一切都被认定是共享存储，比如媒体集 (Media Collection) 和 SD卡外部应用存储目录 一、导火线在分区存储之前，某些应用中，即使功能很简单，大部分都不需要这么宽泛的权限。这就使得某些应用程序 1、乱占空间 ：各种各样的文件散布在磁盘的各个地方，当用户卸载应用之后，这些被遗弃的 “孤儿“ 被滞留在原地，无家可归，占用了磁盘空间，最终结果就会导致磁盘不足2、随意读取用户的数据3、随意读取应用的数据 因此 —— 分区存储 Baby 诞生了 ~ 它的降临 , 限制了过于宽泛的 存储权限 成长的同时, 在 Android 10 / Q 上它需要遵循三个原则 ： 更好的文件属性 : 系统应用知道什么文件属于哪一个app,让用户更加容易管理他们自己的文件。当app被卸载了，被应用创建的内容，除非用户希望保留，否则不应该保留下来。 用户的数据安全 ：当用户下载文件，比如敏感的电子邮件附件，这些文件对大多数应用程序都不应该可见 应用的数据安全 ：当app将特定于应用程序的文件写入外部存储时，其他应用程序不应该可见这些文件 二、规则点 应用访问自己的应用目录不受限制 ( 包括内部和外部 ) 无需任何权限 应用向媒体集和下载目录提供文件，如果您要想保存图片、视频、音频、文档，无需任何权限 不再提供宽泛的共享存储 ( Share Storage ), 读写存储权限只能访问提供的媒体集 ( 图片集、视频集、音频集 ) 位置元数据限制，获取图片上的位置等信息需要请求权限，如果不请求权限，读取图片的信息的时候，位置元数据将会被删除 读取PDF或其他类型的文件，需要调用系统的文件选择器 ( Storage Access Framerwork API ) 在媒体集或应用目录之外，写任何文件都需要系统的文件选择器, 这样用户能选择并确认将文件存在哪里 requestLegacyExternalStorage 开关值，在清单文件配置,如果开启了，存储权限就会像之前版本中的Android一样运作 三、详细说明1. 媒体文件集 用于和其它应用分享媒体文件(图片、音频、视频文件) Android 10 中，自己的App无需任何权限就能向媒体集添加文件，同时您也可以编辑和删除您自己添加的媒体文件。 如果你要读取并操作并非您的应用所创建的媒体文件，就需要读取外部存储权限，如果用户没有同意，您的应用将无法编辑和删除并非您的应用所创建的媒体文件。 这样一来，您的应用想编辑和删除媒体文件时，用户就能获得完整的控制权 2. 下载文件集 用于和其它应用分享非媒体文件(非图片、非音频、非视频文件) 下载文件集，和媒体文件集一样，您无需请求任何权限就能在这个集中添加、编辑、删除非媒体文件。 与媒体文件不同的是，即使有读取外部存储权限, 也是不允许您访问由其他应用创建添加的非媒体文件。想要取得权限，您需要通过调用 Storage Access Framerwork API，启动系统文件选择器，让用户可以进行选择可以访问哪些文件和目录。 如果用户允许您访问一个文件，那么这个权限将是完整的权限，你无需其他额外的任何权限，就可以任意的读取、编辑删除媒体文件和非媒体文件。 这样一来，用户就能获得完整的控制权，更好的管理应用在何时访问敏感的非媒体文件 3. 限制位置元数据 对媒体文件中敏感的元数据进行了访问权限的限制，主要限制位置元数据 可以在应用获取那些其他应用创建添加的媒体文件的时候，直接删除这些元数据 如果想要获取图片的位置信息，需要声明请求权限 ACCESS_MEDIA_LOCATION ，用户在Settings UI里看不到这个权限, 但是它属于运行时权限，所以必须要在Manifest里声明该权限 , 并在运行时同时请求该权限和读取外部存储权限 MediaStore.setRequireOriginal() : 获取当前磁盘的体积容量 4. 媒体文件访问路径 Android 10 锁定了公共目录文件路径的权限。 所有的应用都尽量继续使用MediaStore，因为后台文件路径 [ /sdcard/DCIM/xxx.JPG ] 请求或使用文件路径[ /sdcard/DCIM/xxx.JPG ]进行I/O流请求都是代理给 MediaStore 类的 不建议直接使用媒体文件访问路径 [ /sdcard/DCIM/xxx.JPG ] ，应用的性能会略有下降 5. MediaStore 的强制性 文件需要在适当的目录进行创建， 媒体文件需要媒体目录进行创建, 不能在图片目录创建音频文件，如果您想访问由其他应用创建的媒体文件，您就要请求外部存储读取权限。如果您没有获得媒体位置权限，就仍然会在读取由其他应用创建的媒体文件时，被系统拿掉位置信息。 当然，非媒体文件必须在Downloads下创建，所有Dowonloads目录下也只能创建像PDF或其它的非媒体文件 读取由其他应用创建的非媒体文件，也将需要 Storage Access Framerwork API 四、总结 特定于应用的目录 –&gt; 无需权限 –&gt; 访问方法 getExternalFilesDir() –&gt; 卸载应用时移除文件 媒体集合(照片、视频、音频) –&gt; 需要权限READ_EXTERNAL_STORAGE(仅当访问其他应用的文件时) –&gt; 访问方法 MediaStore –&gt; 卸载应用时不移除文件 下载内容（文档和电子书籍）–&gt; 无需权限 –&gt; 存储访问框架（加载系统的文件选择器）–&gt;卸载应用时不移除文件 Android R 再出发一、变化1. 分区存储强制执行requestLegacyExternalStorage 是为了给开发人员更多的测试时间，在Android 10上设置的一个开关值 在 Android 11 上发生了变更 目标版本 API &lt; = 29 时, 应用仍可请求 requestLegacyExternalStorage 属性。应用可以利用此标记暂时停用与分区存储相关的变更，例如授予对不同目录和不同类型的媒体文件的访问权限。 目标版本 API &gt; 29，将无法使用 requestLegacyExternalStorage，而且也没有其他标记可以提供该停用功能。 2. 媒体文件访问权限为了在保证用户隐私的同时可以更轻松地访问媒体，Android 11 增加了以下功能。 (1) 执行批量操作 MediaStore API 新增方法 方法 说明 createWriteRequest (ContentResolver, Collection) 用户向应用授予对指定媒体文件组的写入访问权限的请求。 createFavoriteRequest (ContentResolver, Collection, boolean) 用户将设备上指定的媒体文件标记为“收藏”的请求。对该文件具有读取访问权限的任何应用都可以看到用户已将该文件标记为“收藏”。 createTrashRequest (ContentResolver, Collection, boolean) 用户将指定的媒体文件放入设备垃圾箱的请求。垃圾箱中的内容在特定时间段（默认为 7 天）后会永久删除。 createDeleteRequest (ContentResolver, Collection) 用户立即永久删除指定的媒体文件（而不是先将其放入垃圾箱）的请求。 系统在调用以上任何一个方法后，会构建一个 PendingIntent 对象。应用调用此 intent 后，用户会看到一个对话框，请求用户同意应用更新或删除指定的媒体文件。 (2) 使用原始路径访问文件 从 Android 11 开始，具有 READ_EXTERNAL_STORAGE 权限的应用可以使用直接文件路径（如： /sdcard/DCIM/xxx.JPG` 的格式）和原生库来读取设备的媒体文件。通过这项新功能，应用可以更顺畅地使用第三方媒体库。 注意：使用直接路径和原生库保存媒体文件时，应用的性能会略有下降。请尽可能改用 MediaStore API。 (3) 测试原始文件路径访问 要激活此功能以进行测试，请执行以下操作： 打开系统设置。 导航到 系统 &gt; 开发者选项 &gt; 功能标记。 找到 settings_fuse 并启用。settings_fuse 下的说明现在应显示为 true。 重启设备。 3. 文件和目录访问限制以下是存储访问框架 ( SAF: Storage Access Framerwork API ) 相关的变更 (1) 访问目录您无法再使用 ACTION_OPEN_DOCUMENT_TREE intent 操作来请求访问以下目录： Downloads 根目录 设备制造商认为可靠的各个 SD 卡卷的根目录，无论该卡是模拟卡还是可移除的卡。 (2) 访问文件您无法再使用 ACTION_OPEN_DOCUMENT_TREE 或 ACTION_OPEN_DOCUMENT intent 操作来请求用户从以下目录中选择单独的文件： Android/data/ 目录及其所有子目录。 Android/obb/ 目录及其所有子目录 (3) 测试变更要测试此行为变更，请在应用的清单文件中将 requestLegacyExternalStorage 的值设置为 false。您可通过执行以下操作来确认行为变更是否已对应用生效： 通过 ACTION_OPEN_DOCUMENT_TREE 操作调用 intent。检查 Downloads 目录是否显示并呈灰显状态。 通过 ACTION_OPEN_DOCUMENT 操作调用 intent。检查 Android/data/ 和 Android/obb/ 目录是否都不显示。 4. 权限 在 Android 11 上，您会看到两种权限请求的字符串，这个取决于应用的目标 SDK 版本, 如果目标版本在 Android 11，那么只请求在外部存储中访问媒体文件，如果是其他目标版本,那么将显示的是旧版本的权限请求字符串 (1) 以任何版本为目标平台不管应用的目标 SDK 版本是什么，以下变更均会在 Android 11 中生效： 存储 运行时权限已重命名为 文件 和 媒体。 如果应用未选择停用分区存储，并且请求 READ_EXTERNAL_STORAGE 权限，则用户会看到不同于 Android 10 的对话框。该对话框会指示应用正在请求访问照片、视频、音频剪辑和文件。在系统设置的设置 &gt; 隐私 &gt; 权限管理器 &gt; 文件和媒体页面中，如果已授予权限，应用会列在允许存储所有文件下。 (2) 以 Android 11 为目标平台则 WRITE_EXTERNAL_STORAGE 权限和 WRITE_MEDIA_STORAGE特许权限将不再提供任何其他访问权限。 5. 所有文件访问权限像文件管理操作或备份和还原操作等需要访问大量的文件,通过执行以下操作，这些应用可以获得”所有文件访问权限”： 声明 MANAGE_EXTERNAL_STORAGE 权限 将用户引导至系统设置页面，在该页面上，用户可以对应用启用授予所有文件的管理权限选项 简单说，像这种文件管理器、备份及存储类应用。你需要在 Google Play Developer Console上填写声明表格说明为什么需要改权限，提交之后会被审核是否加入白名单，一旦加入成功以后，您的应用就可以向用户索要权限了，如果用户也同意您应用的访问权限请求，MadiaStore 访问将不再过滤，包括非媒体库文件。但是获得此权限的应用仍然无法访问这些目录在存储卷上显示为 Android/data/的子目录，也就是属于其他应用的应用专属目录。 MANAGE_EXTERNAL_STORAGE 权限允许应用访问共享的存储空间中的潜在敏感数据。 二、示例 按照上面 Q ~ R 这一些列规则点，我们可以将示例进行分类如下 按照系统版本分类：Android Q 、 Android R 按照分区存储分类：媒体文件集 、下载文件集、App应用程序专属特定目录 按照文件归属分类：自己应用和其他应用 按照文件类型分类：媒体集（图片、视频、音频 .etc）、非媒体（PDF,DOC,XLS .etc） 按照操作行为分类：增、删、改、查 那么接下来示例，我将会按照以上的5大分类，结合两个版本代码简单说明 然后呢？我们该怎么做？ 其实逻辑代码我们可以简化理解这么去定义 一个 Media 操作类：包括了（图片、视频、音频）他们3类分别的增、删、改、查 一个 Download 操作类：包括了非媒体的增、删、改、查 一个Assets操作类：负责从asset下拷贝文件到本地演示 开发环境： Android Studio 4.1 canary 2 Android R 模拟器 / 真机 Media 类[MyMediaCollection.kt] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454class MyMediaCollection &#123; //图片实体类 data class ImageBean( val uri: Uri, val name: String, val mimeType: String, val size: Int ) //视频实体类 data class VideoBean( val uri: Uri, val name: String, val mimeType: String, val duration: Int, val size: Int ) //音频实体类 data class AudioBean( val uri: Uri, val name: String, val mimeType: String, val duration: Int, val size: Int ) /** * Query [ 图片媒体集 ] 包括： DCIM/ 和 Pictures/ 目录 */ fun queryImageCollection(context: Context): MutableList&lt;ImageBean&gt; &#123; Log.d(TAG, "########### 图片媒体集 ############") val imageBeanList = mutableListOf&lt;ImageBean&gt;() //定义内容解析器 val contentResolver = context.contentResolver //指定查询的列名 val photoColumns = arrayOf( MediaStore.Images.Media._ID, MediaStore.Images.Media.TITLE, MediaStore.Images.Media.MIME_TYPE, MediaStore.Images.Media.SIZE ) val cursor = contentResolver.query( MediaStore.Images.Media.EXTERNAL_CONTENT_URI, //指定查询哪张表的URI photoColumns, // 指定查询的列明 null, //指定where的约束条件 null, //为where中的占位符提供具体的值 null // 指定查询结果的排序方式 ) val count = cursor!!.count Log.d(TAG, "imageCollection count: --&gt; $count") cursor.use &#123; while (cursor.moveToNext()) &#123; val id = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID)) val title = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.TITLE)) val mimeType = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.MIME_TYPE)) val size = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.SIZE)) val contentUri = ContentUris.withAppendedId( MediaStore.Images.Media.EXTERNAL_CONTENT_URI, cursor.getLong(cursor.getColumnIndex(BaseColumns._ID)) ) Log.d( TAG, "imageCollection id =$id\ntitle = $title\nmime_type: =$mimeType\nsize: =\t$size\ncontentUri: =\t$contentUri\n" ) val imageBean = ImageBean( uri = contentUri, name = title, mimeType = mimeType, size = size.toInt() ) imageBeanList += imageBean &#125; cursor.close() &#125; return imageBeanList &#125; /** * Query [ 视频媒体集 ] 包括： DCIM/, Movies/, 和 Pictures/ 目录 */ fun queryVideoCollection(context: Context): MutableList&lt;VideoBean&gt; &#123; Log.d(TAG, "########### 视频媒体集 ############") val videoBeanList = mutableListOf&lt;VideoBean&gt;() val contentResolver = context.contentResolver val videoColumns = arrayOf( MediaStore.Video.Media._ID, MediaStore.Video.Media.TITLE, MediaStore.Video.Media.DURATION, MediaStore.Video.Media.MIME_TYPE, MediaStore.Video.Media.SIZE ) val cursor = contentResolver.query( MediaStore.Video.Media.EXTERNAL_CONTENT_URI, videoColumns, null, null, null ) val count = cursor!!.count Log.d(TAG, "videoCollection count: --&gt; $count") cursor.use &#123; while (cursor.moveToNext()) &#123; val id = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media._ID)) val title = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.TITLE)) val mimeType = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.MIME_TYPE)) val duration = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DURATION)) val size = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.SIZE)) val contentUri = ContentUris.withAppendedId( MediaStore.Video.Media.EXTERNAL_CONTENT_URI, cursor.getLong(cursor.getColumnIndex(BaseColumns._ID)) ) Log.d( TAG, "imageCollection id =$id\ntitle = $title\nmime_type: =$mimeType\nduration=$duration\nsize: =\t$size\ncontentUri: =\t$contentUri\n" ) val videoBean = VideoBean( uri = contentUri, name = title, mimeType = mimeType, duration = duration, size = size ) videoBeanList += videoBean &#125; cursor.close() &#125; return videoBeanList &#125; /** * Query [ 音频媒体集 ] 包括： Alarms/, Audiobooks/, Music/, Notifications/, Podcasts/, 和 Ringtones/ 目录 * 以及 Music/ 和 Movies/ 目录中的音频文件 */ fun queryAudioCollection(context: Context): MutableList&lt;AudioBean&gt; &#123; Log.d(TAG, "########### 音频媒体集 ############") val audioBeanList = mutableListOf&lt;AudioBean&gt;() val contentResolver = context.contentResolver val videoColumns = arrayOf( MediaStore.Audio.Media._ID, MediaStore.Audio.Media.TITLE, MediaStore.Audio.Media.DURATION, MediaStore.Audio.Media.MIME_TYPE, MediaStore.Audio.Media.SIZE ) val cursor = contentResolver.query( MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, videoColumns, null, null, null ) val count = cursor!!.count Log.d(TAG, "audioCollection count: --&gt; $count") cursor.use &#123; while (cursor.moveToNext()) &#123; val id = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media._ID)) val title = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.TITLE)) val mimeType = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.MIME_TYPE)) val duration = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DURATION)) val size = cursor.getInt(cursor.getColumnIndexOrThrow(MediaStore.Video.Media.SIZE)) val contentUri = ContentUris.withAppendedId( MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, cursor.getLong(cursor.getColumnIndex(BaseColumns._ID)) ) Log.d( TAG, "audioCollection id =$id\ntitle = $title\nmime_type: =$mimeType\nduration=$duration\nsize: =\t$size\ncontentUri: =\t$contentUri\n" ) val audioBean = AudioBean( uri = contentUri, name = title, mimeType = mimeType, duration = duration, size = size ) audioBeanList += audioBean &#125; cursor.close() &#125; return audioBeanList &#125; /** * Insert [ 图片媒体集 ] */ fun insertImageToCollection(context: Context, disPlayName: String) &#123; Log.d( TAG, "insertImageToCollection() called with: context = $context, disPlayName = $disPlayName" ) val contentResolver = context.contentResolver //在主要外部存储设备上查找所有图片文件 (API &lt;= 28 使用 VOLUME_EXTERNAL 代替) val imageCollection = MediaStore.Images.Media.getContentUri( MediaStore.VOLUME_EXTERNAL_PRIMARY ) val contentValues = ContentValues().apply &#123; //配置图片的显示名称 put(MediaStore.Images.Media.DISPLAY_NAME, disPlayName) //配置图片的状态为：等待中... put(MediaStore.Images.Media.IS_PENDING, 1) &#125; //开始插入图片 val imageUri = contentResolver.insert(imageCollection, contentValues) imageUri.let &#123; contentResolver.openFileDescriptor(imageUri!!, "w", null).use &#123; AssetHelper.copyAssetSingleFileToMedia(context, disPlayName, it!!) contentValues.clear() contentValues.put(MediaStore.Images.Media.IS_PENDING, 0) contentResolver.update(imageUri, contentValues, null, null) it.close() &#125; &#125; &#125; /** * Insert [ 视频媒体集 ] */ fun insertVideoToCollection(context: Context, disPlayName: String) &#123; Log.d( TAG, "insertVideoToCollection() called with: context = $context, disPlayName = $disPlayName" ) val contentResolver = context.contentResolver //在主要外部存储设备上查找所有视频文件 (API &lt;= 28 使用 VOLUME_EXTERNAL 代替) val videoCollection = MediaStore.Video.Media.getContentUri( MediaStore.VOLUME_EXTERNAL_PRIMARY ) val contentValues = ContentValues().apply &#123; //配置视频的显示名称 put(MediaStore.Video.Media.DISPLAY_NAME, disPlayName) //配置视频的状态为：等待中... put(MediaStore.Video.Media.IS_PENDING, 1) &#125; //开始插入视频 val videoUri = contentResolver.insert(videoCollection, contentValues) videoUri.let &#123; contentResolver.openFileDescriptor(videoUri!!, "w", null).use &#123; AssetHelper.copyAssetSingleFileToMedia(context, disPlayName, it!!) contentValues.clear() contentValues.put(MediaStore.Video.Media.IS_PENDING, 0) contentResolver.update(videoUri, contentValues, null, null) it.close() &#125; &#125; &#125; /** * Insert [ 音频媒体集 ] */ fun insertAudioToCollection(context: Context, disPlayName: String) &#123; Log.d( TAG, "insertAudioToCollection() called with: context = $context, disPlayName = $disPlayName" ) val contentResolver = context.contentResolver //在主要外部存储设备上查找所有音频文件 (API &lt;= 28 使用 VOLUME_EXTERNAL 代替) val audioCollection = MediaStore.Audio.Media.getContentUri( MediaStore.VOLUME_EXTERNAL_PRIMARY ) val contentValues = ContentValues().apply &#123; //配置音频的显示名称 put(MediaStore.Audio.Media.DISPLAY_NAME, disPlayName) //配置音频的状态为：等待中... put(MediaStore.Audio.Media.IS_PENDING, 1) &#125; //开始插入音频 val audioUri = contentResolver.insert(audioCollection, contentValues) audioUri.let &#123; contentResolver.openFileDescriptor(audioUri!!, "w", null).use &#123; AssetHelper.copyAssetSingleFileToMedia(context, disPlayName, it!!) contentValues.clear() contentValues.put(MediaStore.Audio.Media.IS_PENDING, 0) contentResolver.update(audioUri, contentValues, null, null) it.close() &#125; &#125; &#125; /** * Update [ 图片媒体集 ] */ fun updateImageCollection(context: Context, id: Long, newName: String) &#123; val contentResolver = context.contentResolver val selection = "$&#123;MediaStore.Images.Media._ID&#125; = ?" val selectionArgs = arrayOf(id.toString()) val contentValues = ContentValues().apply &#123; put(MediaStore.Images.Media.DISPLAY_NAME, newName) &#125; val imageUri = ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id) imageUri.let &#123; context.contentResolver.openFileDescriptor(imageUri, "w")?.use &#123; val result = contentResolver.update(imageUri, contentValues, selection, selectionArgs) Log.d(TAG, "updateImageCollection() called : $result") &#125; &#125; &#125; /** * Update [ 视频媒体集 ] */ fun updateVideoCollection(context: Context, id: Long, newName: String) &#123; val contentResolver = context.contentResolver val selection = "$&#123;MediaStore.Video.Media._ID&#125; = ?" val selectionArgs = arrayOf(id.toString()) val contentValues = ContentValues().apply &#123; put(MediaStore.Video.Media.DISPLAY_NAME, newName) &#125; val videoUri = ContentUris.withAppendedId(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, id) videoUri.let &#123; context.contentResolver.openFileDescriptor(videoUri, "w")?.use &#123; val result = contentResolver.update(videoUri, contentValues, selection, selectionArgs) Log.d(TAG, "updateVideoCollection() called : $result") it.close() &#125; &#125; &#125; /** * Update [ 音频媒体集 ] */ fun updateAudioCollection(context: Context, id: Long, newName: String) &#123; val contentResolver = context.contentResolver val selection = "$&#123;MediaStore.Audio.Media._ID&#125; = ?" val selectionArgs = arrayOf(id.toString()) val contentValues = ContentValues().apply &#123; put(MediaStore.Audio.Media.DISPLAY_NAME, newName) &#125; val audioUri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id) audioUri.let &#123; context.contentResolver.openFileDescriptor(audioUri, "w")?.use &#123; val result = contentResolver.update(audioUri, contentValues, selection, selectionArgs) Log.d(TAG, "updateAudioCollection() called : $result") it.close() &#125; &#125; &#125; /** * Delete [ 图片媒体集 ] */ fun deleteImageCollection(context: Context, id: Long) &#123; val contentResolver = context.contentResolver val selection = "$&#123;MediaStore.Images.Media._ID&#125; = ?" val selectionArgs = arrayOf(id.toString()) val imageUri = ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id) imageUri.let &#123; context.contentResolver.openFileDescriptor(imageUri, "w")?.use &#123; val result = contentResolver.delete(imageUri, selection, selectionArgs) Log.d(TAG, "deleteImageCollection() called : $result") it.close() &#125; &#125; &#125; /** * Delete [ 视频媒体集 ] */ fun deleteVideoCollection(context: Context, id: Long) &#123; val contentResolver = context.contentResolver val selection = "$&#123;MediaStore.Video.Media._ID&#125; = ?" val selectionArgs = arrayOf(id.toString()) val videoUri = ContentUris.withAppendedId(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, id) videoUri.let &#123; context.contentResolver.openFileDescriptor(videoUri, "w")?.use &#123; val result = contentResolver.delete(videoUri, selection, selectionArgs) Log.d(TAG, "deleteVideoCollection() called : $result") it.close() &#125; &#125; &#125; /** * Delete [ 音频媒体集 ] */ fun deleteAudioCollection(context: Context, id: Long) &#123; val contentResolver = context.contentResolver val selection = "$&#123;MediaStore.Audio.Media._ID&#125; = ?" val selectionArgs = arrayOf(id.toString()) val audioUri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id) audioUri.let &#123; context.contentResolver.openFileDescriptor(audioUri, "w")?.use &#123; val result = contentResolver.delete(audioUri, selection, selectionArgs) Log.d(TAG, "deleteAudioCollection() called : $result") it.close() &#125; &#125; &#125; /** * 加载特定媒体文件的缩略图 */ fun loadThumbnail(context: Context, uri: Uri, width: Int, height: Int): Bitmap &#123; val size = Size(width, height) return context.contentResolver.loadThumbnail( uri, size, null ) &#125; /** * 获取图片位置元数据信息 */ fun getImageLocationMataData(context: Context, imageUri: Uri) &#123; // 获取位置数据使用 ExifInterface 库. // 如果 ACCESS_MEDIA_LOCATION 没有被授予，将会发生异常 val uri = MediaStore.setRequireOriginal(imageUri) context.contentResolver.openInputStream(uri)?.use &#123; ExifInterface(it).run &#123; //如果经纬度为Null，将会回退到坐标(0,0) this.latLong?.let &#123; Log.d(TAG, "getImageLocationMataData() called : Latitude = $&#123;latLong?.get(0)&#125;") Log.d(TAG, "getImageLocationMataData() called : Longitude = $&#123;latLong?.get(1)&#125;") &#125; &#125; &#125; &#125; companion object &#123; private const val TAG = "MyMediaCollection" &#125;&#125; Download 类[ MyDownloadCollection 。k ] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140class MyDownloadCollection &#123; /** * 访问目录 */ fun openDirectory(activity: Activity, requestCode: Int) &#123; Log.d(TAG, "openDirectory() called") val intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE).apply &#123; &#125; activity.startActivityForResult(intent, requestCode) &#125; /** * 访问文件 */ fun openDocument(activity: Activity, fileType: String, requestCode: Int) &#123; Log.d( TAG, "openDocument() called with: activity = $activity, fileType = $fileType, requestCode = $requestCode" ) val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply &#123; addCategory(Intent.CATEGORY_OPENABLE) type = fileType &#125; activity.startActivityForResult(intent, requestCode) &#125; /** * 创建文档 */ fun createDocument(activity: Activity, fileType: String, title: String, requestCode: Int) &#123; Log.d( TAG, "createDocument() called with: activity = $activity, fileType = $fileType, title = $title, requestCode = $requestCode" ) val intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply &#123; addCategory(Intent.CATEGORY_OPENABLE) type = fileType putExtra(Intent.EXTRA_TITLE, title) &#125; activity.startActivityForResult(intent, requestCode) &#125; /** * 写入数据 */ fun writeDataToDocument(context: Context, uri: Uri, content: String) &#123; Log.d( TAG, "writeDataToDocument() called with: context = $context, uri = $uri, content = $content" ) try &#123; context.contentResolver.openFileDescriptor(uri, "w").use &#123; parcelFileDescriptor -&gt; FileOutputStream(parcelFileDescriptor?.fileDescriptor).use &#123; fos -&gt; fos.write(content.toByteArray()) fos.close() parcelFileDescriptor?.close() &#125; &#125; &#125; catch (e: FileNotFoundException) &#123; e.printStackTrace() &#125; catch (e: IOException) &#123; e.printStackTrace() &#125; &#125; /** * 删除文档 */ fun deleteDocument(context: Context, uri: Uri) &#123; Log.d(TAG, "deleteDocument() called with: context = $context, uri = $uri") val result = DocumentsContract.deleteDocument(context.contentResolver,uri) Log.d(TAG, "deleteDocument() result = $result") &#125; /*** * 从 Uri中返回文本 */ private fun readTextFromUri(context: Context, uri: Uri): String &#123; val stringBuilder = StringBuilder() context.contentResolver.openInputStream(uri)?.use &#123; inputStream -&gt; BufferedReader(InputStreamReader(inputStream)).use &#123; reader -&gt; var line: String? = reader.readLine() while (line != null) &#123; stringBuilder.append(line) line = reader.readLine() &#125; &#125; &#125; return stringBuilder.toString() &#125; /** * 从 Uri中返回Bitmap */ @Throws(IOException::class) private fun getBitmapFromUri(context: Context, uri: Uri): Bitmap? &#123; val parcelFileDescriptor = context.contentResolver.openFileDescriptor(uri, "r") return BitmapFactory.decodeFileDescriptor(parcelFileDescriptor?.fileDescriptor) &#125; /** * 永久保存获取的目录权限 * APP申请到目录的永久权限后，用户可以在该APP的设置页面（清除缓存页面下）取消目录的访问权限 */ fun keepDocumentPermission(context: Context, uri: Uri, intent: Intent) &#123; val takeFlags: Int = intent.flags and (Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION) // 检查最新数据：文件是否被删除 context.contentResolver.takePersistableUriPermission(uri, takeFlags) // 通过sharePreference保存该目录Uri // --------- 省略 代码 -------- &#125; /** * 使用获得永久保存获取的目录权限 */ fun useKeepDocument(context: Context,saveUri: String,intent: Intent)&#123; if (TextUtils.isEmpty(saveUri)) &#123; // 打开目录, 重新请求永久保存获取的目录权限 // --------- 省略 代码 -------- &#125; else &#123; try &#123; val uri = Uri.parse(saveUri) val takeFlags: Int = intent.flags and (Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION) context.contentResolver.takePersistableUriPermission(uri, takeFlags) //Uri 授予，执行下一步操作 // --------- 省略 代码 -------- &#125; catch (e: SecurityException) &#123; //Uri 未被授予, 打开目录, 重新请求永久保存获取的目录权限 // --------- 省略 代码 -------- &#125; &#125; &#125; companion object &#123; private const val TAG = "MyDownloadCollection" &#125;&#125; Assets 帮助类 [ AssetHelper.kt ] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class AssetHelper &#123; companion object &#123; private const val TAG = "AssetHelper" /** * 复制单个文件的方法 */ fun copyAssetSingleFile(context: Context, fileName: String, savePath: File) &#123; Log.d( TAG, "copyAssetSingleFile() called with: context = $context, fileName = $fileName, savePath = $savePath" ) context.assets.open(fileName).use &#123; fis -&gt; FileOutputStream(savePath).use &#123; fos -&gt; FileUtils.copy(fis, fos) fos.close() fis.close() &#125; &#125; &#125; /** * 复制单个文件的方法 */ fun copyAssetSingleFileToMedia( context: Context, fileName: String, parcelFileDescriptor: ParcelFileDescriptor ) &#123; Log.d( TAG, "copyAssetSingleFile() called with: context = $context, fileName = $fileName, parcelFileDescriptor = $parcelFileDescriptor" ) context.assets.openFd(fileName).use &#123; fis -&gt; FileUtils.copy(fis.fileDescriptor, parcelFileDescriptor.fileDescriptor) parcelFileDescriptor.close() fis.close() &#125; &#125; /** * 复制多个文件的方法 */ fun copyAssetMultipleFile(context: Context, filePath: String, savePath: File) &#123; Log.d( TAG, "copyAssetMultipleFile() called with: context = $context, filePath = $filePath, savePath = $savePath" ) context.assets.list(filePath)?.let &#123; fileList -&gt; when (fileList.isNotEmpty()) &#123; true -&gt; &#123; for (i in fileList.indices) &#123; if (!savePath.exists()) savePath.mkdir() copyAssetMultipleFile( context, filePath + File.separator + fileList[i], File(savePath, fileList[i]) ) &#125; &#125; else -&gt; copyAssetSingleFile(context, filePath, savePath) &#125; &#125; &#125; &#125;&#125; MainActivity[ MainActivity.] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382class MainActivity : AppCompatActivity() &#123; @RequiresApi(10000) override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main2) initPermission() Log.d(TAG, "onCreate() called with: = $&#123;Build.VERSION.SDK_INT&#125;") //使用Kotlin 协程方式 btnStorage.setOnClickListener &#123; GlobalScope.launch &#123; //insertData() //updateData() //queryData() //updateOtherApp() //openDocument() //createDocument() deleteImages(this@MainActivity) &#125; &#125; &#125; /** * 添加媒体集数据 和 应用程序专属目录下数据 */ private suspend fun insertData() &#123; Log.d(TAG, "copyAssets() called : ### START ####") val dataFile = File(getExternalFilesDir(null), "data") val imageFile = File(getExternalFilesDir(Environment.DIRECTORY_PICTURES), "my_app_media_image.jpg") val videoFile = File(getExternalFilesDir(Environment.DIRECTORY_MOVIES), "my_app_media_video.mp4") val audioFile = File(getExternalFilesDir(Environment.DIRECTORY_MUSIC), "my_app_media_audio.mp3") val downloadFile = File(getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS), "my_app_download_file.pdf") withContext(Dispatchers.IO) &#123; //插入数据到应用程序专属特定目录系统整理目录下 AssetHelper.copyAssetSingleFile( this@MainActivity, "my_app_media_image.jpg", imageFile ) AssetHelper.copyAssetSingleFile( this@MainActivity, "my_app_media_video.mp4", videoFile ) AssetHelper.copyAssetSingleFile( this@MainActivity, "my_app_media_audio.mp3", audioFile ) AssetHelper.copyAssetSingleFile( this@MainActivity, "my_app_download_file.pdf", downloadFile ) // 插入数据到应用程序专属特定目录下自定义文件夹 AssetHelper.copyAssetMultipleFile(this@MainActivity, "data", dataFile) // 插入数据到媒体集 MyMediaCollection().insertImageToCollection( this@MainActivity, "my_app_media_image.jpg" ) MyMediaCollection().insertVideoToCollection( this@MainActivity, "my_app_media_video.mp4" ) MyMediaCollection().insertAudioToCollection( this@MainActivity, "my_app_media_audio.mp3" ) &#125; Log.d(TAG, "copyAssets() called : #### END ####") &#125; /** * 查询媒体集数据 */ private suspend fun queryData() &#123; withContext(Dispatchers.IO) &#123; MyMediaCollection().queryImageCollection(this@MainActivity) MyMediaCollection().queryVideoCollection(this@MainActivity) MyMediaCollection().queryAudioCollection(this@MainActivity) &#125; &#125; /** * 修改媒体集数据 */ private suspend fun updateData() &#123; withContext(Dispatchers.IO) &#123; val imageId = 33 val imageNewName = "my_app_media_image_new_name.jpg" val videoId = 34 val videoNewName = "my_app_media_video_new_name.mp4" val audioId = 26 val audioNewName = "my_app_media_audio_new_name.mp3" MyMediaCollection().updateImageCollection( this@MainActivity, imageId.toLong(), imageNewName ) MyMediaCollection().updateVideoCollection( this@MainActivity, videoId.toLong(), videoNewName ) MyMediaCollection().updateAudioCollection( this@MainActivity, audioId.toLong(), audioNewName ) &#125; &#125; /** * 删除媒体集数据 */ private suspend fun deleteData() &#123; withContext(Dispatchers.IO) &#123; val imageId = 33 val videoId = 34 val audioId = 26 MyMediaCollection().deleteImageCollection(this@MainActivity, imageId.toLong()) MyMediaCollection().deleteVideoCollection(this@MainActivity, videoId.toLong()) MyMediaCollection().deleteAudioCollection(this@MainActivity, audioId.toLong()) &#125; &#125; /** * 删除 / 编辑 其他应用程序的媒体集数据(需要申请权限) */ @RequiresApi(Build.VERSION_CODES.Q) private fun changeOtherApp() &#123; try &#123; val imageId = 37 val imageNewName = "other_app__media_image_renamed_by_own_app.jpg" val videoId = 39 val videoNewName = "other_app__media_video_renamed_by_own_app.mp4" val audioId = 36 val audioNewName = "other_app__media_audio_renamed_by_own_app.mp3" MyMediaCollection().updateImageCollection( this@MainActivity, imageId.toLong(), imageNewName ) MyMediaCollection().updateVideoCollection( this@MainActivity, videoId.toLong(), videoNewName ) MyMediaCollection().updateAudioCollection( this@MainActivity, audioId.toLong(), audioNewName ) MyMediaCollection().deleteImageCollection(this@MainActivity, imageId.toLong()) MyMediaCollection().deleteVideoCollection(this@MainActivity, videoId.toLong()) MyMediaCollection().deleteAudioCollection(this@MainActivity, audioId.toLong()) &#125; catch (securityException: SecurityException) &#123; // 这种方式是使用抛出一个异常的方式，弹出操作处理框，让用户处理 // 第二种方式就是删除之前进行权限检查，参考下面的deleteImages方法 Log.d(TAG, "updateOtherApp() called : " + securityException.message) val recoverableSecurityException = securityException as? RecoverableSecurityException ?: throw RuntimeException(securityException.message, securityException) // Android 10 上面的方法，但每次处理一个文件会弹出一个框让用户操作,不能一次性大批量 val intentSender = recoverableSecurityException.userAction.actionIntent.intentSender intentSender?.let &#123; //会弹出权限对话框，让用户是否确定要授予该APP应用程序改变其他应用创建的媒体文件权限 ActivityCompat.startIntentSenderForResult( this, intentSender, 200, null, 0, 0, 0, null ) &#125; &#125; &#125; /*** * 删除多张图片，一次请求 友好的方式 * * createDeleteRequest (Android 11 / R 上新增的 API ) --- 永久删除指定的媒体文件 * * 参考该方法 , 其他新增 createWriteRequest 、createFavoriteRequest、createTrashRequest 这几个API就不写示例了， * */ @RequiresApi(Build.VERSION_CODES.R) private fun deleteImages(context: Context) &#123; val uri1 = Uri.parse("content://media/external/images/media/27855") val uri2 = Uri.parse("content://media/external/images/media/27856") val uri3 = Uri.parse("content://media/external/images/media/27857") val uri4 = Uri.parse("content://media/external/images/media/27858") val uri5 = Uri.parse("content://media/external/images/media/27859") val uris = arrayListOf(uri1,uri2,uri3,uri4,uri5) val pendingIntent = MediaStore.createDeleteRequest(context.contentResolver, uris.filter &#123; // 使用时请求权限 context.checkUriPermission( it, Binder.getCallingPid(), Binder.getCallingUid(), Intent.FLAG_GRANT_WRITE_URI_PERMISSION ) != PackageManager.PERMISSION_GRANTED &#125;) val intentSender = pendingIntent.intentSender intentSender?.let &#123; //会弹出权限对话框，让用户是否确定要授予该APP应用程序改变其他应用创建的媒体文件权限 ActivityCompat.startIntentSenderForResult( this, intentSender, 300, null, 0, 0, 0, null ) &#125; &#125; /** * 访问目录 */ private fun openDocumentTree() &#123; MyDownloadCollection().openDirectory(this@MainActivity, PICK_DIR) &#125; /** * 访问文档 */ private fun openDocument() &#123; MyDownloadCollection().openDocument( this@MainActivity, "*/*",//application/pdf PICK_DOCUMENT ) &#125; /** * 创建文档 */ private fun createDocument() &#123; MyDownloadCollection().createDocument( this@MainActivity, "text/plain", "my_app_create.text", CREATE_DOCUMENT ) &#125; /** * 写入数据到文档 */ private fun writeDocument(uri: Uri) &#123; MyDownloadCollection().writeDataToDocument( this, uri, "balabalabalabalabalabalabalabalabalabalabalabala" ) &#125; private fun deleteDocument(uri: Uri) &#123; MyDownloadCollection().deleteDocument(this, uri) &#125; override fun onResume() &#123; super.onResume() Log.d(TAG, "onResume() called") &#125; override fun onDestroy() &#123; super.onDestroy() Log.d(TAG, "onDestroy() called") &#125; /** * 初始化权限 * READ_EXTERNAL_STORAGE * ACCESS_MEDIA_LOCATION (访问图片位置元数据必须请求) */ private fun initPermission() &#123; Log.d(TAG, "initPermission() called") val permissions = arrayOf( Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.ACCESS_MEDIA_LOCATION ) for (i in permissions.indices) &#123; if (ContextCompat.checkSelfPermission( this, permissions[i] ) != PackageManager.PERMISSION_GRANTED ) &#123; ActivityCompat.requestPermissions(this, permissions, PERMISSION_CODE); &#125; &#125; &#125; override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; super.onActivityResult(requestCode, resultCode, data) if (requestCode == PICK_DOCUMENT &amp;&amp; resultCode == Activity.RESULT_OK) &#123; data?.data?.also &#123; Log.d(TAG, "onActivityResult() called : PICK_DOCUMENT uri = $it") // 返回文件的Uri // 自定义下面的逻辑代码..... // ................ // ................ //示例: deleteDocument(it) // 删除文档 &#125; &#125; if (requestCode == CREATE_DOCUMENT &amp;&amp; resultCode == Activity.RESULT_OK) &#123; data?.data?.also &#123; Log.d(TAG, "onActivityResult() called : CREATE_DOCUMENT uri = $it") // 返回文件的Uri // 自定义下面的逻辑代码..... // ................ // ................ //示例: writeDocument(it) // 删除文档 &#125; &#125; &#125; override fun onRequestPermissionsResult( requestCode: Int, permissions: Array&lt;String&gt;, grantResults: IntArray ) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == PERMISSION_CODE) &#123; for (i in permissions.indices) &#123; Log.d(TAG, "onRequestPermissionsResult: " + grantResults[i]) if (grantResults[i] == -1) &#123; Toast.makeText(this@MainActivity, "$&#123;grantResults[i]&#125;权限被拒绝", Toast.LENGTH_SHORT) .show() &#125; else &#123; Toast.makeText(this@MainActivity, "$&#123;grantResults[i]&#125;权限被授予", Toast.LENGTH_SHORT) .show() &#125; &#125; &#125; &#125; companion object &#123; private const val TAG = "MainActivity" private const val PERMISSION_CODE = 999 private const val CREATE_DOCUMENT = 2000 private const val PICK_DOCUMENT = 1000 private const val PICK_DIR = 3000 &#125;&#125; build.gradle12345678910 minSdkVersion 'R' targetSdkVersion 'R'dependencies &#123; // Kotlin 协程依赖库 implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.0" implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.0" // Exifinterface 库 implementation 'androidx.exifinterface:exifinterface:1.1.0'&#125; AndroidManifest.xml12345678910111213 &lt;!-- Android 11 不再需要 WRITE_EXTERNAL_STORAGE --&gt; &lt;!--&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;--&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_MEDIA_LOCATION" /&gt;&lt;!-- android:requestLegacyExternalStorage="false" 在 targetSdkVersion &gt; 29 已无法使用，从下面application节点把属性配置去掉了 --&gt;&lt;application android:allowBackup="false" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" .... ..../&gt; 后记以上的示例大部分基于Android Q 开始，少部分介绍了Android R 新方法。 更多API的使用 、更多应用场景、更多差异测试，请自己进行参照扩展测试。有什么问题，欢迎在评论处留言。 [相关文献] 1. Android 官网 - Storage updates in Android 11 2. Modern User Storage on Android 3. Scoped Storage on Android 11 4. Working with Scoped Storage 最后 ， 感谢您的阅读 。 本文对Android Q 上分区存储回顾，Android R 上分区存储变化的简单总结。 如果不足之处，欢迎指正。]]></content>
      <categories>
        <category>Android</category>
        <category>Android R</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Q</tag>
        <tag>Android R</tag>
        <tag>Android 11</tag>
        <tag>MediaStore API</tag>
        <tag>SAF</tag>
        <tag>Scoped Storage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 11 (R) Bubble 气泡]]></title>
    <url>%2F2020%2F03%2F10%2Fandroid-r-dp1-bubble%2F</url>
    <content type="text"><![CDATA[Android 11 / R 上自家的短信息应用 Messages , 又如FaceBook的 Messager以及Telegram 应用等等。它们实现了Bubble气泡，也都属于聊天讯息功能应用 本文介绍 Android 11 / R DP1 Bubble 气泡 上一次写气泡是 Android Q ，本节内容我们来看看 Android 11 / R 上的气泡又有哪些变化 ？ Notification.BubbleMetadata.Builder 差异报告 添加方法 Builder createIntentBubble (PendingIntent, Icon) Builder createShortcutBubble (String) 变更方法 状态 Builder setIcon (Icon) Now deprecated. Builder setIntent (PendingIntent) Now deprecated. Notification.BubbleMetadata 差异报告 添加方法 Icon getBubbleIcon () PendingIntent getBubbleIntent () String getShortcutId () 变更方法 状态 Icon getIcon () Now deprecated. PendingInten getIntent() Now deprecated. 前言我们先来看看，默认Android 短信应用的气泡效果，当通知栏收到一条短信通知 [长按] 这条通知 , 能看到有show as Bubble ，favorite 、Smooze、Mute 等选项 然后 [ 点击 show as Bubble ] 通知栏的消息会作为Bubble气泡显示,悬浮在屏幕上 当 [ 点击 ] 悬浮气泡 ,气泡会被展开，触发BubbleActivity , 查看完整的对话或者发生新对话内容 [ 长按 ] 气泡拖到底部 移除 这就是Android 11 / R 上的气泡效果，那么，接下来就来实现这样的气泡效果 示例首先创建一个BubbleActivity用于展示气泡展开后的窗口布局 [ BubbleActivity.kt ] 12345678class BubbleActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_bubble) // 具体的逻辑代码 &#125;&#125; [ activity_bubble.xml ] 1234567891011121314&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/container" android:gravity="center" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_gravity="center" android:gravity="center" android:textSize="20sp" android:text="这里是聊天对话窗口 .." android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt; [ style.xml ] 123456&lt;style name="AppTheme.NoActionBar"&gt; &lt;item name="windowActionBar"&gt;false&lt;/item&gt; &lt;item name="windowNoTitle"&gt;true&lt;/item&gt; &lt;item name="android:windowDrawsSystemBarBackgrounds"&gt;true&lt;/item&gt; &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; [ AndroidManifest.xml ] 123456&lt;activity android:name=".BubbleActivity" android:theme="@style/AppTheme.NoActionBar" android:label="气泡" android:allowEmbedded="true" android:documentLaunchMode="always" android:resizeableActivity="true"/&gt; 创建一个Notification公共类[ MyNotification.kt ] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.shoewann.androidrtestimport android.app.*import android.content.Contextimport android.content.Intentimport android.graphics.drawable.Iconimport android.os.Buildimport android.util.Logimport androidx.annotation.RequiresApiclass MyNotification(context: Context) &#123; private var notificationManager: NotificationManager? = null private var context: Context? = null companion object &#123; private const val TAG = "MyNotification" private const val REQUEST_CONTENT = 1 private const val REQUEST_BUBBLE = 2 &#125; init &#123; this.context = context notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager &#125; @RequiresApi(Build.VERSION_CODES.R) fun showBubble() &#123; Log.d(TAG, "show bubble") //创建通知渠道 val channel = NotificationChannel("通知渠道ID", "通知渠道名称", NotificationManager.IMPORTANCE_HIGH) notificationManager!!.createNotificationChannel(channel) // val icon = Icon.createWithResource(context, R.mipmap.ic_launcher_round) // 添加聊天人员 A val person = Person.Builder() .setName("Shoewann") .setIcon(icon) .build() // 添加聊天人员 B val person2 = Person.Builder() .setName("Bobozai") .setIcon(icon) .build() // 创建一个模拟的短信对话内容 val style: Notification.MessagingStyle = Notification.MessagingStyle(person) .addMessage( "你好，我叫Shoewann,请问你叫什么名字? ", 1583837786, person ) .addMessage( "我叫Bobozai", 1583837851, person2 ).setGroupConversation(true) val contentIntent = PendingIntent.getActivity( context, REQUEST_CONTENT, Intent(context, MainActivity::class.java), PendingIntent.FLAG_UPDATE_CURRENT ) val bubbleIntent = PendingIntent.getActivity( context, REQUEST_BUBBLE, Intent(context, BubbleActivity::class.java), PendingIntent.FLAG_UPDATE_CURRENT ) val bubbleMetadata = Notification.BubbleMetadata.Builder() .setDesiredHeight(400) //.setIcon(icon) // 已废弃 .createShortcutBubble("Android R 测试") .createIntentBubble(bubbleIntent, icon) .setAutoExpandBubble(true) //.setIntent(bubbleIntent) // 已废弃 .build() val builder = Notification.Builder(context, "通知渠道ID") .setContentTitle("Bubble") .setContentText("测试Android R Bubble") .setContentIntent(contentIntent) .setSmallIcon(icon) .setBubbleMetadata(bubbleMetadata) .setStyle(style) .addPerson(person) .setShowWhen(true) notificationManager!!.notify(0, builder.build()); &#125; fun canBubble(): Boolean &#123; val channel = notificationManager!!.getNotificationChannel("通知渠道ID") return notificationManager!!.areBubblesAllowed() &amp;&amp; channel.canBubble() &#125; MainActivity 调用[MainActivity.kt] 1234val canBubble = MyNotification(this).canBubble()if (canBubble) Log.d(TAG, "onClick() called with: canBubble = $canBubble") MyNotification(this).showBubble() 效果图 气泡什么时候会出现？官方文档 为了减少用户的打扰次数，只有满足以下一个或多个条件，气泡才会出现： 通知使用 MessagingStyle，并且有一个 Person 被添加 该通知来自对 Service.startForeground 的调用,有一个CATEGORY_CALL 的 类别，并且有一个 Person 被添加 发送通知时，应用程序处于前台。 本示例只演示了以上第一个类别，其他情况请自行验证 以上就是本文的全部内容，感谢您的阅读 本文基于Android R DP1 , 如有不足，欢迎指正]]></content>
      <categories>
        <category>Android</category>
        <category>Android R</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Notification</tag>
        <tag>Android R</tag>
        <tag>Bubble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 11 (R) 之 IntentService]]></title>
    <url>%2F2020%2F03%2F10%2Fandroid-R-IntentService-deprecated%2F</url>
    <content type="text"><![CDATA[Android 11/R 废弃了 IntentService 本文我们一起来回顾它 IntentService12345678public abstract class IntentServiceextends Servicejava.lang.Object ↳ android.content.Context ↳ android.content.ContextWrapper ↳ android.app.Service ↳ android.app.IntentService 废弃原因 : IntentService受到Android 8.0（API级别26）施加的所有后台执行限制。 替代方案 : 当运行在 Android 8.0 或者更高的版本的时候考虑使用WorkManager或者JobIntentService , 利用jobs代替services 回顾 IntentService (API level 3 ~ API level R)基于Service,可根据需要处理异步请求(表示为Intent)。客户端通过调用Context.startService(Intent)()发送请求。服务根据需要启动，依次使用工作线程处理每一个Intent,当它运行完成自动会停止。 这种“工作队列处理器”模式通常用于从应用程序的主线程分担任务。IntentService类存在是为了简化此模式并注意机制。要使用它，继承IntentService 并实现 onHandleIntent(android.content.Intent)。IntentService将收到Intents,启动一个工作线程，并适当停止服务 所有的请求都在一个单独的工作线程种处理 – 它们或许会耗费大量时间(并且不会阻塞应用程序的主循环)，但是一次只处理一个请求。 构造函数 说明 IntentService(String name) 创建一个IntentService,由您的子类的构造函数调用 方法 说明 onBind (Intent) 除非您为服务提供绑定，否则不需要实现此方法，因为默认实现返回null onCreate() 首次创建服务时由系统调用。不要直接调用此方法 onDestroy() 由系统调用以通知服务该服务已不再使用且已被删除 onStart (Intent, int) 改为实现 onStartCommand（Intent，int，int） onStartCommand（Intent，int，int） 您不应为IntentService覆盖此方法。而是改写onHandleIntent（Intent），当IntentService收到启动请求时，系统将调用该方法。 setIntentRedelivery(boolean) 设置Intent重新交付首选项 onHandleIntent(Intent) 在工作线程上调用此方法以进行处理。 示例说明 一个进度条：更新加载进度 三个文本：服务状态（进行中/结束）、 进程状态（进行中/结束）和进度条百分比 (0-100%) 两个按钮：开始、停止 Activity 启动/停止任务、广播监听更新UI ：文本状态和进度条进度 以下分别通过 IntentService、JobIntentService、WorkManager 3 种方式来实现进度加载效果 [ activity_main.xml ] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;ProgressBar android:id="@+id/progressBar" style="?android:attr/progressBarStyleHorizontal" android:layout_width="0dp" android:layout_height="0dp" android:layout_marginStart="11dp" android:layout_marginEnd="12dp" android:max="100" android:progress="0" app:layout_constraintBottom_toBottomOf="@+id/tvProgress" app:layout_constraintEnd_toStartOf="@+id/tvProgress" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="@+id/tvProgress" /&gt; &lt;TextView android:id="@+id/tvThreadValue" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="8dp" android:text="线程结束" app:layout_constraintStart_toStartOf="@+id/tvServiceValue" app:layout_constraintTop_toBottomOf="@+id/tvServiceValue" /&gt; &lt;TextView android:id="@+id/tvThreadStatus" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="11dp" android:layout_marginTop="10dp" android:text="线程状态:" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/tvServiceStatus" /&gt; &lt;Button android:id="@+id/btnStopService" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="8dp" android:layout_marginEnd="16dp" android:text="停止" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintTop_toBottomOf="@+id/progressBar" /&gt; &lt;TextView android:id="@+id/tvProgress" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="86dp" android:layout_marginEnd="15dp" android:text="0%" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView android:id="@+id/tvServiceValue" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="14dp" android:text="服务结束" app:layout_constraintStart_toEndOf="@+id/tvServiceStatus" app:layout_constraintTop_toTopOf="@+id/tvServiceStatus" /&gt; &lt;Button android:id="@+id/btnStart" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="7dp" android:layout_marginEnd="13dp" android:text="开始" app:layout_constraintEnd_toStartOf="@+id/btnStop" app:layout_constraintTop_toBottomOf="@+id/progressBar" /&gt; &lt;TextView android:id="@+id/tvServiceStatus" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="11dp" android:layout_marginTop="27dp" android:text="服务状态:" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; [ MainActivity.kt ] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package com.shoewann.androidrtestimport android.content.BroadcastReceiverimport android.content.Contextimport android.content.Intentimport android.content.IntentFilterimport android.os.Bundleimport android.util.Logimport android.view.Viewimport androidx.appcompat.app.AppCompatActivityimport androidx.work.*import kotlinx.android.synthetic.main.activity_main.*import java.util.concurrent.TimeUnitclass MainActivity : AppCompatActivity(), View.OnClickListener &#123; private var receiver: MyBroadcastReceiver? = null private var myWorkRequest: WorkRequest? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) Log.d(TAG, "onCreate() called with: savedInstanceState = $savedInstanceState") //初始化广播 initReceiver() //按钮点击监听事件 btnStart.setOnClickListener(this) btnStop.setOnClickListener(this) &#125; /** * 开始 IntentService */ private fun startIntentService() &#123; val intent = Intent(this, MyIntentService::class.java) startService(intent) &#125; /** * 停止 IntentService */ private fun stopIntentService() &#123; val intent = Intent(this, MyIntentService::class.java) stopService(intent) &#125; /** * 开始 JobIntentService */ private fun startJobIntentService() &#123; val intent = Intent(this, MyJobIntentService::class.java) MyJobIntentService.enqueueWork(this@MainActivity, intent) &#125; /** * 开始 WorkManager一次 Work 任务 */ private fun startMyWorkManagerOneTimeWork() &#123; myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWorkManager&gt;() .build() WorkManager.getInstance(this).enqueue(myWorkRequest as OneTimeWorkRequest) &#125; /** * 开始 WorkManager 周期性 Work 任务 */ private fun startMyWorkManagerPeriodicWork() &#123; //注意：最短重复间隔是 15 分钟 myWorkRequest = PeriodicWorkRequestBuilder&lt;MyWorkManager&gt;(15 * 60 * 1000, TimeUnit.SECONDS) .build() WorkManager.getInstance(this).enqueue(myWorkRequest as PeriodicWorkRequest) &#125; /** * 停止work任务 */ private fun stopMyWorkManager() &#123; WorkManager.getInstance(this).cancelWorkById(myWorkRequest!!.id) &#125; /** * 初始化广播 */ private fun initReceiver() &#123; Log.d(TAG, "initReceiver() called") if (receiver != null) return receiver = MyBroadcastReceiver() val intentFilter = IntentFilter() intentFilter.addAction(ACTION_CASE_SERVICE) intentFilter.addAction(ACTION_CASE_THREAD) registerReceiver(receiver, intentFilter) &#125; /** * 广播内部类 */ inner class MyBroadcastReceiver : BroadcastReceiver() &#123; override fun onReceive(context: Context, intent: Intent?) &#123; Log.d(TAG, "onReceive() called with: context = $context, intent = $intent") if (intent == null) return when (intent.action) &#123; ACTION_CASE_SERVICE -&gt; &#123; tvServiceValue.text = intent.getStringExtra("status") &#125; ACTION_CASE_THREAD -&gt; &#123; val progress = intent.getIntExtra("progress", 0) tvThreadValue.text = intent.getStringExtra("status") progressBar.progress = progress tvProgress.text = "$progress%" &#125; else -&gt; return &#125; &#125; &#125; override fun onClick(v: View?) &#123; when (v?.id) &#123; R.id.btnStart -&gt; &#123; //startIntentService() //startJobIntentService() //startMyWorkManagerOneTimeWork() //startMyWorkManagerPeriodicWork() &#125; R.id.btnStop -&gt; &#123; //stopIntentService() //stopMyWorkManager() &#125; else -&gt; return &#125; &#125; override fun onResume() &#123; super.onResume() Log.d(TAG, "onResume() called") initReceiver() &#125; override fun onDestroy() &#123; super.onDestroy() Log.d(TAG, "onDestroy() called") unregisterReceiver(receiver) &#125; companion object &#123; private const val TAG = "MainActivity" const val ACTION_CASE_SERVICE = "action_case_service" const val ACTION_CASE_THREAD = "action_case_thread" &#125;&#125; 1. IntentService 方式[ MyIntentService.kt ] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.shoewann.androidrtestimport android.app.IntentServiceimport android.content.Intentimport android.util.Logimport com.shoewann.androidrtest.MainActivity.Companion.ACTION_CASE_SERVICEimport com.shoewann.androidrtest.MainActivity.Companion.ACTION_CASE_THREADclass MyIntentService : IntentService("MyIntentService") &#123; private var isRunning = true private var count = 0 companion object&#123; private const val TAG = "MyIntentService" &#125; override fun onCreate() &#123; super.onCreate() Log.d(TAG, "onCreate() called") sendServiceStatus("服务启动"); &#125; override fun onHandleIntent(intent: Intent?) &#123; Log.d(TAG, "onHandleIntent() called with: intent = $intent") try &#123; sendThreadStatus("线程启动", count) Thread.sleep(1000) sendServiceStatus("服务运行中...") isRunning = true count = 0 while (isRunning) &#123; count++ if (count &gt;= 100) &#123; isRunning = false &#125; Thread.sleep(50) sendThreadStatus("线程运行中...", count) &#125; sendThreadStatus("线程结束", count) &#125; catch (e: InterruptedException) &#123; e.printStackTrace() &#125; &#125; override fun onDestroy() &#123; super.onDestroy() Log.d(TAG, "onDestroy() called") sendServiceStatus("服务结束") &#125; // 发送服务状态信息 private fun sendServiceStatus(status: String) &#123; Log.d(TAG, "sendServiceStatus() called with: status = $status") val intent = Intent(ACTION_CASE_SERVICE) intent.putExtra("status", status) sendBroadcast(intent) &#125; // 发送线程状态信息 private fun sendThreadStatus(status: String, progress: Int) &#123; Log.d(TAG, "sendThreadStatus() called with: status = $status, progress = $progress") val intent = Intent(ACTION_CASE_THREAD) intent.putExtra("status", status) intent.putExtra("progress", progress) sendBroadcast(intent) &#125;&#125; 123&lt;service android:name=".MyIntentService" android:exported="false" /&gt; 2. JobIntentService 方式[ MyJobIntentService.kt ] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.shoewann.androidrtestimport android.content.Contextimport android.content.Intentimport android.util.Logimport androidx.core.app.JobIntentServiceclass MyJobIntentService : JobIntentService() &#123; private var isRunning = true private var count = 0 companion object &#123; private const val TAG = "MyJobIntentService" private const val JOB_ID = 1000 fun enqueueWork(context: Context, work: Intent) &#123; enqueueWork(context, MyJobIntentService::class.java, JOB_ID, work) &#125; &#125; override fun onHandleWork(intent: Intent) &#123; Log.d(TAG, "onHandleWork() called with: intent = $intent") try &#123; sendThreadStatus("线程启动", count) Thread.sleep(1000) sendServiceStatus("服务运行中...") isRunning = true count = 0 while (isRunning) &#123; count++ if (count &gt;= 100) &#123; isRunning = false &#125; Thread.sleep(50) sendThreadStatus("线程运行中...", count) &#125; sendThreadStatus("线程结束", count) &#125; catch (e: InterruptedException) &#123; e.printStackTrace() &#125; &#125; override fun onDestroy() &#123; super.onDestroy() Log.d(TAG, "onDestroy() called") sendServiceStatus("服务结束") &#125; // 发送服务状态信息 private fun sendServiceStatus(status: String) &#123; Log.d(TAG, "sendServiceStatus() called with: status = $status") val intent = Intent(MainActivity.ACTION_CASE_SERVICE) intent.putExtra("status", status) sendBroadcast(intent) &#125; // 发送线程状态信息 private fun sendThreadStatus(status: String, progress: Int) &#123; Log.d(TAG, "sendThreadStatus() called with: status = $status, progress = $progress") val intent = Intent(MainActivity.ACTION_CASE_THREAD) intent.putExtra("status", status) intent.putExtra("progress", progress) sendBroadcast(intent) &#125;&#125; [ AndroidManifest.xml ] 12345&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;&lt;service android:name=".MyJobIntentService" android:exported="true" android:permission="android.permission.BIND_JOB_SERVICE" /&gt; 2. WorkManager 方式[ MyWorkManager.kt ] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.shoewann.androidrtestimport android.content.Contextimport android.content.Intentimport android.util.Logimport androidx.work.Workerimport androidx.work.WorkerParametersclass MyWorkManager(context: Context, params: WorkerParameters) : Worker(context, params) &#123; private var isRunning = true private var count = 0 companion object &#123; private const val TAG = "MyWorkManager" &#125; private var context: Context? = null private var params: WorkerParameters? = null init &#123; this.context = context this.params = params &#125; override fun doWork(): Result &#123; Log.d(TAG, "doWork() called") try &#123; sendThreadStatus("线程启动", count) Thread.sleep(1000) sendServiceStatus("服务运行中...") isRunning = true count = 0 while (isRunning) &#123; count++ if (count &gt;= 100) &#123; isRunning = false &#125; Thread.sleep(50) sendThreadStatus("线程运行中...", count) &#125; sendThreadStatus("线程结束", count) &#125; catch (e: InterruptedException) &#123; e.printStackTrace() &#125; return Result.success() &#125; private fun sendServiceStatus(status: String) &#123; Log.d(TAG, "sendServiceStatus() called with: status = $status") val intent = Intent(MainActivity.ACTION_CASE_SERVICE) intent.putExtra("status", status) context?.sendBroadcast(intent) &#125; private fun sendThreadStatus(status: String, progress: Int) &#123; Log.d(TAG, "sendThreadStatus() called with: status = $status, progress = $progress") val intent = Intent(MainActivity.ACTION_CASE_THREAD) intent.putExtra("status", status) intent.putExtra("progress", progress) context?.sendBroadcast(intent) &#125; override fun onStopped() &#123; super.onStopped() Log.d(TAG, "onStopped() called") &#125;&#125; [ app -&gt; build.gradle ] 1234567891011121314151617181920dependencies &#123; // 依赖配置 def work_version = "2.3.3" // (Java only) implementation "androidx.work:work-runtime:$work_version" // Kotlin + coroutines implementation "androidx.work:work-runtime-ktx:$work_version" // optional - RxJava2 support implementation "androidx.work:work-rxjava2:$work_version" // optional - GCMNetworkManager support implementation "androidx.work:work-gcm:$work_version" // optional - Test helpers androidTestImplementation "androidx.work:work-testing:$work_version"&#125; 效果1. IntentService 点击［开始］，服务运行，线程计数完成后，服务和线程都结束。 点击［开始］，服务运行，线程计数完成前，点击［停止］，服务结束，线程计数完成后线程结束。 点击两次［开始］，服务运行，第一次线程计数完成后，进行第二次线程计数，两次完成后，服务和线程都结束。 点击两次［开始］，服务运行，第一次线程计数完成前，点击两次[停止]，服务结束，第一次线程计数完成后线程结束，不进行第二次线程计数 2. JobIntentService 点击［开始］，服务运行，线程计数完成后，服务和线程都结束。 点击［开始］，服务运行，线程计数完成前，点击［停止］，服务运行中，线程计数完成后线程结束。 点击两次［开始］，服务运行，第一次线程计数完成后，进行第二次线程计数，两次完成后，服务和线程都结束。 点击两次［开始］，服务运行，第一次线程计数完成前，点击两次[停止]，服务运行中，第一次线程计数完成后线程结束，不进行第二次线程计数 3. WorkManager (OneTimeWork，非周期性) 点击［开始］，服务运行，线程计数完成后，服务和线程都结束。 点击［开始］，服务运行，线程计数完成前，点击［停止］，服务无法结束，线程计数完成后线程结束。 点击两次［开始］，服务运行，两次线程同时进行叠加计数，线程结束，服务运行中。 点击两次［开始］，服务运行，两次线程同时进行叠加计数，点击两次[停止]，两次完成后分别进行两次线程结束，服务运行中。 总结 IntentService 和 JobIntentService(都继承自Service),创建一个工作线程处理多线程任务，线程优先级相对普通线程要高，不需要手动结束，在任务处理完后，会自动关闭服务 IntentService从未被设计为可以取消的，因此缺少用于取消JobIntentService的任何API。因此，JobIntenService仅应用于不需要取消的工作。JobIntentService是作为实现的IntentService。尽管您可以stopService()用来销毁IntentService，这可能不会对用于onHandleIntent（）的后台线程产生影响，在onHandleIntent方法完成前一个请求之前，它不会通过某些intent操作停止或处理任何其他请求。在任务执行完毕之前，将不会调用stopService（）( via : how-to-cancel-a-jobintentservice ) WorkManager，并不是所有的任务都可以取消，当任务正在执行时是不能取消的，当然任务执行完成了，取消也是意义的，也就是说当任务加入到ManagerWork的队列中但是还没有执行时才可以取消。 如果将[开始]按钮里面的代码延时(70s)启动，模拟后台启动，MainActivity.kt 改成如下： 123456789R.id.btnStart -&gt; &#123; Log.d(TAG, "startService() called") Handler(Looper.getMainLooper()).postDelayed(&#123; //startIntentService() //startJobIntentService() //startMyWorkManagerOneTimeWork() //startMyWorkManagerPeriodicWork() &#125;, 70 * 1000) &#125; 再点击 开始 按钮之后，按Home键回到launcherIntentService 的方式会因为Android O / 8.0 后台限制抛出异常 1234567891011121314151617181920212020-03-10 17:23:01.132 10813-10813/com.shoewann.androidrtest D/MainActivity: startIntentService() called2020-03-10 17:23:01.139 10813-10813/com.shoewann.androidrtest D/AndroidRuntime: Shutting down VM --------- beginning of crash2020-03-10 17:23:01.143 10813-10813/com.shoewann.androidrtest E/AndroidRuntime: FATAL EXCEPTION: main Process: com.shoewann.androidrtest, PID: 10813 java.lang.IllegalStateException: Not allowed to start service Intent &#123; cmp=com.shoewann.androidrtest/.MyIntentService &#125;: app is in background uid UidRecord&#123;f520899 u0a421 LAST bg:+1m8s709ms idle change:idle procs:1 seq(0,0,0)&#125; at android.app.ContextImpl.startServiceCommon(ContextImpl.java:1699) at android.app.ContextImpl.startService(ContextImpl.java:1654) at android.content.ContextWrapper.startService(ContextWrapper.java:719) at com.shoewann.androidrtest.MainActivity.startIntentService(MainActivity.kt:59) at com.shoewann.androidrtest.MainActivity.access$startIntentService(MainActivity.kt:18) at com.shoewann.androidrtest.MainActivity$onClick$1.run(MainActivity.kt:158) at android.os.Handler.handleCallback(Handler.java:907) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:216) at android.app.ActivityThread.main(ActivityThread.java:7506) at java.lang.reflect.Method.invoke(Native Method) a2020-03-10 17:23:01.169 10813-10813/com.shoewann.androidrtest I/Process: Sending signal. PID: 10813 SIG: 9 其他均验证通过JobIntentService 和 WorkManager 的方式为 IntentService 替代方案 以上就是本文的全部内容，其他方面请自行总结扩展测试，感谢您的阅读 本文基于Android 11 / R DP1 发布，如有不足, 欢迎指正]]></content>
      <categories>
        <category>Android</category>
        <category>Android R</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android R</tag>
        <tag>IntentService</tag>
        <tag>Jobs</tag>
        <tag>JobIntentService</tag>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 11 (R) 之 Handler 相关变化]]></title>
    <url>%2F2020%2F03%2F09%2Fandroid-R-about-handler-change%2F</url>
    <content type="text"><![CDATA[Handler 类，相信大家并不陌生，也应当耳熟能详，且铭记于心几乎项目中使用频率较高，同时也是面试时常挂嘴边的必考知识点 今天我们来谈谈在Android 11/R 上 Handler 相关变化 HandlerHandler 可让您发送和处理 Message 和 Runnable 与线程的 MessageQueue 关联的对象。每个处理程序实例与单个线程以及该线程的消息相关联排队。创建新的处理程序时，它会绑定到 Looper。它将消息和可运行消息传递到该 Looper 的消息排队并在该 Looper 的线程上执行它们。 Android 11/R DP1 的发布，参考以下的差异报告 官方对 Handler 类的两个构造函数进行了更改，一个是 Handler()，另一个是 Handler(Handler.Callback callback) 结果也就是将这两个方法 —— 废！弃！了！ Changed Constructors Handler() Now deprecated. Handler(Callback) Now deprecated. Handler 差异报告 Handler() 这个构造函数废弃了, 在Handler构造期间隐式选择Looper会导致操作悄无声息的丢失(如果Handler不再期待新的任务并退出)，崩溃(如果Handler有时在没有激活Looper的主线程中被创建) 或者竞争条件下的bug,处理程序与之关联的线程不是作者预期的，而是使用 Executor 或者使用 Looper#getMainLooper、View#getHandler(), 或者类似方法显式指定Looper。如果为了兼容性需要隐式线程局部行为，使用 new Handler(Looper.myLooper()) 让读者清楚知道。 Handler(Handler.Callback callback) 这个构造函数废弃了, 在Handler构造期间隐式选择Looper会导致操作悄无声息的丢失(如果Handler不再期待新的任务并退出)，崩溃(如果Handler有时在没有激活Looper的主线程中被创建) 或者竞争条件下的bug,处理程序与之关联的线程不是作者预期的，而是使用 Executor 或者使用 Looper#getMainLooper、View#getHandler(), 或者类似方法显式指定Looper。如果为了兼容性需要隐式线程局部行为，使用 new Handler(Looper.myLooper(), callback) 让读者清楚知道。 通过上面的官方文档介绍那么在Android 11 /R 之后创建Handler构造函数 Handler() 变更为 new Handler(Looper.myLooper()) Handler(Handler.Callback callback) 变更为 new Handler(Looper.myLooper(), callback) 相关示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package com.shoewann.androidrtestimport android.os.Bundleimport android.os.Handlerimport android.os.Looperimport android.os.Messageimport android.util.Logimport android.widget.Toastimport androidx.appcompat.app.AppCompatActivityimport kotlinx.android.synthetic.main.activity_main.*import java.lang.ref.WeakReferenceclass MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // Handler() --&gt; R 上已废弃 handler1 = object : Handler() &#123; override fun handleMessage(msg: Message) &#123; super.handleMessage(msg) Log.d(TAG, "handler1 handleMessage() called with: message = [$msg]") if (msg.what == 100) &#123; Log.d(TAG, "handler1 收到消息: $&#123;msg.obj&#125;") &#125; &#125; &#125; // Handler(Handler.Callback callback) --&gt; R 上已废弃 handler2 = Handler(Handler.Callback &#123; Log.d(TAG, "handler 2 handleMessage() called with: message = [$it]") if (it.what == 200) &#123; Log.d(TAG, "handler 2 收到消息: $&#123;it.obj&#125;") return@Callback true &#125; false &#125;) // Handler(Looper looper) R 上替代 Handler() handler3 = object : Handler(Looper.myLooper()!!) &#123; override fun handleMessage(msg: Message) &#123; super.handleMessage(msg) Log.d(TAG, "handler3 handleMessage() called with: msg = [$msg]") if (msg.what == 300) &#123; Log.d(TAG, "handler3 收到消息: $&#123;msg.obj&#125;") &#125; &#125; &#125; // Handler(Looper looper,Handler.Callback callback) R 上替代 Handler(Handler.Callback callback) handler4 = Handler(Looper.myLooper()!!, Handler.Callback &#123; Log.d(TAG, "handler4 handleMessage() called with: msg = [$it]") if (it.what == 400) &#123; Log.d(TAG, "handler4 收到消息: $&#123;it.obj&#125;") return@Callback true &#125; false &#125;) // 弱引用 + 静态内部类 -- Handler() handler5 = Handler5(this@MainActivity) // 弱引用 + 静态内部类 -- Handler(Looper looper) handler6 = Handler6(this@MainActivity) handler7 = Handler(Looper.myLooper()!!, WeakReference(Handler.Callback &#123; if (it.what == 700) &#123; Log.d(TAG, "handler7 收到消息: $&#123;it.obj&#125;") return@Callback true &#125; false &#125;).get()) //弱引用 + 静态内部类 ---&gt; Runnable myRunnable = MyRunnable(this@MainActivity) //子线程开始运行 //如果这里直接new Runnable的方式会导致内存泄漏 (后面会说到) Thread(myRunnable).start() &#125; companion object &#123; private const val TAG = "MainActivity" private var handler1: Handler? = null private var handler2: Handler? = null private var handler3: Handler? = null private var handler4: Handler? = null private var handler5: Handler? = null private var handler6: Handler? = null private var handler7: Handler? = null private var myRunnable: MyRunnable? = null // ------------------------ 弱引用 + 静态内部类 (开始)--------------------------------- private class MyRunnable(activity: MainActivity) : Runnable &#123; private var activity: WeakReference&lt;MainActivity&gt;? = null init &#123; this.activity = WeakReference(activity) &#125; override fun run() &#123; if (activity?.get() == null) return //模拟网络请求数据---&gt; 耗时操作 Thread.sleep(10000) val data = "This is a json data from web server" //发送消息 sendMsg(handler1!!, 100, data) sendMsg(handler2!!, 200, data) sendMsg(handler3!!, 300, data) sendMsg(handler4!!, 400, data) sendMsg(handler5!!, 500, data) sendMsg(handler6!!, 600, data) sendMsg(handler7!!, 700, data) &#125; &#125; // Handler() -- R 上已废弃 private class Handler5(activity: MainActivity) : Handler() &#123; private var activity: WeakReference&lt;MainActivity&gt;? = null init &#123; this.activity = WeakReference(activity) &#125; override fun handleMessage(msg: Message) &#123; super.handleMessage(msg) Log.d(TAG, "handler5 handleMessage() called with: message = [$msg]") if (activity?.get() == null) return if (msg.what == 500) &#123; Log.d(TAG, "handler5 收到消息: $&#123;msg.obj&#125;") &#125; &#125; &#125; // Handler(Looper looper) -- R 上替代 Handler() private class Handler6(activity: MainActivity) : Handler(Looper.myLooper()!!) &#123; private var activity: WeakReference&lt;MainActivity&gt;? = null init &#123; this.activity = WeakReference(activity) &#125; override fun handleMessage(msg: Message) &#123; super.handleMessage(msg) Log.d(TAG, "handler6 handleMessage() called with: message = [$msg]") if (activity?.get() == null) return if (msg.what == 600) &#123; Log.d(TAG, "handler6 收到消息: $&#123;msg.obj&#125;") &#125; &#125; &#125; // ------------------------ 弱引用 + 静态内部类 (结束)--------------------------------- private fun sendMsg(handler: Handler, what: Int, obj: String) &#123; Log.d(TAG, "sendMsg() called with: handler = $handler, what = $what") val message = handler.obtainMessage() message.what = what message.obj = obj handler.sendMessage(message) &#125; &#125; override fun onBackPressed() &#123; super.onBackPressed() Log.d(TAG, "onBackPressed() called") finish() &#125; override fun onDestroy() &#123; super.onDestroy() Log.d(TAG, "onDestroy() called") handler1?.removeCallbacksAndMessages(null) handler2?.removeCallbacksAndMessages(null) handler3?.removeCallbacksAndMessages(null) handler4?.removeCallbacksAndMessages(null) handler5?.removeCallbacksAndMessages(null) handler6?.removeCallbacksAndMessages(null) handler7?.removeCallbacksAndMessages(null) &#125;&#125; 内存泄漏1. Handler123456789private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Toast.makeText(......).show(); textview.setText("xxxx") &#125; &#125;; Handler允许我们发送延时消息，如果在延时消息未处理完，而此时Handler所在的Activity被关闭，但因为上述Handler用法则可能会导致内存泄漏。那么，在延时消息未处理完时，Handler无法释放外部类MainActivity的对象，从而导致内存泄漏产生。 2. Runnable123456private Runnable mRunnable = new Runnable() &#123; @Override public void run() &#123; &#125; &#125;; 该使用方式是创建了一个内部类，内部类隐性持有外部类对象的引用，如果Activity结束，Runnable里面的任务没有处理完，则不会释放Activity的引用，则Activity无法被回收，造成内存泄漏。 LooperLooper在android的消息机制充当消息循环的角色，它不停的从MessageQueue中拿出消息，并将消息交给Handler处理。 prepareMainLooper()在Android 11/ R中，Looper.prepareMainLooper() 已废弃 方法作用 : 将当前线程初始化为循环程序，将其标记为应用程序的主循环程序废弃原因 : 应用程序的主循环程序是由Android环境创建的，因此您无需在自己应用里调用此函数。 【源码部分】 1234567891011121314151617/** * Initialize the current thread as a looper, marking it as an * application's main looper. See also: &#123;@link #prepare()&#125; * * @deprecated The main looper for your application is created by the Android environment, * so you should never need to call this function yourself. */ @Deprecated public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125; &#125; ActivityThread是android的主线程，android主线程在创建的时候会在main函数中调用Looper.prepareMainLooper()主动创建一个Looper。 从上面的信息我们可以知道，prepareMainLooper函数中有调用了Looper的prepare来创建Looper 在子线程中直接使用Looper.prepare()方法创建，确保在调用这个方法之后调用loop()方法，并使用quit()方法结束 【源码部分】 123456789101112131415161718/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */ public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; //一个线程中只能有一个Looper if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; //创建Looper sThreadLocal.set(new Looper(quitAllowed)); &#125; 在线程中我们可以调用Looper.prepare，这个函数中 sThreadLocal.set()中创建一个Looper，该方法不仅创建了Looper，其实也创建了MessageQueue,以及将Looper将当前线程和Looper关联起来了。 【源码部分】 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 而Looper的Loop()方法，主要是用来从MessageQueue消息队列里面拿出消息。 以上就是本文的全部内容，感谢您的阅读 本文基于Android R DP1 post，如有不足, 欢迎指正]]></content>
      <categories>
        <category>Android</category>
        <category>Android R</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android R</tag>
        <tag>Handler</tag>
        <tag>Looper</tag>
        <tag>prepareMainLooper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 11 (R) 之 AsyncTask 前世今生]]></title>
    <url>%2F2020%2F03%2F06%2Fandroid-R-AsyncTask-deprecated%2F</url>
    <content type="text"><![CDATA[在过去的十年中，AsyncTask一直是用于在Android中编写并发代码的最广泛使用的解决方案之一但是，从 Android 11 (R) 开始，官方正式弃用, 也标志着AsyncTask 的时代正式结束 本文我们一起来回顾它的前世今生 简介 本名：AsyncTask中文名：异步任务出生日期：2009 年 Android 1.5 ( API Level 3 )去世日期：2020 年 Android 11 ( API Level R )所处位置：android.os.AsyncTask 前世作用AsyncTask 是安卓开发中使用的一种轻量级异步任务类。其作用是在线程池中执行后台任务，并在执行过程中将执行进度传递给主线程，当任务执行完毕后，将最终结果传递给主线程。 产生背景安卓系统线程分为主线程和子线程，主线程也叫UI线程。主线程主要负责与用户交互。为了更好的用户体验，保证系统不因主线程的阻塞而产生卡顿，安卓系统要求主线程中不能执行耗时任务。例如：IO操作、网络请求等必须在子线程中完成。AsyncTask就是为了适应这种需要而产生。 使用方式直接使用 AsyncTask 123AsyncTask.execute &#123; Log.d(TAG, &quot;###### AsyncTask execute #####&quot;)&#125; 原型 — java 1public abstract class AsyncTask &lt; Params, Progress, Result &gt; — kotlin 1abstract class AsyncTask&lt;Params : Any!, Progress : Any!, Result : Any!&gt; AsyncTask是一个泛型抽象类 参数 说明 Params 执行后台任务所需参数类型 Progress 后台任务执行进度的类型 Result 台任务执行完毕后返回结果类型 并非所有类型都总是由异步任务使用。要将类型标记为未使用，只需使用该类型 Void 1private class MyTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; ... &#125; 核心方法AsyncTask提供4个核心方法： protected void onPreExecute() 参数 说明 执行线程 主线程 调用时间 异步任务执行之前 方法作用 异步任务执行前的初始化工作 protected Result doInBackground(Params…params) 参数 说明 执行线程 线程池中执行 调用时间 任务开始后到任务结束之前 方法作用 用于执行异步任务 protected void onProgressUpdate(Prgress…values) 参数 说明 执行线程 主线程 调用时间 任务开始后到任务结束之前 方法作用 用于更新任务进度 protected void onPostExecute(Result result) 参数 说明 执行线程 主线程 调用时间 异步任务执行之后 方法作用 将异步任务的执行结果传递给主线程 官方示例123456789101112131415161718192021private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; &#123; protected Long doInBackground(URL... urls) &#123; int count = urls.length; long totalSize = 0; for (int i = 0; i &lt; count; i++) &#123; totalSize += Downloader.downloadFile(urls[i]); publishProgress((int) ((i / (float) count) * 100)); // Escape early if cancel() is called if (isCancelled()) break; &#125; return totalSize; &#125; protected void onProgressUpdate(Integer... progress) &#123; setProgressPercent(progress[0]); &#125; protected void onPostExecute(Long result) &#123; showDialog("Downloaded " + result + " bytes"); &#125; &#125; DownloadFilesTask类模拟文件下载过程。传入的参数Params类型为URL(文件地址)，后台任务进程参数Progress类型为Integer(下载进度)，后台任务返回结果参数Result类型为Long(总文件大小)。 创建完成后，任务将非常简单地执行： 1new DownloadFilesTask().execute(url1, url2, url3); 取消任务可以通过调用cancel（boolean）随时取消任务。 调用此方法将导致对isCancelled（）的后续调用返回true。 调用此方法后，在doInBackground（java.lang.Object []）返回之后，将调用onCancelled（java.lang.Object）而不是onPostExecute（java.lang.Object）。 为了确保尽快取消任务，如果可能的话（例如在循环内），应始终定期从doInBackground（java.lang.Object []）检查isCancelled（）的返回值。 使用注意 AsyncTask类必须在主线程加载 AsyncTask对象必须在主线程创建 execute方法必须在主线程调用 不要在程序中直接调用AsyncTask提供的4个核心方法 一个AsyncTask对象只能执行一次，即只能调用一次execute 内存泄漏问题描述 12This AsyncTask class should be static or leaks might occur (anonymous android.os.AsyncTask) less... (Ctrl+F1) A static field will leak contexts. Non-static inner classes have an implicit reference to their outer class. If that outer class is for example a Fragment or Activity, then this reference means that the long-running handler/loader/task will hold a reference to the activity which prevents it from getting garbage collected. Similarly, direct field references to activities and fragments from these longer running instances can cause leaks. ViewModel classes should never point to Views or non-application Contexts 解决方法 ： 静态内部类+弱引用 1234567891011121314151617181920212223242526private static class MyTask extends AsyncTask&lt;Void, Void, String&gt; &#123; private WeakReference&lt;MyActivity&gt; activityReference; //只保留一个弱引用到Activity MyTask(MyActivity context) &#123; activityReference = new WeakReference&lt;&gt;(context); &#125; @Override protected String doInBackground(Void... params) &#123; return "task finished"; &#125; @Override protected void onPostExecute(String result) &#123; //获取Activity的引用（如果仍存在） MyActivity activity = activityReference.get(); if (activity == null || activity.isFinishing()) return; // 验证Activity的UI TextView textView = activity.findViewById(R.id.textview); textView.setText(result); // 访问Activity成员变量 activity.mSomeMemberVariable = 321; &#125; &#125; 今生 abstract class AsyncTask &lt; Params : Any!, Progress : Any!, Result : Any! &gt; 这个类在API level R 被弃用请使用标准的java.util.concurrent或Kotlin并发实用程序代替。 弃用原因 AsyncTask旨在启用和轻松使用UI线程。但是，最常见的用例是集成到UI中，这会导致Context泄漏，丢失的回调或配置更改崩溃。它还在平台的不同版本上具有不一致的行为，吞噬的异常doInBackground，并且不能提供比Executor直接使用更多的实用程序。 AsyncTask是为围绕Thread和Handler的帮助器类而被设计出来的，并且不构成通用的线程框架。理想情况下，应将AsyncTasks用于较短的操作（最多几秒钟）。如果需要使线程长时间运行，则强烈建议您使用java.util.concurrent包提供的各种API，例如 Executor，ThreadPoolExecutor和FutureTask。 代替示例Executor1234567891011121314151617181920212223242526272829// ----------- 示例1 ----------------------//定义class DirectExecutor : Executor &#123; override fun execute(runnable: Runnable?) &#123; runnable?.run() &#125;&#125;//调用val directExecutor = DirectExecutor() directExecutor.execute &#123; Log.d(TAG, "###### DirectExecutor execute ##### ") ......... .........&#125; //----------- 示例2 ----------------------//定义class ThreadPerTaskExecutor : Executor &#123; override fun execute(runnable: Runnable?) &#123; Thread(runnable).start() &#125;&#125;//调用val threadPerTaskExecutor = ThreadPerTaskExecutor() threadPerTaskExecutor.execute &#123; Log.d(TAG, "###### threadPerTaskExecutor execute #####") ......... .........&#125; ThreadPoolExecutor123456789101112131415161718192021//核心线程池大小 --&gt; 即需要开启多少个线程val coreThreadPoolSize = Runtime.getRuntime().availableProcessors() //系统有多少可用就开多少//最大线程池大小val maximumPoolSize = 15//线程最大空闲时间//线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)使得核心线程 有效时间val keepAliveTime = 120L//keepAliveTime时间单位val unit = TimeUnit.SECONDS//定义阻塞式列队val workQueue = ArrayBlockingQueue&lt;Runnable&gt;(10000)val executor = ThreadPoolExecutor(coreThreadPoolSize, maximumPoolSize, keepAliveTime, unit, workQueue )for (i in 0..100) &#123; executor.execute &#123; Log.d(TAG, "线程池中线程数目："+executor.poolSize +"，队列中等待执行的任务数目："+ executor.queue.size +"，已执行完成的任务数目："+executor.completedTaskCount) &#125;&#125;executor.shutdown() FutureTask1234val service = Executors.newSingleThreadExecutor()val futureTask = FutureTask(Callable &#123; ......... &#125;)service.execute(futureTask)Log.d(TAG, "###### futureTask execute ##### $&#123;futureTask.get()&#125;") Kotlin并发(协程)实用程序123456789101112131415//定义耗时操作的方法private fun spendLongTimeAction() : String&#123; //模拟网络请求,耗时5s Thread.sleep(5000) return "This is a json data from web server"&#125;//调用GlobalScope.launch &#123; //使用给定的协程上下文调用指定的暂停块，暂停直到完成，然后返回结果。 withContext(Dispatchers.Main)&#123; val data = spendLongTimeAction() textView.text = data Toast.makeText(this@MainActivity,"数据请求成功",Toast.LENGTH_LONG).show() &#125;&#125; 相关文献 API Differences between 29 and rdp1 AsyncTask is Deprecated, Now What? Deprecating AsyncTask in Android with Kotlin Coroutines Google depreciated AsyncTask from Android 11 以上就是本文对AsyncTask的简单回顾总结 本文发布于Android 11 / R DP 1 。如有不足，欢迎指正]]></content>
      <categories>
        <category>Android</category>
        <category>Android R</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android R</tag>
        <tag>AsycnTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q 检查网络连通性]]></title>
    <url>%2F2019%2F08%2F14%2Fandroid-q-network-connectivity-check%2F</url>
    <content type="text"><![CDATA[对Android Q 上检查网络连通性的相关记录 前言大多数情况下，我们从ConnectivityManager获取活动的网络信息，并检查该网络是否已经连接 像这样 12345fun isNetworkConnected(context: Context?): Boolean &#123; val mConnectivityManager = context?.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager val mNetworkInfo = mConnectivityManager.activeNetworkInfo return mNetworkInfo!=null &amp;&amp; mNetworkInfo.isConnected&#125; 但是在Android Q (API 29) 上，从ConnectivityManager类里废弃了activeNetworkInfo方法(Java对应getActiveNetworkInfo()方法)。 Android Q查询相关文档，可以找到另一种方法 12345678910111213141516171819fun isNetworkConnectedWithQ(context: Context?): Boolean &#123; var hasNetwork = false if (context != null) &#123; val mConnectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager val networks = mConnectivityManager.allNetworks if (networks.isNotEmpty()) &#123; for (network in networks) &#123; val nc = mConnectivityManager.getNetworkCapabilities(network) if (nc!!.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) &#123; hasNetwork = true &#125; &#125; &#125; &#125; return hasNetwork &#125; 注意：以上代码中allNetworks、getNetworkCapabilities和hasCapability都是在API 21 (Lollipop)被添加的，也就是说最低版本需要21。对此，这里为了兼容到21版本以下，可以将两种方式合并到一个方法中，同时兼容。 同时兼容123456789101112131415161718192021222324fun isNetworkConnected(context: Context?): Boolean &#123; val mConnectivityManager = context?.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager if (Build.VERSION.SDK_INT&lt;Build.VERSION_CODES.Q)&#123; val mNetworkInfo = mConnectivityManager.activeNetworkInfo return mNetworkInfo!=null &amp;&amp; mNetworkInfo.isConnected &#125; var hasNetwork = false val networks = mConnectivityManager.allNetworks if (networks.isNotEmpty()) &#123; for (network in networks) &#123; val nc = mConnectivityManager.getNetworkCapabilities(network) if (nc!!.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) &#123; hasNetwork = true &#125; &#125; &#125; return hasNetwork &#125; 最后，不要忘记在清单文件添加网络权限 12&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; 以上就是针对Android Q上网络检查方式的一个简单的记录，如有不足，欢迎指正]]></content>
      <categories>
        <category>Android</category>
        <category>Android Q</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Q</tag>
        <tag>NetWork</tag>
        <tag>ConnectivityManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q Beta 6 存储示例]]></title>
    <url>%2F2019%2F08%2F13%2Fandroid-q-beta6-storage-sample-record%2F</url>
    <content type="text"><![CDATA[对 Android Q Beta 6 版本上的存储示例，进行一次测试分析并记录 前言官方给出: Android Q 会继续使用 READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE 权限，这些权限与面向用户的存储运行时权限相对应。不过，默认情况下，以 Android Q 为目标平台的应用（以及选择接受这些变更的应用）在访问外部存储设备中的文件时会进入过滤视图。此类应用只能查看特定于应用的目录和特定类型的媒体，因此应用无需请求任何其他用户权限。 环境 编译环境：Ubuntu 19.04 、Android Studio 3.4.2、compileSdkVersion 29、buildToolsVersion “29.0.1”、 targetSdkVersion 29运行环境：Pixel 2 、Android Version 10 (QPP6.190730.005) 、API 29 过程效果界面上有两个按钮，一个写入内容到文件存储，一个是从存储读取文件内容 测试分类类别 1 传统目录方式12345678910111213141516171819202122232425262728/** * 写文件的方法 */ private fun writeMethod() &#123; val file = File(Environment.getExternalStorageDirectory(), "测试Android Q文件.txt") Log.d(tag, "file.exists():$&#123;file.exists()&#125; ， file.getAbsolutePath(): $&#123;file.absolutePath&#125;") if (file.exists()) &#123; file.delete() val flag = file.createNewFile() Log.d(tag, "SD卡目录下创建文件是否成功？:$flag") &#125; val fw = FileWriter(file) fw.write("我是测试Android Q文件写入的内容"); fw.close() Toast.makeText(this@StorageActivity, "SD卡写入内容完成...", Toast.LENGTH_LONG).show() Log.d(tag, "SD卡写入内容完成...") &#125; /** * 读文件的方法 */ private fun readMethod() &#123; val fr = FileReader(Environment.getExternalStorageDirectory().path+"/测试Android Q文件.txt") val r = BufferedReader(fr) val result = r.readLine() Log.d(tag, "SD卡文件里面的内容:$result") &#125; 不加读写权限清单文件不添加如下权限，也没有动态请求代码 12&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 失败，程序异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253542019-08-13 00:42:47.945 9976-9976/com.xw.androidqtest D/StorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/测试Android Q文件.txt2019-08-13 00:42:47.947 9976-9976/com.xw.androidqtest D/AndroidRuntime: Shutting down VM2019-08-13 00:42:47.951 9976-9976/com.xw.androidqtest E/AndroidRuntime: FATAL EXCEPTION: main Process: com.xw.androidqtest, PID: 9976 java.lang.RuntimeException: java.lang.reflect.InvocationTargetException at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:502) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) Caused by: java.lang.reflect.InvocationTargetException at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) Caused by: java.io.FileNotFoundException: /storage/emulated/0/测试Android Q文件.txt: open failed: EACCES (Permission denied) at libcore.io.IoBridge.open(IoBridge.java:496) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186) at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90) at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79) at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21) at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31) at android.view.View.performClick(View.java:7140) at android.view.View.performClickInternal(View.java:7117) at android.view.View.access$3500(View.java:801) at android.view.View$PerformClick.run(View.java:27351) at android.os.Handler.handleCallback(Handler.java:883) at android.os.Handler.dispatchMessage(Handler.java:100) at android.os.Looper.loop(Looper.java:214) at android.app.ActivityThread.main(ActivityThread.java:7356) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied) at libcore.io.Linux.open(Native Method) at libcore.io.ForwardingOs.open(ForwardingOs.java:167) at libcore.io.BlockGuardOs.open(BlockGuardOs.java:252) at libcore.io.ForwardingOs.open(ForwardingOs.java:167) at android.app.ActivityThread$AndroidOs.open(ActivityThread.java:7255) at libcore.io.IoBridge.open(IoBridge.java:482) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186) at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90) at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79) at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21) at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31) at android.view.View.performClick(View.java:7140) at android.view.View.performClickInternal(View.java:7117) at android.view.View.access$3500(View.java:801) at android.view.View$PerformClick.run(View.java:27351) at android.os.Handler.handleCallback(Handler.java:883) at android.os.Handler.dispatchMessage(Handler.java:100) at android.os.Looper.loop(Looper.java:214) at android.app.ActivityThread.main(ActivityThread.java:7356) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) 加读写权限但不动态请求清单文件添加如下权限，但不动态请求 12&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 失败，程序异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556572019-08-13 00:47:52.759 11693-11693/com.xw.androidqtest D/StorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/测试Android Q文件.txt2019-08-13 00:47:52.761 11693-11693/com.xw.androidqtest D/AndroidRuntime: Shutting down VM --------- beginning of crash2019-08-13 00:47:52.766 11693-11693/com.xw.androidqtest E/AndroidRuntime: FATAL EXCEPTION: main Process: com.xw.androidqtest, PID: 11693 java.lang.RuntimeException: java.lang.reflect.InvocationTargetException at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:502) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) Caused by: java.lang.reflect.InvocationTargetException at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) Caused by: java.io.FileNotFoundException: /storage/emulated/0/测试Android Q文件.txt: open failed: EACCES (Permission denied) at libcore.io.IoBridge.open(IoBridge.java:496) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186) at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90) at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79) at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21) at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31) at android.view.View.performClick(View.java:7140) at android.view.View.performClickInternal(View.java:7117) at android.view.View.access$3500(View.java:801) at android.view.View$PerformClick.run(View.java:27351) at android.os.Handler.handleCallback(Handler.java:883) at android.os.Handler.dispatchMessage(Handler.java:100) at android.os.Looper.loop(Looper.java:214) at android.app.ActivityThread.main(ActivityThread.java:7356) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied) at libcore.io.Linux.open(Native Method) at libcore.io.ForwardingOs.open(ForwardingOs.java:167) at libcore.io.BlockGuardOs.open(BlockGuardOs.java:252) at libcore.io.ForwardingOs.open(ForwardingOs.java:167) at android.app.ActivityThread$AndroidOs.open(ActivityThread.java:7255) at libcore.io.IoBridge.open(IoBridge.java:482) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186) at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90) at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79) at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21) at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31) at android.view.View.performClick(View.java:7140) at android.view.View.performClickInternal(View.java:7117) at android.view.View.access$3500(View.java:801) at android.view.View$PerformClick.run(View.java:27351) at android.os.Handler.handleCallback(Handler.java:883) at android.os.Handler.dispatchMessage(Handler.java:100) at android.os.Looper.loop(Looper.java:214) at android.app.ActivityThread.main(ActivityThread.java:7356) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) 加读写权限但并动态请求清单文件添加如下权限，并动态请求 12&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 123456789101112131415161718192021222324252627282930private fun initPermission()&#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; // 检查权限状态 if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; // 用户彻底拒绝授予权限 &#125; else &#123; // 用户未彻底拒绝授予权限 ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), 1) &#125; &#125; &#125; &#125; override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;String&gt;, grantResults: IntArray) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == 1) &#123; for (i in permissions.indices) &#123; if (grantResults[i] == PERMISSION_GRANTED) &#123; // 申请成功 Log.d(tag,"申请成功") &#125; else &#123; // 申请失败 Log.d(tag,"申请失败") &#125; &#125; &#125; &#125; 失败，程序异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556572019-08-13 00:53:45.690 13471-13471/com.xw.androidqtest D/StorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/测试Android Q文件.txt2019-08-13 00:53:45.692 13471-13471/com.xw.androidqtest D/AndroidRuntime: Shutting down VM --------- beginning of crash2019-08-13 00:53:45.698 13471-13471/com.xw.androidqtest E/AndroidRuntime: FATAL EXCEPTION: main Process: com.xw.androidqtest, PID: 13471 java.lang.RuntimeException: java.lang.reflect.InvocationTargetException at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:502) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) Caused by: java.lang.reflect.InvocationTargetException at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) Caused by: java.io.FileNotFoundException: /storage/emulated/0/测试Android Q文件.txt: open failed: EACCES (Permission denied) at libcore.io.IoBridge.open(IoBridge.java:496) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186) at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90) at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79) at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21) at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31) at android.view.View.performClick(View.java:7140) at android.view.View.performClickInternal(View.java:7117) at android.view.View.access$3500(View.java:801) at android.view.View$PerformClick.run(View.java:27351) at android.os.Handler.handleCallback(Handler.java:883) at android.os.Handler.dispatchMessage(Handler.java:100) at android.os.Looper.loop(Looper.java:214) at android.app.ActivityThread.main(ActivityThread.java:7356) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied) at libcore.io.Linux.open(Native Method) at libcore.io.ForwardingOs.open(ForwardingOs.java:167) at libcore.io.BlockGuardOs.open(BlockGuardOs.java:252) at libcore.io.ForwardingOs.open(ForwardingOs.java:167) at android.app.ActivityThread$AndroidOs.open(ActivityThread.java:7255) at libcore.io.IoBridge.open(IoBridge.java:482) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:235) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:186) at java.io.FileWriter.&lt;init&gt;(FileWriter.java:90) at com.xw.androidqtest.StorageActivity.writeMethod(StorageActivity.kt:79) at com.xw.androidqtest.StorageActivity.access$writeMethod(StorageActivity.kt:21) at com.xw.androidqtest.StorageActivity$onCreate$1.onClick(StorageActivity.kt:31) at android.view.View.performClick(View.java:7140) at android.view.View.performClickInternal(View.java:7117) at android.view.View.access$3500(View.java:801) at android.view.View$PerformClick.run(View.java:27351) at android.os.Handler.handleCallback(Handler.java:883) at android.os.Handler.dispatchMessage(Handler.java:100) at android.os.Looper.loop(Looper.java:214) at android.app.ActivityThread.main(ActivityThread.java:7356) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930) 类别 2 特定目录方式1234567891011121314151617181920212223242526272829 /** * 写文件的方法 */ private fun writeMethod() &#123;//这里我们创建的是一个文本txt,getExternalFilesDir使用Environment.DIRECTORY_DOCUMENTS类型 val file = File(this@StorageActivity.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), "测试Android Q文件.txt") Log.d(tag, "file.exists():$&#123;file.exists()&#125; ， file.getAbsolutePath(): $&#123;file.absolutePath&#125;") if (file.exists()) &#123; file.delete() val flag = file.createNewFile() Log.d(tag, "SD卡目录下创建文件是否成功？:$flag") &#125; val fw = FileWriter(file) fw.write("我是测试Android Q文件写入的内容"); fw.close() Toast.makeText(this@StorageActivity, "SD卡写入内容完成...", Toast.LENGTH_LONG).show() Log.d(tag, "SD卡写入内容完成...") &#125; /** * 读文件的方法 */ private fun readMethod() &#123;//这里我们创建的是一个文本txt,getExternalFilesDir使用Environment.DIRECTORY_DOCUMENTS类型 val fr = FileReader(this@StorageActivity.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS)!!.path+"/测试Android Q文件.txt") val r = BufferedReader(fr) val result = r.readLine() Log.d(tag, "SD卡文件里面的内容:$result") &#125; 不加读写权限清单文件不添加如下权限，也没有动态请求代码 12&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 成功，程序正常运行 1232019-08-13 01:01:40.653 14721-14721/com.xw.androidqtest D/StorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/Android/data/com.xw.androidqtest/files/Documents/测试Android Q文件.txt2019-08-13 01:01:40.671 14721-14721/com.xw.androidqtest D/StorageActivity: SD卡写入内容完成...2019-08-13 01:01:54.410 14721-14721/com.xw.androidqtest D/StorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容 查看设备上应用详情的相关权限模块，并没有相应的权限请求 加读写权限但不动态请求清单文件添加如下权限，但不动态请求 12&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 成功，程序正常运行 12342019-08-13 01:12:22.104 18040-18040/com.xw.androidqtest D/StorageActivity: file.exists():true ， file.getAbsolutePath(): /storage/emulated/0/Android/data/com.xw.androidqtest/files/Documents/测试Android Q文件.txt2019-08-13 01:12:22.105 18040-18040/com.xw.androidqtest D/StorageActivity: SD卡目录下创建文件是否成功？:true2019-08-13 01:12:22.116 18040-18040/com.xw.androidqtest D/StorageActivity: SD卡写入内容完成...2019-08-13 01:12:26.276 18040-18040/com.xw.androidqtest D/StorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容 查看设备上应用详情的相关权限模块，有相应的存储权限请求，为拒绝状态 加读写权限但并动态请求清单文件添加如下权限，并动态请求 12&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 123456789101112131415161718192021222324252627282930private fun initPermission()&#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; // 检查权限状态 if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; // 用户彻底拒绝授予权限 &#125; else &#123; // 用户未彻底拒绝授予权限 ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), 1) &#125; &#125; &#125; &#125; override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;String&gt;, grantResults: IntArray) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == 1) &#123; for (i in permissions.indices) &#123; if (grantResults[i] == PERMISSION_GRANTED) &#123; // 申请成功 Log.d(tag,"申请成功") &#125; else &#123; // 申请失败 Log.d(tag,"申请失败") &#125; &#125; &#125; &#125; 成功，程序正常运行 123452019-08-13 01:16:06.530 19535-19535/com.xw.androidqtest D/StorageActivity: 申请成功2019-08-13 01:16:09.301 19535-19535/com.xw.androidqtest D/StorageActivity: file.exists():true ， file.getAbsolutePath(): /storage/emulated/0/Android/data/com.xw.androidqtest/files/Documents/测试Android Q文件.txt2019-08-13 01:16:09.303 19535-19535/com.xw.androidqtest D/StorageActivity: SD卡目录下创建文件是否成功？:true2019-08-13 01:16:09.316 19535-19535/com.xw.androidqtest D/StorageActivity: SD卡写入内容完成...2019-08-13 01:16:12.023 19535-19535/com.xw.androidqtest D/StorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容 结论1.Android Q 如果调用Environment.getExternalStorageDirectory()，需要添加READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE权限，并动态请求权限，同时还需要添加新的清单属性为requestLegacyExternalStorage,否则会出现类别1的测试结果 123456&lt;manifest ... &gt; &lt;!-- This attribute is "false" by default on apps targeting Android Q. --&gt; &lt;application android:requestLegacyExternalStorage="true" ... &gt; ... &lt;/application&gt;&lt;/manifest&gt; 这样添加完成之后，getExternalStorageDirectory方式就能执行成功了。 2、Android Q 如果调用Environment.getExternalFilesDir()。正如官方所言，默认情况下，以 Android Q 为目标平台的应用（以及选择接受这些变更的应用）在访问外部存储设备中的文件时会进入过滤视图。此类应用只能查看特定于应用的目录和特定类型的媒体，因此应用无需请求任何其他用户权限。（类别2测试示例体现） 以上内容简单的对Android Q 存储方式进行简单的示例说明。如果有不足之处，欢迎指正。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Q</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Q</tag>
        <tag>Storage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q 气泡]]></title>
    <url>%2F2019%2F04%2F07%2Fandroid-q-beta2-bubbles%2F</url>
    <content type="text"><![CDATA[本节内容测试Android Q新功能 —— 气泡 当前文章首次编辑于Android Q Beta 2 版本，可能部分内容会在后期版本上发生变化，仅供参考 气泡是Android Q中的一项新功能。通过气泡，用户可以轻松地从设备上的任何位置进行多任务处理。 气泡内置于通知系统中。 它们会浮动在其他应用内容之上，并随时随地关注用户。 可以扩展气泡以显示应用程序功能和信息，并且可以在不使用时折叠。 当设备被锁定或始终显示处于活动状态时，气泡就会像通常那样出现。 气泡是一种选择退出功能。 当应用程序显示其第一个气泡时，会显示一个权限对话框，提供两个选项： 1.阻止您应用中的所有气泡 - 通知不会被阻止，但它们永远不会显示为气泡 2.允许来自您应用的所有气泡 - 使用BubbleMetaData发送的所有通知都将显示为气泡 Bubble API气泡是通过通知API创建的，您可以像往常一样发送通知。如果你想让它冒泡，你需要附加一些额外的数据到它。 气泡的展开视图是由您选择的Activity创建的。需要将Activity配置为适当显示为气泡。该Activity必须可调整大小、嵌入并始终以文档UI模式启动。如果它缺少这些要求中的任何一个，它将以通知的形式显示。 下面的代码演示了如何实现一个简单的气泡: 12345678&lt;activity android:name=".bubbles.BubbleActivity" android:theme="@style/AppTheme.NoActionBar" android:label="@string/title_activity_bubble" android:allowEmbedded="true" android:documentLaunchMode="always" android:resizeableActivity="true"/&gt; 如果您的应用程序显示多个相同类型的气泡，比如多个联系人的聊天对话，则该活动必须能够启动多个实例。将documentLaunchMode设置为“always”。 要发送气泡，请遵循以下步骤: 1、像平常一样创建通知。 2、调用Notification.BubbleMetadata.Builder创建一个BubbleMetadata对象。 3、使用setBubbleMetadata将元数据添加到通知中。 1234567891011121314151617181920212223// Create bubble intentval target = Intent(context, BubbleActivity::class.java)val bubbleIntent = PendingIntent.getActivity(context, 0, target, 0 /* flags */)// Create bubble metadataval bubbleData = Notification.BubbleMetadata.Builder() .setDesiredHeight(600) // Note: although you can set the icon is not displayed in Q Beta 2 .setIcon(Icon.createWithResource(context, R.drawable.icon)) .setIntent(bubbleIntent) .build()// Create notificationval chatBot = Person.Builder() .setBot(true) .setName("BubbleBot") .setImportant(true) .build()val builder = Notification.Builder(context, CHANNEL_ID) .setContentIntent(contentIntent) .setSmallIcon(smallIcon) .setBubbleMetadata(bubbleData) 注意:第一次发送显示气泡的通知时，它必须位于IMPORTANCE_HIGH的通知通道中。这是因为气泡是由通知重要性管理器处理的。如果系统在用户有机会允许或阻止冒泡之前降低了通知的重要性，则通知将不会冒泡。 如果您的应用程序在发送气泡时位于前台，那么重要性将被忽略，并且您的气泡将始终显示(除非用户已经阻止了气泡或来自应用程序的通知)。 创建扩展的气泡您可以配置气泡以自动将其呈现为展开状态。 我们建议仅在用户执行可能导致冒泡的操作时使用此功能，例如点按按钮以开始新聊天。 在这种情况下，抑制创建气泡时发送的初始通知也是有意义的。 您可以使用一些方法来设置启用这些行为的标志：setAutoExpandBubble()和setSuppressInitialNotification 注意:虽然您可以在Android Q Beta 2中设置这些标志，但它们还没有任何效果。 123456val bubbleMetadata = Notification.BubbleMetadata.Builder() .setDesiredHeight(600) .setIntent(bubbleIntent) .setAutoExpandBubble(true) .setSuppressInitialNotification(true) .build() 最佳实践1、气泡占据了屏幕空间，并覆盖了其他应用程序内容。只有在非常重要的情况下(比如正在进行的通信)，或者用户明确要求某些内容使用冒泡时，才应该将通知作为冒泡发送。 2、注意，用户可以禁用气泡。在这种情况下，气泡通知显示为正常通知。您应该始终确保气泡通知与正常通知一样工作。 3、从气泡中启动的流程(如活动和对话框)出现在气泡容器中。这意味着一个气泡可以有一个任务堆栈。如果气泡中有很多功能或导航，事情就会变得复杂。我们建议保持功能尽可能的具体和轻量级。 测试示例创建BubbleActivity，在AndroidManifest.xml添加如下代码 123456&lt;activity android:name=".BubbleActivity" android:theme="@style/AppTheme.NoActionBar" android:label="@string/title_activity_bubble" android:allowEmbedded="true" android:documentLaunchMode="always" android:resizeableActivity="true"&gt; 其中AppTheme.NoActionBar主题代码 123456&lt;style name="AppTheme.NoActionBar"&gt; &lt;item name="windowActionBar"&gt;false&lt;/item&gt; &lt;item name="windowNoTitle"&gt;true&lt;/item&gt; &lt;item name="android:windowDrawsSystemBarBackgrounds"&gt;true&lt;/item&gt; &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; 在MainActivity中，定义NotificatioManager对象 1private var notificationManager: NotificationManager? = null 并在onCreate方法初始化 1notificationManager = this@MainActivity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager 定义常量 1234companion object &#123; private const val REQUEST_CONTENT = 1 private const val REQUEST_BUBBLE = 2 &#125; 定义显示Bubble气泡的方法 123456789101112131415161718192021222324252627282930313233343536373839404142private fun showBubble() &#123; Log.d(tag, "show bubble") //创建通知渠道 val channel = NotificationChannel("通知渠道ID", "通知渠道名称", NotificationManager.IMPORTANCE_HIGH) notificationManager!!.createNotificationChannel(channel) // val icon = Icon.createWithResource(this@MainActivity, R.mipmap.ic_launcher_round) // val person = Person.Builder() .setName("Person Name") .setIcon(icon) .build() val contentIntent = PendingIntent.getActivity( this@MainActivity,REQUEST_CONTENT, Intent(this@MainActivity, MainActivity::class.java), PendingIntent.FLAG_UPDATE_CURRENT) val bubbleIntent = PendingIntent.getActivity( this@MainActivity, REQUEST_BUBBLE, Intent(this@MainActivity, BubbleActivity::class.java), PendingIntent.FLAG_UPDATE_CURRENT) val bubbleMetadata = Notification.BubbleMetadata.Builder() .setDesiredHeight(400) .setIcon(icon) .setAutoExpandBubble(true) .setSuppressInitialNotification(true) .setIntent(bubbleIntent) .build() val builder = Notification.Builder(this@MainActivity, "通知渠道ID") .setContentTitle("Bubble") .setContentText("测试Android Q Bubble") .setContentIntent(contentIntent) .setSmallIcon(icon) .setBubbleMetadata(bubbleMetadata) .addPerson(person) .setShowWhen(true) notificationManager!!.notify(0, builder.build()); &#125; 在按钮的点击事件中调用showBubble方法，触发通知，并显示气泡 通知栏出现通知消息，屏幕右侧显示出了气泡（气泡好像没有图标，上文中有提到，即使设置了也不会在Q Beta 2上显示） 下拉通知栏，可以看到创建的通知消息 长按快捷方式的效果 点击气泡，会触发打开BubbleActivity并弹出窗口，可以看到右上角两个图标，左下角一个，右下角一个 首先我们看看左下角的图标，点击了会弹出两个选项，一个添加应用快捷方式，另一个设置壁纸 点击第一个添加应用快捷方式，可以列出当前设备安装的应用 随机点了两个，一个微信，一个支付宝，添加进去。添加完成之后，从此处点击过去，就能直接打开跳转到指定的应用程序 (添加进去还没测试如何移除，试过了清除数据和重新安装都没效果) 点击右上角箭头的的图标可以直接进入 —— MainActivity 点击右上角的齿轮，可以跳转的该应用的通知的设置 点击具体的一条通知渠道后面的齿轮，可以详细的进入具体的通知渠道设置 然后气泡右下角的图标，类似于快捷launcher桌面，可以直接访问桌面的所有应用程序，点击也是直接打开跳转到指定的应用程序中 最后，长按气泡图标，拖拽到底部指定区域，可以销毁气泡 判断是否允许了气泡的方法 1234fun canBubble(): Boolean &#123; val channel = notificationManager!!.getNotificationChannel("通知渠道ID") return notificationManager!!.areBubblesAllowed() &amp;&amp; channel.canBubble()&#125; 本文参考官方文档和官方示例简单总结，感谢您的阅读。如有不足，欢迎指正]]></content>
      <categories>
        <category>Android</category>
        <category>Android Q</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Q</tag>
        <tag>Bubbles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q 访问剪切板数据]]></title>
    <url>%2F2019%2F03%2F27%2Fandroid-q-beta-access-clipboard-data%2F</url>
    <content type="text"><![CDATA[本节内容测试Android Q对剪切板数据的访问 当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考 变化Android Q 对访问剪切板数据进行了限制，非系统默认输入法以及后台运行的程序是无法访问到剪切板数据 测试示例 —— 后台运行的程序访问剪切板测试之前我复制了本博客地址:https://shoewann0402.github.io 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.xw.clipboarddemoimport android.content.ClipboardManagerimport android.content.Contextimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.util.Logimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity() &#123; private val tag: String = MainActivity::class.java.simpleName private var cm: ClipboardManager? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) cm = this.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager? //1.直接获取剪切板数据 getClipboardData() //2.点击按钮获取剪切板数据 btn_get_clipboard_data.setOnClickListener &#123; getClipboardData() &#125; &#125; //获取剪切板数据的方法 private fun getClipboardData() &#123; Log.d(tag, getString(R.string.get_clipboard_data)) //如果当前剪贴板上存在Copy返回True val hasPrimaryClip = cm!!.hasPrimaryClip() Log.d(tag, "$&#123;getString(R.string.hasPrimaryClip)&#125;$hasPrimaryClip") if (hasPrimaryClip) &#123; val abc = cm!!.primaryClip if (abc != null) &#123; val item = abc.getItemAt(0) val text = item.text.toString() Log.d(tag, "$&#123;getString(R.string.clipboard_data)&#125;$text") &#125; //对剪贴板文字的操作 &#125; &#125;&#125; 当应用加载成功，输出日志: 122019-03-27 17:17:17.127 26244-26244/com.xw.clipboarddemo D/MainActivity: 获取剪切板数据2019-03-27 17:17:17.128 26244-26244/com.xw.clipboarddemo D/MainActivity: 剪切板是否含有复制数据:false 然后点击按钮，输出日志: 1232019-03-27 17:17:18.924 26244-26244/com.xw.clipboarddemo D/MainActivity: 获取剪切板数据2019-03-27 17:17:18.924 26244-26244/com.xw.clipboarddemo D/MainActivity: 剪切板是否含有复制数据:true2019-03-27 17:17:18.925 26244-26244/com.xw.clipboarddemo D/MainActivity: [剪切板数据]:https://shoewann0402.github.io 可见Android Q上只有当前应用获取了焦点，运行在前台才能访问到剪切板数据，在后台无法获取到剪切板的数据 针对默认键盘这种方式的，这里不做测试了 本文参考官方文档简单总结，感谢您的阅读。如有不足，欢迎指正]]></content>
      <categories>
        <category>Android</category>
        <category>Android Q</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Q</tag>
        <tag>Clipboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q 应用切换WiFi开关的限制]]></title>
    <url>%2F2019%2F03%2F20%2Fandroid-q-beta-enable-and-disable-wifi%2F</url>
    <content type="text"><![CDATA[Android Q 不允许应用程序开/关WIFI 当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考 目的Android Q 将切断应用对Wi-Fi设置的访问权限，防止恶意软件滥用系统功能的访问权限。 变化运行在Q上的应用程序将无法启用/禁用WIFI, WifiManager.setWifiEnabled()方法始将终返回false,该方法不被允许 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.xw.androidqtestimport android.content.Contextimport android.net.wifi.WifiManagerimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.util.Logclass WifiActivity : AppCompatActivity() &#123; private val tag: String = WifiActivity::class.java.simpleName private var wifiManager: WifiManager? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_wifi) wifiManager = this.getSystemService(Context.WIFI_SERVICE) as WifiManager? val isWifiEnabled = wifiManager!!.isWifiEnabled Log.d(tag, "[默认状态]是否开启 :$isWifiEnabled") when (isWifiEnabled) &#123; true -&gt; &#123; Log.d(tag, "[关闭]WiFi，设置WiFi状态为: false") wifiManager!!.isWifiEnabled = false val result = wifiManager!!.isWifiEnabled Log.d(tag, "当前状态:$result") if (result) &#123; Log.d(tag, "检查到当前是true[开启状态], 关闭WiFi: [失败]") &#125; else &#123; Log.d(tag, "检查到当前是false[关闭状态], 关闭WiFi: [成功]") &#125; &#125; else -&gt; &#123; Log.d(tag, "[开启]WiFi，设置WiFi状态为: true") wifiManager!!.isWifiEnabled = true val result = wifiManager!!.isWifiEnabled Log.d(tag, "当前状态:$result") if (result) &#123; Log.d(tag, "检查当前是true[开启状态], 开启WiFi: [成功]") &#125; else &#123; Log.d(tag, "检查当前是false[关闭状态], 开启WiFi: [失败]") &#125; &#125; &#125; &#125;&#125; 当WiFi默认是开启的情况下，需要代码关闭WiFi，输出日志: 1234562019-03-20 08:24:51.741 1213-1650/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.WifiActivity&#125; from uid 105052019-03-20 08:24:51.779 11562-11562/? D/WifiActivity: [默认状态]是否开启 :true2019-03-20 08:24:51.779 11562-11562/? D/WifiActivity: [关闭]WiFi，设置WiFi状态为: false2019-03-20 08:24:51.781 1213-1650/? I/WifiService: setWifiEnabled not allowed for uid=105052019-03-20 08:24:51.781 11562-11562/? D/WifiActivity: 当前状态:true2019-03-20 08:24:51.781 11562-11562/? D/WifiActivity: 检查到当前是true[开启状态], 关闭WiFi: [失败] 当WiFi默认是关闭的情况下，需要代码开启WiFi，输出日志: 1234562019-03-20 08:27:00.212 1213-3863/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.WifiActivity&#125; from uid 105052019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: [默认状态]是否开启 :false2019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: [开启]WiFi，设置WiFi状态为: true2019-03-20 08:27:00.245 1213-5152/? I/WifiService: setWifiEnabled not allowed for uid=105052019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: 当前状态:false2019-03-20 08:27:00.245 11562-11562/? D/WifiActivity: 检查当前是false[关闭状态], 开启WiFi: [失败] 通过以上的示例可以看到，不论是开启还是关闭WiFi都没有效果，系统都将返回false，并输出setWifiEnabled不被允许的日志信息: 1setWifiEnabled not allowed for uid= xxxx 解决方法使用设置面板提示用户启用和禁用Wi-Fi，调用Settings.Panel.ACTION_INTERNET_CONNECTIVITY 1startActivity(Intent(Settings.Panel.ACTION_INTERNET_CONNECTIVITY)) 本文参考官方文档简单总结，感谢您的阅读。如有不足，欢迎指正]]></content>
      <categories>
        <category>Android</category>
        <category>Android Q</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Q</tag>
        <tag>WIFI</tag>
        <tag>setWifiEnabled</tag>
        <tag>Settings Panel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q 设置面板]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid-q-beta-settings-panel%2F</url>
    <content type="text"><![CDATA[Android Q 引入了设置面板，它是一种API, 允许从应用程序上下文直接向用户展示设置。 当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考 目的避免了用户为了使用应用程序而需要进入设置来更改NFC或移动数据等内容。 场景例如，假设用户在其设备处于飞行模式时打开Web浏览器。 在Android Q之前，该应用只能显示一条通用消息，要求用户打开“设置”以恢复连接。 使用Android Q，浏览器应用程序可以显示一个内联面板，显示关键的连接设置，如飞行模式，Wi-Fi（包括附近的网络）和移动数据。 使用此面板，用户无需离开应用即可恢复连接。 使用这一新功能目前暂提供了网络连接、NFC、音量三个设置面板,使我们可以访问这三个不同的设置面板，所有这些面板都可以通过简单的startActivity()调用启动。 网络连接1Settings.Panel.ACTION_INTERNET_CONNECTIVITY 面板属性: 启用/禁用飞行模式 启用/禁用WIFI连接 启用/禁用移动数据 更改WIFI连接 导航到连接设置 NFC1Settings.Panel.ACTION_NFC 面板属性: 显示与近场通信（NFC）相关的所有设置。 音量1Settings.Panel.ACTION_VOLUME 面板属性: 媒体音量 通话音量 铃声音量 闹钟音量 示例123456789101112131415161718192021222324252627282930313233343536package com.xw.androidqtestimport android.content.Intentimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.provider.Settingsimport android.util.Logimport kotlinx.android.synthetic.main.activity_settings_panel.*class SettingsPanelActivity : AppCompatActivity() &#123; private val tag: String = SettingsPanelActivity::class.java.simpleName override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_settings_panel) btnConnectivity.setOnClickListener &#123; openSettings(Settings.Panel.ACTION_INTERNET_CONNECTIVITY) &#125; btnNFC.setOnClickListener &#123; openSettings(Settings.Panel.ACTION_NFC) &#125; btnVolume.setOnClickListener &#123; openSettings(Settings.Panel.ACTION_VOLUME) &#125; &#125; private fun openSettings(panel: String) &#123; Log.d(tag, "panel:$panel") val intent = Intent(panel) startActivity(intent) &#125;&#125; 本文参考官方文档及示例简单总结，感谢您的阅读。如有不足，欢迎指正]]></content>
      <categories>
        <category>Android</category>
        <category>Android Q</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Q</tag>
        <tag>Settings Panel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q 独立存储]]></title>
    <url>%2F2019%2F03%2F17%2Fandroid-q-beta-scoped-storage%2F</url>
    <content type="text"><![CDATA[Android Q 系统, 对应用存储空间访问进行了限制。 当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考 目的为了让用户更好地控制文件并限制文件混乱，Android Q 改变了应用程序访问设备外部存储上文件的方式 变化 使用更精细粒度、特殊媒体权限取代READ_EXTERNAL_STORAGE 和WRITE_EXTERNAL_STORAGE 权限 应用程序从外部存储设备访问自己的文件不需要特殊权限 更新变化 -&gt; Q beta5以下内容是 Q beta 5 上最新的变化 (临时添加部分内容) 1、您可以使用新的requestLegacyExternalStorage manifest属性在Android Q设备上启用应用程序的新行为，即使您的应用程序的目标是Android 9或更低。 1234567&lt;manifest ... &gt; &lt;!--在目标版本为 Android Q 的应用程序上这个属性值默认情况下为 false --&gt; &lt;!-- This attribute is "false" by default on apps targeting Android Q. --&gt; &lt;application android:requestLegacyExternalStorage="true" ... &gt; ... &lt;/application&gt;&lt;/manifest&gt; 2、Android Q继续使用READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限，这两个权限对应于面向存储用户的运行时权限。3、早期测试版本中引入的特定于媒体集合的权限，现已过时 READ_MEDIA_IMAGES READ_MEDIA_AUDIO READ_MEDIA_VIDEO 更多变化和使用参见官方文档影响这些更改会影响您的应用保存和访问外部存储上的文件的方式。 沙箱独立存储应用私有文件Android Q 为每一个应用在外部存储设备内采用了沙箱独立存储。比如/sdcard, 没有其他应用程序能够直接访问您应用程序沙箱内的文件，因为对于您的应用程序来说这些文件是私有的，您不再需要任何权限去访问和保存您自己外部存储中的文件，这一变化使维护用户文件的隐私变得更容易，并有助于减少应用程序所需的权限数量。 【注意】如果用户手动卸载了应用程序，沙箱内的私有文件也会被清理 通过Context.getExternalFilesDir()返回的位置是在外部存储上存储文件的最佳位置。因为这个位置在所有Android版本上的行为都是一致的。使用此方法时，请传入与要创建或打开的文件类型对应的媒体环境，比如说，访问或保存应用程序私有图片，调用Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES) 分享媒体文件集如果您的应用程序创建的文件属于用户，用户希望在当应用程序被卸载之后这些文件能够被保留，然后保存到一个公共的媒体集，也称为共享集合。共享集合包括：图片&amp;视频、音乐以及下载 查看其他应用程序文件的权限在这些共享集合中您的应用程序为了创建和变更它自己的文件不需要请求任何的权限。如果您的应用需要去创建和变更其他应用程序创建的文件，它必须首先要请求适当的权限 在图片&amp;视频共享集合中去访问其他应用的文件需要请求READ_MEDIA_IMAGES或者 READ_MEDIA_VIDEO权限，依赖您的应用程序需要去访问的文件类型 在音乐共享集合中去访问其他应用的文件需要请求READ_MEDIA_AUDIO权限 【注意】这里没有访问下载共享集合的权限。您的应用程序能够在这个集合里访问它自己的文件，对于访问这个集合里其他应用程序的文件，您必须使用系统文件选择器应用程序允许用户去选择一个文件 【注意】如果您的应用使用了Storage Access Framework(存储访问框架),它不需要去请求这些独立的媒体权限 访问共享集合请求必要的权限之后，您的应用程序使用MediaStoreAPI 访问这些集合 图片 &amp; 视频 共享集合 —— 使用MediaStore.Images或MediaStore.Video 音乐 共享集合 —— 使用MediaStore.Audio 下载 共享集合 —— 使用MediaStore.Downloads【警告】对于新安装在Android Q上的应用程序，调用getExternalStoragePublicDirectory,只提供对应用程序存储在其隔离存储沙箱中的文件的访问。保持对其他应用程序文件的访问权限，更新应用程序的逻辑，使用MediaStore代替 保留应用程序在共享集合中的文件默认情况下，当用户卸载了您的应用程序，Android Q 会清理您保存在沙箱中的文件。当您应用程序被卸载时对于保留这些文件，使用Storage Access Framework(存储访问框架)或者保存到一个共享集合。 要保留文件到共享集合，请在相关的MediaStore集合中插入新行，并按以下方式填充其列 最低限度，为DISPLAY_NAME和MIME_TYPE列提供值 可选性，您能够使用PRIMARY_DIRECTORY和SECONDARY_DIRECTORY列影响文件放置在磁盘上的位置。 不定义DATA列，这样，平台可以灵活地将文件保存在您的沙箱之外。 插入之后，您能够使用像ContentResolver.openFileDescriptor()读写数据到新创建的文件 如果用户在之后重新安装了您的应用，您的应用程序不会访问这些文件，除非它执行以下操作之一： 请求相应的集合权限 从存储访问框架向用户发送请求。这种情况类似于应用程序尝试访问其他应用程序文件的情况。 照片的特殊注意事项Android Q 添加了几个增强功能，让用户更好的控制在外部存储上他们照片的访问 访问照片的位置有一些照片在它们Exif元数据中包含了位置信息，允许用户查看照片的拍摄地。因为这些位置信息是敏感的，Android Q 默认情况下重新编辑了这些信息。这个位置信息的限制不同于适用于相机特性的限制。 【注意】如果您的应用程序是用户默认的照片管理应用程序，平台将会自动给予您应用程序访问照片中的位置信息。 如果您的应用程序需要访问一个照片的位置，需要完成如下步骤 1.添加新的权限ACCESS_MEDIA_LOCATION到您应用程序的清单中2.从您的MediaStore对象，调用setRequireOriginal()，传入照片的URI 展示用户图库照片如果您的应用程序是一个相机应用，它无法直接访问保存在图片&amp;视频共享集合中的照片，除非它是默认的照片管理应用，要将用户引导到图库应用程序，请使用ACTION_REVIEW intent意图。 处理其他应用程序的文件这个环节解释应用程序如何与存储在共享集合中的其他应用程序的文件进行交互。 访问其他应用创建的文件在一个外部存储设备上，访问和读取其他应用程序的已经保存的媒体文件，分为以下几步： 1.请求必要的权限，基于包含您要访问的文件的共享集合。2.使用ContentResolver对象去查找并打开文件 【注意】ContentResolver类包含了一个新的方法，loadThumbnail(),提供给您应用预览文件。最好先调用loadThumbnail(),以便用户能够查看媒体文件快照无需您的应用程序加载所有文件本身。这个方法还允许更灵活的请求，比如请求特殊维度和取消请求的能力。 写入其他应用创建的文件通过保存文件到共享集合，您的应用程序将成为该文件的所有者。通常情况下，您的应用程序能够写入到共享集合的文件，除非您是这个文件的所有者。如果您的应用程序有正确的角色分配给它，您也能够写入到其他应用程序自己的文件： 如果您的应用程序是用户默认的照片管理应用，你能够变更其他应用保存在图片&amp;视频共享集合里的图片文件 如果您的应用程序是用户默认的音乐应用，您能够变更其他应用程序保存在音乐共享集合里的音频文件 【注意】您的应用程序应该保持功能，无论它是默认的照片管理器或音乐应用程序。 要变更其他应用保存在外部存储设备中原始的媒体文件，完成如下步骤之一： 通过角色指南检查您的应用是否是默认的图片管理应用或者默认的音乐管理应用 使用ContentResolver对象查找文件并变更它，当执行编辑/变更操作，捕获RecoverableSecurityException以便您能够请求用户授予您写入的特殊项 访问特殊文件在一些使用情况中，您的应用或许需要打开或者创建权限，它无需要有访问权限： 在照片编辑应用程序中，打开一张图片。 在商业产品应用中，保存文本文档到本地让用户选择 允许用户去选择特殊文件打开，或者选择特殊位置保存文件，对于这些解决方案，使用存储访问框架 配套的app文件共享如果您管理一套需要互相访问彼此文件的应用程序，使用content://URIs,我们已经建议作为安全性最佳实践。 更多信息，请查阅文档如何设置文件共享 升级设备上以前安装的应用程序的兼容性模式限制外部存储中的文件访问应用于应用程序target目标版本是Android Q,或者运行在Android Q设备上最新安装的应用 当满足如下条件时，系统会将您的应用文件访问设置为兼容模式: target version &lt; = Android 9 (API 28) 您安装在设备上的应用从[ Android 9 ] –&gt; 升级到—&gt; [ Android Q ] 当您的应用程序进入兼容模式，以下文件访问行为适用： 您的应用程序能够访问MediaStore集合内所有的文件存储，甚至是您的应用程序没有创建的文件。 面向用户的是允许或拒绝您的应用程序访问整个外部存储的权限，而不是像图片&amp;视频或者音乐这样单独的共享集合 这个兼容模式直到您首次卸载您的应用程序仍然有效 【注意】如果您的应用程序之后在同一设备重新安装，兼容模式不会重新被激活 识别特殊的外部存储设备SDK &lt; = Android 9 (API 28) —— 在所有的外部存储设备上的所有文件都显示在当个&quot;external&quot;(外部)卷标下 Android Q, 给每一个外部存储设备一个不一样的卷标，这意味着系统帮助您有效地组织和索引内容，它可以让您控制新内容的存储位置 【注意】主外部存储设备始终使用卷名“external”。 对于外部存储内唯一地标识特殊文件，您必须使用卷标名和ID一起。比如说，一个文件在主存储设备将是content://media/external/images/media/12，但是二级存储设备上名为FA23-3E92的相应文件将是content://media/FA23-3E92/images/media/12 您能够在特殊的卷上，通过传入卷标名到特殊媒体集访问存储文件。比如说MediaStore.Images.getContentUri() 获取外部存储设备列表要获取所有当前可用的卷标名称列表，调用call MediaStore.getAllVolumeNames() 1val volumeNames: Set&lt;String&gt; = MediaStore.getAllVolumeNames(context) 设置一个虚拟的外部存储设备在没有可移动外部存储的设备上，使用以下命令启用虚拟磁盘以进行测试: 1adb shell sm set-virtual-disk true 测试行为变化为了帮助您使应用程序与此新行为变化兼容，平台提供了多种方法来调整与更改相关的多个参数。 切换行为更改要在Android Q Beta 1中启用此行为更改，请在终端窗口中执行以下命令： 1adb shell sm set-isolated-storage on 运行此命令后，设备将重新启动。 如果没有，请等一下再尝试再次运行该命令。 要确认行为变化是否已生效，请使用以下命令： 1adb shell getprop sys.isolated_storage_snapshot 测试兼容模式行为测试应用程序时，可以通过在终端窗口中运行以下命令来启用外部文件存储访问的兼容性模式： 1adb shell cmd appops set your-package-name android:legacy_storage allow 要禁用兼容模式，请在Android Q上卸载并重新安装您的应用，或在终端窗口中运行以下命令： 1adb shell cmd appops set your-package-name android:legacy_storage default 将外部存储作为文件管理器浏览获得对外部存储中的目录的广泛访问,就像文件管理器应用程序可能做的那样,使用ACTION_OPEN_DOCUMENT_TREE意图，比如说，在GitHub上查看android-DirectorySelection示例。 【警告】在Android Q中不推荐使用StorageVolume类中的createAccessIntent（） 方法，因此不应使用此方法浏览外部存储设备。 如果您这样做，运行Android Q设备的用户将无法在您的应用中查看保存在外部存储中的文件。 测试示例文件存储测试 1 —— 默认方式 getExternalStorageDirectory定义一个Activity——FileStorageActivity，然后定义如下读写方法，通过界面上两个按钮触发，进行默认getExternalStorageDirectory路径下文件的读写测试，运行在Android Q 设备也无需在清单文件定义READ_EXTERNAL_STORAGE 和WRITE_EXTERNAL_STORAGE权限 123456789101112131415161718192021private fun writeMethod() &#123; val file = File(Environment.getExternalStorageDirectory(), "测试Android Q文件.txt"); Log.d(tag, "file.exists():$&#123;file.exists()&#125; ， file.getAbsolutePath(): $&#123;file.absolutePath&#125;"); if (file.exists()) &#123; file.delete(); file.createNewFile(); &#125; Toast.makeText(this@FileStorageActivity, "SD卡目录下创建文件成功...", Toast.LENGTH_LONG).show(); val fw = FileWriter(file); fw.write("我是测试Android Q文件写入的内容"); fw.close() Toast.makeText(this@FileStorageActivity, "SD卡写入内容完成...", Toast.LENGTH_LONG).show() Log.d(tag, "SD卡写入内容完成..."); &#125; private fun readMethod() &#123; val fr = FileReader(Environment.getExternalStorageDirectory().path+"/测试Android Q文件.txt"); val r = BufferedReader(fr); val result = r.readLine(); Log.d(tag, "SD卡文件里面的内容:$result") &#125; 输出日志： 1232019-03-17 14:06:46.117 31140-31140/com.xw.androidqtest D/FileStorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/测试Android Q文件.txt2019-03-17 14:06:46.130 31140-31140/com.xw.androidqtest D/FileStorageActivity: SD卡写入内容完成...2019-03-17 14:06:50.346 31140-31140/com.xw.androidqtest D/FileStorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容 查看/sdcard根下的文件，发现没有该文件，被系统自动存放在如下沙箱中 测试 2 —— 推荐方式 Context.getExternalFilesDir()测试将文件放入文档目录，传入Environment.DIRECTORY_DOCUMENTS到getExternalFilesDir()方法 1234567891011121314151617181920212223private fun writeMethod() &#123; val context: Context = this@FileStorageActivity val file = File(context.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), "测试Android Q文件.txt"); Log.d(tag, "file.exists():$&#123;file.exists()&#125; ， file.getAbsolutePath(): $&#123;file.absolutePath&#125;"); if (file.exists()) &#123; file.delete(); file.createNewFile(); &#125; Toast.makeText(this@FileStorageActivity, "SD卡目录下创建文件成功...", Toast.LENGTH_LONG).show(); val fw = FileWriter(file); fw.write("我是测试Android Q文件写入的内容"); fw.close() Toast.makeText(this@FileStorageActivity, "SD卡写入内容完成...", Toast.LENGTH_LONG).show() Log.d(tag, "SD卡写入内容完成..."); &#125; private fun readMethod() &#123; val context: Context = this@FileStorageActivity val fr = FileReader(context.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS).path + "/测试Android Q文件.txt"); val r = BufferedReader(fr); val result = r.readLine(); Log.d(tag, "SD卡文件里面的内容:$result") &#125; 输出日志： 1232019-03-17 14:27:23.423 9511-9511/com.xw.androidqtest D/FileStorageActivity: file.exists():false ， file.getAbsolutePath(): /storage/emulated/0/Android/data/com.xw.androidqtest/files/Documents/测试Android Q文件.txt2019-03-17 14:27:23.437 9511-9511/com.xw.androidqtest D/FileStorageActivity: SD卡写入内容完成...2019-03-17 14:27:27.696 9511-9511/com.xw.androidqtest D/FileStorageActivity: SD卡文件里面的内容:我是测试Android Q文件写入的内容 文件所在位置： 更多示例，请参照以上内容或官方文档, 自行测试 2019-03-26 更新: 得到反馈，测试 1 未能在android-10模拟器上复现成功，由于上面的测试我是在pixel 2真机上测试的，对此如下又在模拟器上进行了测试 （本次真机也同时测试了一遍）。 由于没有添加读写权限，在模拟器上运行抛出了异常 —-&gt; (真机没有任何异常) 于是添加读写权限，并动态授权，模拟器上运行无异常，但是确实写入的文件未能自动放入/Android/sandbox/com.xw.androidqtest目录下，位置没变还是在/storage/emulated/0/根目录下 针对以上的出现的问题，猜想应该是模拟器和真机之间的差异，大家怎么看？ 欢迎大家在评论处留言讨论 本文参考官方文档进行简单翻译及示例总结，感谢您的阅读。如有不足，欢迎指正]]></content>
      <categories>
        <category>Android</category>
        <category>Android Q</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Q</tag>
        <tag>Permission</tag>
        <tag>scoped</tag>
        <tag>sandbox</tag>
        <tag>Shared collections</tag>
        <tag>File</tag>
        <tag>external storage</tag>
        <tag>behavior change</tag>
        <tag>media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q 后台启动Activity限制]]></title>
    <url>%2F2019%2F03%2F16%2Fandroid-q-beta-background-activity-starts%2F</url>
    <content type="text"><![CDATA[本文针对Android Q 后台启动Activity简单总结 当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考 Android Q对应用程序何时可以启动Activity进行了限制。 变化这种行为的改变有助于减少用户的干扰，并让用户更好地控制屏幕上显示的内容。尤其是运行在Android Q上的应用程序，只有满足以下一个或多个条件才能启动Activity: 应用程序有一个可见的窗口，比如在前台一个的Activity。 一个在前台不同的应用程序发送了属于该应用程序的一个PendingIntent， 示例包括自定义选项卡提供者发送菜单项待定意图。 系统发送了一个属于该应用程序的PendingIntent，比如点击一条通知，只有应用程序可以启动UI的待处理意图才可以免除。 系统向应用程序发送一个广播，如SECRET_CODE_ACTION到应用程序。只有特定的广播，应用程序预计在UI启动时才会被豁免。 【注】出于Activity启动的目的，前台服务不将应用程序限定在前台。 影响这个行为变化影响到所有运行在Android Q上的应用程序，即使是那些target版本是Android 9(API 28) 或者更低的，即使您的应用程序的target版本是Android 9或更低版本，并且最初安装在运行Android 9或更低版本的设备上，在设备升级到Android Q之后，行为更改仍然会生效。 但是，只要您的应用程序作为用户交互的直接结果启动Actvity，您的应用程序就很可能不会受到此更改的影响。 警告信息在Beta 1中，如果你的应用程序运行在Android Q上，并试图从后台启动某个活动，平台允许该活动启动，但它会向logcat发送一条警告消息，并显示以下警告toast消息: 1This background activity start from package-name will be blocked in future Q builds. 这则消息意思是: 该后台activity从某包下启动，将在之后构建的Q版本中被屏蔽 Android Q中与在后台启动Activity相关的限制与设备进入屏幕固定状态后系统阻止Activity启动的方式类似。 改进方式几乎在所有情况下，后台应用程序都应创建通知，以便向用户提供信息，而不是直接启动Activity。 示例复现警告为了测试复现警告消息，这里定义MainActivity和BackgroundActivity,在MainActivity的onPause方法中如下实现 12345678910override fun onPause() &#123; super.onPause() val timer = Timer() val timerTask = object : TimerTask() &#123; override fun run() &#123; startActivity(Intent(this@MainActivity,BackgroundActivity::class.java)) &#125; &#125; timer.schedule(timerTask, 5000) &#125; MainActivity启动之后，按Home键切换到Launcher，此时MainActivity将会执行onPause方法，在此方法中开启了一个定时器，模拟后台启动Activity 然后后台输出如下日志 12342019-03-16 10:03:10.599 1192-7709/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.BackgroundActivity&#125; from uid 105052019-03-16 10:03:10.600 1192-7709/? W/ActivityTaskManager: Background activity start [callingPackage: com.xw.androidqtest; callingUid: 10505; isCallingUidForeground: false; isCallingUidPersistentSystemProcess: false; realCallingUid: 10505; isRealCallingUidForeground: false; isRealCallingUidPersistentSystemProcess: false; originatingPendingIntent: null; isBgStartWhitelisted: false; intent: Intent &#123; cmp=com.xw.androidqtest/.BackgroundActivity &#125;; callerApp: ProcessRecord&#123;b6f89ff 29017:com.xw.androidqtest/u0a505&#125;]2019-03-16 10:03:10.619 29017-29017/com.xw.androidqtest W/ActivityThread: handleWindowVisibility: no activity for token android.os.BinderProxy@8611b072019-03-16 10:03:10.700 1192-1238/? I/ActivityTaskManager: Displayed com.xw.androidqtest/.BackgroundActivity: +96ms 界面弹出了警告消息 参考官方文档，做如下处理 处理创建前台服务类，并在onStartCommand方法中创建一个前台通知, 以下是完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 package com.xw.androidqtestimport android.app.*import android.content.Contextimport android.content.Intentimport android.graphics.Colorimport android.os.Buildimport android.os.IBinderimport android.util.Logimport androidx.annotation.RequiresApiimport androidx.core.app.NotificationCompatclass ForegroundService : Service() &#123; private val tag: String = ForegroundService::class.java.simpleName override fun onBind(intent: Intent): IBinder? &#123; return null; &#125; override fun onCreate() &#123; super.onCreate() Log.d(tag, "ForegroundService OnCreate called") &#125; override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int &#123; Log.d(tag, "ForegroundService onStartCommand called") createNotificationChannel("channelId", "channelName") val fullScreenIntent = Intent(this, BackgroundActivity::class.java) val fullScreenPendingIntent = PendingIntent.getActivity( this, 0, fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT ) val notificationBuilder = NotificationCompat.Builder(this, "channelId") .setSmallIcon(R.mipmap.ic_launcher_round) .setContentTitle(getString(R.string.app_name)) .setContentText("启动BackgroundActivity") .setPriority(NotificationCompat.PRIORITY_HIGH) .setCategory(NotificationCompat.CATEGORY_CALL) // Use a full-screen intent only for the highest-priority alerts where you // have an associated activity that you would like to launch after the user // interacts with the notification. Also, if your app targets Android Q, you // need to request the USE_FULL_SCREEN_INTENT permission in order for the // platform to invoke this notification. .setFullScreenIntent(fullScreenPendingIntent, true) val incomingCallNotification = notificationBuilder.build() // The integer ID that you give to startForeground() must not be 0. startForeground(1, incomingCallNotification) return START_STICKY &#125; @RequiresApi(Build.VERSION_CODES.O) private fun createNotificationChannel(channelId: String, channelName: String): String &#123; val channel = NotificationChannel( channelId, channelName, NotificationManager.IMPORTANCE_NONE ) channel.lightColor = Color.BLUE channel.lockscreenVisibility = Notification.VISIBILITY_PRIVATE val service = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager service.createNotificationChannel(channel) return channelId &#125; override fun onDestroy() &#123; super.onDestroy() stopForeground(true); &#125;&#125; 清单文件注册权限 123&lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE"/&gt;&lt;!-- New Android Q permission --&gt;&lt;uses-permission android:name="android.permission.USE_FULL_SCREEN_INTENT"/&gt; 最后更新onPause方法 12345678910override fun onPause() &#123; super.onPause() val timer = Timer() val timerTask = object : TimerTask() &#123; override fun run() &#123; startService(Intent(this@MainActivity, ForegroundService::class.java)) &#125; &#125; timer.schedule(timerTask, 5000) &#125; 运行输出日志： 122019-03-16 10:25:22.308 9112-9112/com.xw.androidqtest D/ForegroundService: ForegroundService OnCreate called2019-03-16 10:25:22.309 9112-9112/com.xw.androidqtest D/ForegroundService: ForegroundService onStartCommand called 通知栏收到了发出的通知 点击通知进入了需要后台启动的BackgroundActivity日志内容 ： 123452019-03-16 10:29:04.074 1192-4994/? I/ActivityTaskManager: START u0 &#123;cmp=com.xw.androidqtest/.BackgroundActivity&#125; from uid 105052019-03-16 10:29:04.074 1192-4994/? W/ActivityTaskManager: startActivity called from non-Activity context; forcing Intent.FLAG_ACTIVITY_NEW_TASK for: Intent &#123; cmp=com.xw.androidqtest/.BackgroundActivity &#125;2019-03-16 10:29:04.082 9112-9112/com.xw.androidqtest W/ActivityThread: handleWindowVisibility: no activity for token android.os.BinderProxy@46d3c482019-03-16 10:29:04.084 1192-1251/? W/WindowManager: TaskSnapshotSurface.create: Failed to find main window for token=AppWindowToken&#123;6b40830 token=Token&#123;fb2f173 ActivityRecord&#123;7d079e2 u0 com.xw.androidqtest/.BackgroundActivity t800&#125;&#125;&#125;2019-03-16 10:29:04.143 1192-1238/? I/ActivityTaskManager: Displayed com.xw.androidqtest/.BackgroundActivity: +69ms 开启行为变化即使这种行为变化在默认情况下不会在Android Q Beta 1中生效，您也可以通过完成以下任务之一来模拟这种行为变化: 导航到“设置&gt;开发人员选项”，并禁用“允许后台活动启动”选项 在终端中执行如下命令 1adb shell settings put global background_activity_starts_enabled 0 模拟测试将代码还原成直接调用从后台启动Activity，设置好如上所叙述的操作，测试效果图 与文章一开始测试不同之处就是: 目前在Q Beta1上默认还是会启动起后台的Activity展示并显示toast消息，这次测试模拟了最终完全屏蔽的情况，不会调起后台的Activity 本文参考官方文档进行简单总结，感谢您的阅读。如有不足，欢迎指正]]></content>
      <categories>
        <category>Android</category>
        <category>Android Q</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>Android</tag>
        <tag>Android Q</tag>
        <tag>Background</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Android Q 定位]]></title>
    <url>%2F2019%2F03%2F15%2Fabout-android-q-beta-location%2F</url>
    <content type="text"><![CDATA[Android Q Location 的简单总结 当前文章首次编辑于Android Q Beta 1 版本，可能部分内容会在后期版本上发生变化，仅供参考 以往情况 Android API &lt; 23 : 无需动态请求，直接注册使用位置权限 Android API &gt; = 23 &amp;&amp; API &lt; = 28: 需要动态请求权限，并允许/拒绝权限 从之前来看，用户只有一个控件允许或拒绝应用程序访问设备位置，包括应用程序在使用时和不使用时的位置使用情况。 在Android Q上，Android团队对控件进行了改进 有何变化 从Android Q开始，用户有一个新选项，只有在使用该应用时才能让应用访问该位置; 换句话说，当应用程序在前台时。这意味着用户可以选择三种选项来为应用提供位置： All the time - 意味着APP任何时候都能访问到位置 While in use - 意味着APP只有当在使用的时候才能访问到位置 Deny - 意味着APP无法访问到位置 从Android Q Beta 1开始，此更改具有以下属性： 如果您在后台请求访问用户的位置，则会影响您的应用 通过使用新权限在后台访问位置并在没有后台位置更新的情况下确保优雅降级来进行缓解 Android Q上始终启用行为 如何开始1234&lt;manifest&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" /&gt;&lt;/manifest&gt; 如果您的应用具有需要“始终”权限的功能 target version Q : 您需要为清单文件添加新的ACCESS_BACKGROUND_LOCATION权限 target version &lt;= Android 9 (API 28) : 如果您请求ACCESS_FINE_LOCATION或ACCESS_COARSE_LOCATION中的任何一个，系统将会自动为您添加ACCESS_BACKGROUND_LOCATION权限 用户可以随时通过设置决定提供或删除这些位置权限。 要保持良好的用户体验，请将应用程序设计为在应用程序没有后台位置权限或没有任何位置访问权限时进行优雅处理。 注意：虽然您的应用可以请求并接收ACCESS_BACKGROUND_LOCATION，但用户可以通过选择您的应用仅应在前台访问位置信息来撤消此权限。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.xw.androidqtestimport android.Manifestimport android.content.pm.PackageManagerimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.util.Logimport androidx.core.app.ActivityCompatimport kotlinx.android.synthetic.main.activity_location.*class LocationActivity : AppCompatActivity() &#123; private val tag: String = LocationActivity::class.java.simpleName companion object &#123; const val REQUEST_CODE_FOREGROUND = 1 const val REQUEST_CODE_BACKGROUND = 2 &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_location) btnForeground.setOnClickListener &#123; requestPermission() &#125; btnBackground.setOnClickListener &#123; requestBackgroundPermission() &#125; &#125; override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123; when (requestCode) &#123; REQUEST_CODE_FOREGROUND -&gt; handlePermissionForForeground() &#125; super.onRequestPermissionsResult(requestCode, permissions, grantResults) &#125; private fun requestPermission() &#123; val permissionAccessCoarseLocationApproved = ActivityCompat .checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED if (permissionAccessCoarseLocationApproved) &#123; handlePermissionForForeground() &#125; else &#123; ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION), REQUEST_CODE_FOREGROUND) &#125; &#125; private fun requestBackgroundPermission() &#123; val permissionAccessCoarseLocationApproved = ActivityCompat .checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED if (permissionAccessCoarseLocationApproved) &#123; val backgroundLocationPermissionApproved = ActivityCompat .checkSelfPermission(this, Manifest.permission.ACCESS_BACKGROUND_LOCATION) == PackageManager.PERMISSION_GRANTED if (backgroundLocationPermissionApproved) &#123; // App can access location both in the foreground and in the background. // Start your service that doesn't have a foreground service type // defined. &#125; else &#123; // App can only access location in the foreground. Display a dialog // warning the user that your app must have all-the-time access to // location in order to function properly. Then, request background // location. ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.ACCESS_BACKGROUND_LOCATION), REQUEST_CODE_BACKGROUND) &#125; &#125; else &#123; // App doesn't have access to the user's location at all. Make full request // for permission. ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_BACKGROUND_LOCATION), REQUEST_CODE_BACKGROUND) &#125; &#125; private fun handlePermissionForForeground() &#123; Log.d(tag,"handlePermissionForForeground called") &#125;&#125; 以上是对Android Q 位置变化的简单总结，更多使用方法请参阅官方文档]]></content>
      <categories>
        <category>Android</category>
        <category>Android Q</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Q</tag>
        <tag>Location</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍 Android Q Beta版]]></title>
    <url>%2F2019%2F03%2F14%2Fintroducing-android-q-beta%2F</url>
    <content type="text"><![CDATA[原文来自: Introducing Android Q Beta 2019年，移动创新比以往更加强大。新型科技从5G到边缘，再到边缘显示器，甚至是可折叠屏幕。Android正处于这个创新周期的中心，感谢数十亿设备的合作伙伴广泛的生态系统。Android帮助推动了硬件和软件的界限，带给用户全新的体验和功能。 随着移动生态系统的发展，Android着重于帮助用户利用最新的创新，确保用户的安全和隐私始终是首要任务，在像Google Pley Protect和运行时权限的基础上构建。Android Q 带来了额外的隐私和安全功能给用户，以及增强可折叠，用于连接新的APIs,新的媒体解码器和相机功能，NNAPI扩展，Vulkan 1.1支持，更快的应用程序启动，以及更多。 今天我们为早期采纳者发布了Android Q Beta 1 版本并为开发者发布SDK预览版。您今天可以通过注册任意Pixel设备(包括原版的Pixel和Pixel XL,我们通过大众需求扩大了支持！)请让我们知道您的想法！，继续阅读，了解Android Q中的内容，我们将在5月份的Google I / O上看到您，我们将分享更多内容。 建立在Android的隐私保护之上Android的设计以安全和隐私为中心,随着Android的成熟,我们增加了很多功能来保护用户,像基于文件的加密、操作系统控制要求应用程序在访问敏感资源之前请求权限、锁定相机/麦克风后台访问、锁定模式、加密备份、Google Play Protect(每天扫描超过500亿个应用程序，以识别潜在的有害应用程序并删除它们)以及更多。在Android Q中，我们已经做了更多的增强来保护我们的用户，其中许多增强是我们在Strobe项目中工作的一部分。 给用户更多的位置控制使用Android Q，操作系统帮助用户更好地控制应用程序何时可以获得位置。就像之前的操作系统版本一样，应用程序只有在请求你的权限并得到你的许可后才能获得位置信息。 特别敏感的一件事是，应用程序在不使用的情况下(在后台)访问位置。Android Q 允许用户永远不允许应用程序查看自己的位置，只在应用程序正在使用(运行)或一直在使用(后台)时才允许。 例如，一个应用程序询问用户食品配送的位置是有意义的，用户可能希望授予它这样做的能力。但由于应用程序可能不需要当前正在使用的位置之外的位置，用户可能不想授予该访问权限。Android Q现在提供了更高级别的控制。请阅读开发人员指南，了解有关如何使应用程序适应此新控件的详细信息。期待更多以用户为中心的改进出现在即将到来的beta中。我们的目标是非常敏感地，始终为开发人员提供尽可能多的通知和支持。 Android Q中更多的隐私保护除了位置的改变，我们还在进行进一步的更新，以确保透明度、用户控制权和个人数据的安全。 在Android Q 中，该操作系统让用户对应用程序有了更多的控制，控制对共享文件的访问。用户将能够通过新的运行时权限控制应用程序对照片、视频或音频集合的访问。对于下载，应用程序必须使用系统文件选择器，这允许用户决定应用程序可以访问哪些下载文件。对于开发人员来说，您的应用程序如何在外部存储上使用共享区域有一些变化。请确保阅读作用域存储(Scoped Storage)更改以获得详细信息。 我们还看到，当一个应用程序意外地跳到前台并占据焦点时，用户(和开发人员)会感到不安。为了减少这些干扰，Android Q将阻止应用程序在后台启动活动。如果你的应用程序在后台，需要迅速吸引用户的注意力——比如来电或闹钟——你可以使用高优先级通知，并提供全屏意图。有关更多信息，请参阅文档。 我们限制对不可重置设备标识符的访问，包括设备IMEI、序列号和类似标识符。阅读最佳实践，以帮助您为用例选择正确的标识符，并在这里查看详细信息。在默认情况下，当连接到不同的Wi-Fi网络时，我们还会随机设置设备的MAC地址——这在Android 9 Pie中是可选的。 我们提前把这些变化告诉你，这样你就可以有尽可能多的时间来准备。我们还努力为开发人员预先提供详细的信息，我们建议查看关于隐私更改的详细文档，并立即开始测试。 吸引用户的新方式在Android Q中，我们启用了新的方式将用户带入你的应用程序，并在他们从其他应用程序过渡时简化体验。 折叠和创新的新屏幕可折叠设备开辟了一些创新的经验和用例。为了帮助你的应用程序更好地利用这些和其他大屏幕设备，我们在Android Q中做了很多改进，包括onResume和onPause的改变，以支持多简历，并在你的应用程序有焦点时通知你。我们还更改了resizeableActivity manifest属性的工作方式，以帮助您管理应用程序在可折叠和大屏幕上的显示方式。为了让您开始在这些新设备上构建和测试，我们一直在努力更新Android模拟器，以支持多显示器类型切换——更多细节即将公布! 分享快捷键当用户想在另一个应用程序中与他人分享照片等内容时，过程应该很快。在Android Q中，我们通过共享快捷方式让这一过程变得更快更简单，用户可以直接跳转到另一个应用程序来共享内容。开发人员可以发布共享目标，这些目标在应用程序中启动带有附加内容的特定活动，并在共享UI中显示给用户。因为它们是预先发布的，所以可以在启动时立即加载共享UI。 共享快捷方式机制类似于应用程序快捷方式的工作方式，因此我们扩展了ShortcutInfo API，以便更容易地集成这两个功能。新的ShareTarget AndroidX库也支持这个新的API。这允许应用程序使用新功能，同时允许pre-Q设备使用直接共享。您可以在这里找到带有源代码的早期示例应用程序。 设置面板现在，您还可以通过一个新的设置面板API在应用程序上下文中直接显示关键系统设置，该API利用了我们在Android 9 Pie中引入的slice特性。 设置面板是一个浮动的UI，您可以从应用程序中调用它来显示用户可能需要的系统设置，比如internet连接、NFC和音频音量。例如，浏览器可以显示带有连接设置的面板，如飞机模式、Wi-Fi(包括附近的网络)和移动数据。没有必要离开应用程序;用户可以根据需要从面板管理设置。要显示设置面板，只需使用Settings.Panel actions其中一个新设置触发一个intent 连接在Android Q中，我们扩展了您的应用程序可以使用Android的连接堆栈并添加新的连接API。 连接权限、隐私和安全性大多数用于扫描网络的api已经需要粗位置权限，但在Android Q 中，对于蓝牙、蜂窝网络和Wi-Fi，我们正在通过要求精细位置权限来增强对这些api的保护。如果你的应用只需要建立点对点连接或推荐网络，看看下面改进的Wi-Fi api——它们简化了连接，不需要位置许可。 除了Android Q在连接不同Wi-Fi网络时提供的随机MAC地址，我们还增加了新的Wi-Fi标准支持WP3和OWE，以提高家庭和工作网络以及开放/公共网络的安全性。 改进的点对点和互联网连接在Android Q中，我们重构了Wi-Fi堆栈，以改善隐私和性能，但也改善了常见的用例，比如管理物联网设备和建议互联网连接——不需要位置许可。 网络连接api使得通过本地Wi-Fi管理物联网设备变得更加容易，可以实现配置、下载或打印等对等功能。应用程序通过指定首选的ssid和bssid作为WiFiNetworkSpecifiers间接启动连接请求。该平台自己处理Wi-Fi扫描，并在Wi-Fi选择器中显示匹配的网络。当用户选择时，平台会自动设置连接。 网络建议api允许应用程序在互联网连接方面显示用户更喜欢的Wi-Fi网络。应用程序通过提供网络和证书列表作为WifiNetworkSuggestion来间接启动连接。该平台将基于过去的性能无缝连接时，在这些网络范围。 Wi-Fi 性能模式现在你可以在Android Q中通过启用高性能和低延迟模式来请求自适应Wi-Fi。在低延迟对用户体验非常重要的情况下，如实时游戏、活动语音呼叫和类似的用例，这些将非常有用。 要使用新的性能模式，请使用WIFI_MODE_FULL_LOW_LATENCY或WIFI_MODE_FULL_HIGH_PERF调用WifiManager.WifiLock.createWifiLock()。在这些模式下，平台与设备固件协同工作，以满足功耗最低的要求。 相机、媒体、图形动态深度格式的照片许多移动设备上的相机可以通过模糊前景或背景来模拟较窄的景深。它们为图像中的不同点捕获深度元数据，并对图像应用静态模糊，然后丢弃深度元数据。 从Android Q开始，应用程序可以请求一个动态深度图像，该图像由一个JPEG、XMP元数据(与深度相关的元素相关)和一个深度和置信度地图组成，这些数据嵌入到宣传支持的设备的同一个文件中。 要求JPEG +动态深度图像可以让你在你的应用程序中提供专门的模糊和bokeh选项。你甚至可以使用这些数据来创建3D图像或支持AR摄影用例。我们正在使动态深度成为生态系统的一种开放格式，我们正在与我们的设备制造商合作伙伴合作，使其在运行Android Q及更高版本的设备上可用。 使用动态深度图像，你可以在你的应用程序中提供专门的模糊和背景虚化选项。 新的音频和视频编解码器Android Q引入了对开源视频编解码器AV1的支持。这使得媒体供应商可以用更少的带宽向Android设备传输高质量的视频内容。此外，Android Q支持使用Opus进行音频编码，Opus是一种针对语音和音乐流媒体进行优化的编解码器，HDR10+用于支持Opus的设备上的高动态范围视频。 MediaCodecInfo API引入了一种更简单的方法来确定Android设备的视频呈现能力。对于任何给定的编解码器，都可以使用VideoCodecCapabilities.getSupportedPerformancePoints()获得支持的大小和帧速率列表。这允许您选择在任何给定设备上呈现的最佳质量的视频内容。 Vulkan上的ANGLE为了使游戏和图形开发人员更加一致，我们正在为所有基于Vulkan的设备开发一个标准的、可更新的OpenGL驱动程序。在Android Q中，我们在Android设备的Vulkan之上添加了对ANGLE的实验性支持。ANGLE是一个图形抽象层，用于实现高性能的OpenGL兼容性。通过angular，许多使用OpenGL ES的应用程序和游戏都可以利用Vulkan的性能和稳定性，并从Android设备上对ES的一致、独立于供应商的实现中获益。在Android Q中，我们计划支持OpenGL ES 2.0，下一步将支持ES 3.0。 我们将使用更多OpenGL功能、bug修复和性能优化来扩展实现。有关Android中当前角度支持的详细信息，如何使用它，以及我们未来的计划，请参阅文档。您可以通过“设置”中的“开发人员选项”选择我们的初始支持来开始测试。今天就试试吧! Vulkan 无处不在我们正在继续扩大Vulkan对Android的影响，我们为高性能3D图形实现了低开销、跨平台的API。我们的目标是使Android上的Vulkan成为一个广泛支持的、一致的图形开发人员API。我们正在与我们的设备制造商合作伙伴共同努力，使Vulkan 1.1成为所有运行Android Q或更高版本的64位设备的要求，并成为所有32位设备的推荐标准。未来，这将有助于为应用程序和游戏提供统一的高性能图形API。 神经网络 API 1.2自2017年推出神经网络API (NNAPI)以来，我们继续扩大支持的操作数量，并改进现有功能。在Android Q中，我们增加了60个新操作，包括ARGMAX, ARGMIN，量化LSTM，以及一系列的性能优化。这为加速更大范围的模型奠定了基础，比如用于目标检测和图像分割的模型。我们正在与硬件供应商和流行的机器学习框架(如TensorFlow)合作，优化和推出对NNAPI 1.2的支持。 Android基础的加强ART 性能Android Q对ART运行时进行了几项新的改进，帮助应用程序更快地启动并消耗更少的内存，而不需要开发人员做任何工作。 自Android Nougat以来，ART提供了Profile Guided Optimization (PGO)，它通过识别和预编译代码中经常执行的部分，随着时间的推移加快了应用程序的启动速度。为了帮助最初的应用程序启动，谷歌Play现在提供了基于云的配置文件和apk。这些都是匿名的、聚合的艺术配置文件，可以让艺术在应用程序运行之前预先编译应用程序的某些部分，从而为整个优化过程提供了一个重要的起点。基于云的配置文件对所有应用程序都有好处，而且运行Android P或更高版本的设备已经可以使用这些配置文件。 我们还在继续改进ART本身。例如，在Android Q中，我们通过提前启动应用程序进程并将其移至安全容器来优化Zygote进程，因此可以立即启动。 我们将更多信息存储在应用程序的堆映像中，例如类，并使用线程来更快地加载映像。 我们还在ART的Concurrent Copying（CC）垃圾收集器中添加了Generational Garbage Collection。 分代CC更有效率，因为它分别收集年轻代对象，与全堆GC相比，成本更低，同时仍然可以回收大量空间。 这使得垃圾收集整体上在时间和CPU方面更加高效，减少了jank并帮助应用程序在低端设备上更好地运行。 应用安全BiometricPrompt是我们的统一认证框架，支持系统级的生物识别。在Android Q中，我们扩展了对被动身份验证方法(如face)的支持，并添加了隐式和显式身份验证流。在显式流中，用户必须在身份验证期间显式地确认TEE中的事务。隐式流是为使用被动身份验证的事务设计的轻量级替代方案。我们还改进了设备凭据在需要时的回退。 Android Q增加了对TLS 1.3的支持，TLS 1.3是对TLS标准的重大修订，包括性能优势和增强的安全性。 我们的基准测试表明，与TLS 1.2相比，使用TLS 1.3可以将安全连接的速度提高40％。 默认情况下，为所有TLS连接启用TLS 1.3。 有关详细信息，请参阅文档。 通过公共api的兼容性我们都关心的另一件事是确保应用程序在操作系统变化和发展的过程中运行顺畅。使用非sdk api的应用程序对用户有崩溃的风险，对开发人员有紧急推出的风险。在Android Q中，我们将继续从Android P开始的长期努力，将应用程序转向只使用公共api。我们知道将您的应用程序从非sdk api中移除需要时间，所以我们提前通知您。 在Android Q中，我们限制了对更多非sdk接口的访问，并要求您使用公共接口。为了帮助您进行转换并防止您的应用程序崩溃，我们只在您的应用程序针对Android q时启用这些限制。我们将根据您的请求继续添加公共替代api;如果没有符合您用例的公共API，请让我们知道。 测试应用程序是否使用非sdk接口非常重要。我们建议使用StrictMode方法detectNonSdkApiUsage()在应用程序通过反射或JNI访问非sdk api时发出警告。即使api此时被豁免(灰色列表)，最好还是为将来做好计划，并消除对它们的使用，以减少兼容性问题。有关Android Q中限制的更多细节，请参阅开发人员指南。 现代化安卓我们正在努力让所有应用程序充分利用最新版本Android的安全和性能特性。今年晚些时候，谷歌Play将要求你在新应用和更新中把应用的targetSdkVersion设置为28 (Android 9 Pie)。根据这些变化，Android Q将在用户首次运行针对API级别23 (Android Marshmallow)之前的平台的应用程序时，用对话框警告用户。下面是帮助您迁移应用程序的资源清单。 我们还在推动生态系统为64位设备做好准备。今年晚些时候，谷歌Play将要求所有应用程序都支持64位。如果您的应用程序使用本地sdk或库，请记住，您需要提供这些sdk或库的64位兼容版本。有关如何准备的详细信息，请参阅开发人员指南。 开始使用Android Q测试版对于可能影响您的应用程序的重要隐私特性，我们建议您立即开始测试。特别是，您希望启用和测试Android Q存储更改、新位置权限状态、后台应用程序启动的限制和设备标识符的限制。有关详细信息，请参阅隐私文档。 首先，只需将您当前的应用程序从谷歌Play安装到运行Android Q Beta版的设备或Android虚拟设备上，并处理用户流。该应用程序应该运行良好，看起来很棒，并正确处理所有应用程序的Android Q行为变化。如果你发现问题，我们建议你在当前的应用程序中修复它们，而不改变你的目标水平。查看迁移指南中的步骤和建议的时间线。 探索新特性和api当你准备好了，深入Android Q，了解你可以在你的应用程序中使用的新功能和api。以API diff报告、Android Q Beta API参考和开发人员指南作为起点。另外，在Android Q Beta开发人员站点上，您可以找到发布说明和报告问题的支持资源。 要使用Android Q进行构建，请下载Android Q Beta SDK和工具到Android Studio 3.3或更高版本中，并按照以下说明配置您的环境。如果你想要最新的修复Android Q相关的变化，我们建议你使用Android Studio 3.5或更高版本。 我如何得到Android Q测试版?这很简单——你可以在这里注册，在任何像素设备上通过无线方式获得Android Q Beta更新(今年我们支持所有三代Pixel—Pixel3、Pixel2，甚至原始Pixel!)还可以下载这些设备的系统映像。如果没有Pixel设备，可以使用Android模拟器，并通过Android Studio中的SDK Manager下载最新的模拟器系统镜像。 我们计划在整个预览过程中定期更新预览系统图像和SDK。随着Beta版程序的推进，我们将有更多的功能可以分享。 一如既往，你的反馈是至关重要的，所以请让我们知道你的想法——我们越早收到你的反馈，我们就能整合更多的反馈。当您发现问题时，请在这里报告。我们有单独的热门列表来归档平台问题、应用程序兼容性问题和第三方SDK问题。 以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
        <category>Android Q</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Q</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack WorkManager 稳定发布]]></title>
    <url>%2F2019%2F03%2F06%2Fandroid-jetpack-workmanager-stable%2F</url>
    <content type="text"><![CDATA[原文来自: Android Jetpack WorkManager Stable Release 使用WorkManager的方式简化您的后台管理 今天我们非常高兴的宣布Android Jetpack WorkManager 1.0 稳定版发布。我们想感谢许多在我们开发社区的您，一路上为我们给予反馈和bug记录 —— 我们到达了这里，感谢您的帮助！ 当我们通过开发者看到面临的主要问题时，我们看见了做可靠的后台处理和友好的电量管理是一个巨大的挑战。这意味着定期刷新内容或者上传您的日志是复杂的。不同的Android版本为工作提供了不同的工具，它们每一个都有自己怪异的API。比如说，监听网络或者存储可用性以及自动重试您的任务涉及到大量工作。 我们对于这些挑战的回答是WorkManager。在Google I/O 2018上，我们介绍了Android Jetpack WorkManager库的预览,并且从那之后在它上面迭代了额外的功能核和bug修复，感谢您宝贵的意见。 WorkManager的目标就是为了您操作后台使其简单。WorkManager考虑到了像电量优化、存储或者网络可用性的约束，同事当满足适当的条件它只能运行它的任务。它也知道去重试或者重新调度您的工作——即使您的设备或者app重启了。 我们相信ＷOrkManager是友好的，亲切的API,能够处理好Android最复杂的部分之一，您可以将焦点放在让您的App独特代码上。 ＷorkManager 亮点这里是WorkManager一些关键点： 让您设置约束，比如网络状态或者充电状态、任务在运行时 支持异步一次性和周期性 支持带输入和输出的链式任务 确保任务执行，及时APP或者设备重启 支持Android 4.0+ (API 14+) 观看和阅读下面去学习在您的APP里面什么时候以及如何使用WorkManager去简化管理后台工作 Android Jetpack: 介绍WorkManager 何时使用 WorkManagerWorkManager是针对于能够被延期任务的最佳套件，但是即使是应用程序或者设备重启(比如: 使用后端服务定期同步数据以及上传日志或者分析数据) 也是仍然有望运行 对于像需要立即运行去发送即时消息或者APP在退出之后不需要立即运行的任务，去看看后台处理向导 了解哪一种解决方案满足您的需求。 如何使用 WorkManager开始使用WorkManager API, 添加在Google’s Maven repository上WorkManager可用的Java或者Kotlin依赖到您应用程序的build.gradle文件: 123456789dependencies &#123; def work_version = 1.0.0 // Java implementation "android.arch.work:work-runtime:$work_version" // Kotlin KTX + coroutines implementation "android.arch.work:work-runtime-ktx:$work_version" &#125; 现在，只需要将Worker子类化并利用doWork()实现您的后台工作，并用WorkManager加入列队。 123456789101112131415161718192021class MyWorker(ctx: Context, params: WorkerParameters) : Worker(ctx, params) &#123; override fun WorkerResult doWork() &#123; //在这里完成一些需要在后台处理的工作 ..... return Result.success() &#125;&#125;// 可选, 添加像电源、网络可用性的约束val constraints: Constraints = Constraints.Builder() .setRequiresCharging(true) .setRequiredNetworkType(NetworkType.CONNECTED) .build()val myWork = OneTimeWorkRequestBuilder&lt;MyWorker&gt;() .setConstraints(constraints).build()// 现在，列队您的工作WorkManager.getInstance().enqueue(myWork) WorkManager当识别到您的设备正在充电且网络是可用时，它将负责运行您的任务。 为何使用 WorkManager向后兼容WorkManager将利用正确的调度API:它使用了JobScheduler API在Android 6.0+ (API 23+)并且结合了之前版本上的AlarmManager和BroadcastReceiver 它也力求最佳行为，这样它就符合了在较新的Android API版本中引入系统优化去最大化电量和强制执行良好的APP行为。 比如说，当系统是进入了Doze 模式时，对于Android 6.0+(API 23+)的设备，WorkManager将在维护窗口期间调度后台工作。 可靠的调度利用WorkManager,您能够简单的添加像网络可用性或者充电状态的约束。当约束满足您的工作将会运行，并且如果在运行的过程中它们失败了将会自动重试。比如说，如果您的任务要求网络可用，当网络不再可用时任务将会停止并且之后重试。 您也能够使用LiveData监控工作状态和检索工作结果。当您的任务完成时，这样可以通知您的UI。 您的工作失败了的情况下，您可用通过配置backoff(退避)的处理方式来控制您的工作重试方式 WorkManager也能够重新调度您的工作，如果一个应用程序或者设备重启发生了，使用本地数据库记录您的工作。 控制您的工作方式我们明白每一个APP有不同的需求，您的任务也如此——甚至是在同一个APP内。WorkManager提供了简单但高度灵活的API表面，可以帮助您配置您的工作和运行它的方式。 利用OneTimeWorkRequest一次性调度或者PeriodicWorkRequest周期性调度 您也能够链接您的一次工作请求以按顺序或并行运行。如果任意链接工作失败，WorkManager力求确保剩下的工作链不会运行。阅读更多关于链接工作请求这里 如果您需要更多灵活性的WorkManager并行化方式以及消息工作，检出我们高级线程向导 开发者有说什么redBus ，最大在线巴士票务平台，分享他们使用WorkManager的经验，以简化他们在Android应用中收集用户反馈的方式： “随着我们扩展到其他国家，反馈对于readBus至关重要。一个用户给予了关于在redBus应用程序中功能至关重要的反馈，但是当应用程序尝试去上传反馈到后端，这儿或许没有足够的网络覆盖或者电量WorkManager简化了redBus应用程序向后端提供信息的方式。WorkManager库处理像网络连接、电量参数的能力以及使用像AlarmManager或者JobScheduler适当的处理程序，使我们能够专注于构建业务逻辑并将执行复杂性卸载到WorkManager —— Dinesh Shanmugam Android Lead, redBus.in 开始使用 WorkManager根据您后台任务的需要，检出我们开始使用向导和codelab动手去使用WorkManager库 我们欣赏您的反馈，包括您喜欢的新功能以及您希望看到的新功能 如果您发现了一个bug或者issue,随时提出问题 以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
        <category>WorkManager</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WorkManager</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android P 默认通过TLS保护用户]]></title>
    <url>%2F2018%2F04%2F11%2Fprotecting-users-with-tls-by-default-in%2F</url>
    <content type="text"><![CDATA[原文来自：Protecting users with TLS by default in Android P Android承诺去保持用户他们的设备和数据安全。保持数据安全之一的方式是,通过保护Android设备在进入或者离开中转传输层安全（TLS）的所有数据。正如我们在Android P开发者预览版中宣布的那样，我们将进一步改善这些保护，通过阻止目标版本是Android P的应用程序来自默认允许未加密的连接。 这是我们为保护Android用户，多年来做出的各种改变。去阻止偶发的未加密连接，在Android Marshmallow(6.0)中我们介绍了android:usesCleartextTraffic清单属性。在Android Nougat(7.0),我们通过创建Network Security Config(网络安全配置)功能特性去扩展了这个属性，允许应用程序去表明它们不打算在没有加密的情况下发送网络流量。在Android Nougat(7.0)和Android Oreo(8.0)，我们仍然允许明文连接。 我怎么更新我的应用程序？如果你的应用程序对于所有的连接都使用了TLS，然后你不需要做什么了。如果你还没有，就去使用TLS去加密所有的连接更新你的应用程序。如果你仍然需要去使用明文进行连接,继续去阅读一下最佳做法。 为什么我应该使用TLS？Android考虑到所有的网络可能有敌意，因此加密流量应该在所有时间对于所有的连接都被使用。移动设备尤其面临风险，因为它们经常会连接到许多不同的网络，比如在咖啡店的Wi-Fi 所有的流量应该被加密，无论内容是什么。作为任意一种未加密的连接能够注入内容被使用，对于那些可能弱势的客户端代码增加攻击面，或者攻击用户。更多信息，看我们过去的博客文章和开发者高峰论坛 TLS是不是很慢？不，它不是 我如何在我的应用程序中使用TLS ?只要你的服务器支持TLS, 只需要在你的应用程序和服务器响应中把URLs 从http://改变成https:// 。你的HTTP栈处理TLS握手，无需其他更多操作。 如果你是自己制作的Socket,使用SSLSocketFactory去替代SocketFactory要格外小心去正确使用作为SSLSocket的socket，它不会去验证主机。你的应用程序需要做的是它自己的主机验证。优选通过调用getDefaultHostnameVerifier()期望的主机名。进一步，谨防HostnameVerifier.verify()在发生异常时不会抛出错误，但是相反的會返回一个boolean的结果，你必须明确的检查。 我需要去使用一个明文去…当你应该对所有连接使用TLS，可能你需要去使用一个明文流量针对于遗留原因。比如连接到一些服务器。因此，改变你的应用程序的网络安全配置，以允许这些连接。 我们包括了一组示例配置，更多帮助查看network security config文档。 允许明文连接到一个具体的域，你可以使用如下的配置作为一个向导：123456&lt;network-security-config&gt; &lt;domain-config cleartextTrafficPermitted="true"&gt; &lt;domain includeSubdomains="true"&gt;insecure.example.com&lt;/domain&gt; &lt;domain includeSubdomains="true"&gt;insecure.cdn.example.com&lt;/domain&gt; &lt;/domain-config&gt;&lt;/network-security-config&gt; 允许连接到任意不安全的域如果你的应用程序支持打开任意来自不安全URLs的内容，当支持明文连接到任意主机，你应该禁用明文连接到你自己的服务器。记住，对于这些通过不安全连接接收到的数据你应该谨慎，它能够在传输的过程当中被篡改。 1234567&lt;network-security-config&gt; &lt;domain-config cleartextTrafficPermitted="false"&gt; &lt;domain includeSubdomains="true"&gt;example.com&lt;/domain&gt; &lt;domain includeSubdomains="true"&gt;cdn.example2.com&lt;/domain&gt; &lt;/domain-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt;&lt;/network-security-config&gt; 我应该怎么更新我的库？如果你的库是直接创建安全/不安全的连接，确保它在打开任意明文连接之前通过检查isCleartextTrafficPermitted来尊重应用程序明文设置。 以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>TLS</category>
        <category>android p</category>
      </categories>
      <tags>
        <tag>android p</tag>
        <tag>android security</tag>
        <tag>connection encryption</tag>
        <tag>HTTPS</tag>
        <tag>network security</tag>
        <tag>TLS</tag>
        <tag>TLS by default</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 切换到D8 dexer]]></title>
    <url>%2F2018%2F04%2F07%2Fandroid-studio-switching-to-d8-dexer%2F</url>
    <content type="text"><![CDATA[原文来自：Android Studio switching to D8 dexer D8现在是默认的dex编译器更快、更小的应用程序编译一直是Android工具团队的目标，那也是为什么我们此前宣布了D8,下一代的dex编译器。相比历史编译器-DX,D8运行更快并生成更小的.dex文件具有相当或者更佳的运行时性能。 我们最近宣布了D8成为Android Studio 3.1中默认的编译器。如果你之前还没有去尝试D8，我们希望你在切换的时候注意到更佳、更快的dex编译。 D8首次在Android Studio3.0中作为一个可选的功能被发出。除此之外我们自己也在严格测试，我们现在已经看到了它在各种各样的应用程序中良好的表现。最后，我们确信D8对于每一个开始在3.1中使用他的人来说都将良好运作。然而，如果你在使用的时候有什么问题，你现在能够通过在你的项目gradle.properties文件下一直设置如下还原到DX 1android.enableD8=false 如果你确实遇到什么问题导致你禁用了D8，请让我们知道! 下一步我们的目标是确保每一个人都能访问到快速、正确的dex编译器。因此避免冒着任一個用户的回归，我们将分为3个阶段去弃用DX 第一阶段打算防止过早的弃用DX。在这个阶段期间，DX将仍然可以在studio中使用。我们将修复它的关键性问题，但是不会再有新的功能特性了。这个阶段将会持续至少6个月，期间我们将打开任何一个D8的错误去决定如果是回归，将会阻止一些用户使用D8替换DX。第一个阶段直到团队解决完全部的迁移阻滞者问题才会结束。在这个窗口中我们将会特别注意到错误追踪器，因此如果你遭遇任何回归，请提出问题。 一旦我们将查看6个月的窗口没有了D8替换DX的主要回归问题，我们将进入第二阶段。这个阶段将会至少是一年，打算确保那些即使是复杂的项目都有大量时间去进行迁移。在这个阶段期间，我们仍然保持着DX可用，但是我们将它视为完全弃用，我们将不会修复它的任何问题。 再第三阶段也就是最后阶段，DX将会从Android Studio中移除。在此时，为了能继续使用DX去构建，你将需要使用一个legacy版本的Android Gradle插件。 以上是对Android官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Dex</category>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Dex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Android O 通知渠道总结]]></title>
    <url>%2F2018%2F01%2F08%2Fabout-android-o-notification-channels%2F</url>
    <content type="text"><![CDATA[本文是关于针对Android O 通知渠道的总结。 Android O 引入了通知渠道Notification Channels，更好的方便用户管理通知栏消息。 123456NotificationChannelpublic final class NotificationChannel extends Object implements Parcelablejava.lang.Object ↳ android.app.NotificationChannel 距离上一次总结通知栏相关的东西好像有很久了，可以去这里查看 今天我们从一个基本的通知示例开始，来总结下Android O 通知渠道相关的使用。 基本示例123456789101112131415161718192021222324252627//创建通知栏管理对象NotificationManager mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);//为了版本兼容 选择V7包下的NotificationCompat进行构造NotificationCompat.Builder builder = new NotificationCompat.Builder(this);//setTicker 在5.0以上不显示Ticker属性信息builder.setTicker("状态栏显示的提示");;//setContentTitle 通知栏通知的标题builder.setContentTitle("内容标题");//setContentText 通知栏通知的详细内容builder.setContentText("内容文本信息");//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）builder.setAutoCancel(true);//setLargeIcon 通知消息上的大图标builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));//setSmallIcon 通知上面的小图标builder.setSmallIcon(R.mipmap.ic_launcher);//小图标//创建一个意图Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com"));PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0);//setContentIntent 将意图设置到通知上builder.setContentIntent(pIntent);//通知默认的声音 震动 呼吸灯builder.setDefaults(NotificationCompat.DEFAULT_ALL);//构建通知Notification notification = builder.build();//将构建好的通知添加到通知管理器中，执行通知mNotificationManager.notify(0, notification); 这段代码很简单，已经添加了注释，没有什么可以说的。 差异复现SDK &lt; 8.0(API 26)这种情况，上面的示例代码是能无障碍的将通知消息显示出来。 SDK &gt; = 8.0(API 26)这种情况，上面的示例代码，是死活都不会把通知消息显示出来的。 在Android Oreo上的开发者选项中，新增加了一个show notification channel warnings的选项功能，可以通过Settings &gt; System &gt; Developer options 下找到开启。 再次运行代码后，界面上会弹出类似于下面的这样一个Toast,告知你的通知消息post失败，详细情况查看log 123Developer warning for package &quot;com.shoewann.notificationsimple&quot; Failed to post notification on channel &quot;null&quot; See log for more details 查看log是这样的： 1E/NotificationService: No Channel found for pkg=com.shoewann.notificationsimple, channelId=null, id=0, tag=null, opPkg=com.shoewann.notificationsimple, callingUid=10083, userId=0, incomingUserId=0, notificationUid=10083, notification=Notification(channel=null pri=0 contentView=null vibrate=default sound=default tick defaults=0xffffffff flags=0x11 color=0x00000000 vis=PRIVATE) 通过跟踪查看相关源代码，分析到了，在NotificationCompat这个类中的Builder方法。 在版本com.android.support:appcompat-v7:26.1.0的兼容库中，可以看到传一个参数的Builder(Context context)方法已经过期，使用传入两个参数的Builder(@NonNull Context context, @NonNull String channelId)新方法代替。 注意：该新方法需要传入的这两个参数都是标注了@NonNull，也就是不能传入null或者未初始化的变量。 兼容代码通过以上的分析，也就是我们在Android Oreo上面使用Notification，就必须要为你的Notification创建一个Notification Channels(通知渠道)。 创建通知渠道12345678910111213141516171819202122232425262728293031323334353637383940414243NotificationCompat.Builder builder = null;if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123; NotificationChannel channel = new NotificationChannel("通知渠道ID", "通知渠道名称", NotificationManager.IMPORTANCE_DEFAULT); channel.enableLights(true); //设置开启指示灯，如果设备有的话 channel.setLightColor(Color.RED); //设置指示灯颜色 channel.setShowBadge(true); //设置是否显示角标 channel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE);//设置是否应在锁定屏幕上显示此频道的通知 channel.setDescription("通知渠道描述");//设置渠道描述 channel.setVibrationPattern(new long[]&#123;100,200,300,400,500,600&#125;);//设置震动频率 channel.setBypassDnd(true);//设置是否绕过免打扰模式 mNotificationManager.createNotificationChannel(channel); createNotificationChannelGroups(); setNotificationChannelGroups(channel); builder = new NotificationCompat.Builder(this, "通知渠道ID"); builder.setBadgeIconType(BADGE_ICON_SMALL);//设置显示角标的样式 builder.setNumber(3);//设置显示角标的数量 builder.setTimeoutAfter(5000);//设置通知被创建多长时间之后自动取消通知栏的通知。&#125;else&#123; builder = new NotificationCompat.Builder(this);&#125;//setContentTitle 通知栏通知的标题builder.setContentTitle("内容标题");//setContentText 通知栏通知的详细内容builder.setContentText("内容文本信息");//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）builder.setAutoCancel(true);//setLargeIcon 通知消息上的大图标builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));//setSmallIcon 通知上面的小图标builder.setSmallIcon(R.mipmap.ic_launcher);//小图标//创建一个意图Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com"));PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0);//setContentIntent 将意图设置到通知上builder.setContentIntent(pIntent);//通知默认的声音 震动 呼吸灯builder.setDefaults(NotificationCompat.DEFAULT_ALL);//构建通知Notification notification = builder.build();//将构建好的通知添加到通知管理器中，执行通知mNotificationManager.notify(0, notification); 效果图: 向右滑动通知消息，可以显示延迟本条消息显示和设置选项 点击左边的延迟本条消息显示的时间 点击右边的设置选项，可以显示进入操作通知的设置入口 在桌面上的快捷方式上会显示角标 长按快捷方式，会在快捷方式旁边弹出通知栏窗口，显示通知栏消息等信息。 移除通知渠道123if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123; mNotificationManager.deleteNotificationChannel("通知渠道ID");&#125; 跳转到通知渠道设置123456if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123; Intent intent = new Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS); intent.putExtra(Settings.EXTRA_CHANNEL_ID, "通知渠道ID"); intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName()); startActivity(intent);&#125; 创建通知渠道组123if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123; mNotificationManager.createNotificationChannelGroup(new NotificationChannelGroup("通知渠道组ID", "通知渠道组名称"));&#125; 绑定通知渠道组123if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123; channel.setGroup("通知渠道组ID");&#125; 本文只是简要的总结了通知渠道的基本用法，还有更多的使用方法，请参考Android官方文档-NotificationChannel。关于本文如有不足之处，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
        <category>Notification</category>
      </categories>
      <tags>
        <tag>Notification Channels</tag>
        <tag>Android O</tag>
        <tag>通知渠道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Android WindowManager行为变化]]></title>
    <url>%2F2018%2F01%2F01%2Fabout-android-windowmanager-behavior-changes%2F</url>
    <content type="text"><![CDATA[本文是关于针对Android WindowManager悬浮窗行为变化的总结。 官方参考WindowManagerpublic interface WindowManagerimplements ViewManager android.view.WindowManager 示例首先创建一个简单的WindowManager悬浮窗，具体代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041package com.shoewann.windowmanager;import android.graphics.PixelFormat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.Gravity;import android.view.View;import android.view.WindowManager;import com.shoewann.windowmanager.view.FloatView;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); (findViewById(R.id.btn_show)).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; setUpFloatView(); &#125; &#125;); &#125; public void setUpFloatView() &#123; WindowManager windowManager = (WindowManager) getSystemService(WINDOW_SERVICE); FloatView floatView = new FloatView(getApplicationContext()); WindowManager.LayoutParams params = new WindowManager.LayoutParams(); params.type = WindowManager.LayoutParams.TYPE_PHONE; params.format = PixelFormat.RGBA_8888; params.gravity = Gravity.START | Gravity.TOP; params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; params.width = 200; params.height = 200; params.x = 0; params.y = 0; floatView.setImageResource(R.mipmap.ic_launcher_round); windowManager.addView(floatView, params); &#125;&#125; 上面的代码简单易懂，这里就不再进行解释了。 最后不要忘记了，在AndroidManifest.xml添加所需要的权限。 1&lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" /&gt; 行为变化SDK &lt; Android M以上的示例代码，在这种情况下(比如Kitkat 4.4)的设备上现在就已经可以成功创建出一个系统悬浮窗了。 运行，效果图如下 SDK &gt;= Android M到了Android M 之后的设备，也就是targetSdkVersion要指定23(及其以上)，程序就会崩溃，抛出如下异常信息： 1234567891011121314151617E/AndroidRuntime: FATAL EXCEPTION: main Process: com.shoewann.windowmanager, PID: 3120 android.view.WindowManager$BadTokenException: Unable to add window android.view.ViewRootImpl$W@c1fda7 -- permission denied for this window type at android.view.ViewRootImpl.setView(ViewRootImpl.java:591) at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:310) at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:85) at com.shoewann.windowmanager.MainActivity.setUpFloatView(MainActivity.java:39) at com.shoewann.windowmanager.MainActivity$1.onClick(MainActivity.java:21) at android.view.View.performClick(View.java:5198) at android.view.View$PerformClick.run(View.java:21147) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:148) at android.app.ActivityThread.main(ActivityThread.java:5417) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616) 参考:SYSTEM_ALERT_WINDOW Note: If the app targets API level 23 or higher, the app user must explicitly grant this permission to the app through a permission management screen. The app requests the user’s approval by sending an intent with action ACTION_MANAGE_OVERLAY_PERMISSION. The app can check whether it has this authorization by calling Settings.canDrawOverlays(). 官方的解释是，如果你的应用程序目标API等级为23或者更高版本，在使用SYSTEM_ALERT_WINDOW权限时，需要先调用Settings.canDrawOverlays()来判断一下是否允许创建悬浮窗，如果允许的话就可以创建了，不允许的话还要发送一个action值为ACTION_MANAGE_OVERLAY_PERMISSION的Intent来让用户同意创建悬浮窗。 针对该行为变化，对上面的示例代码进行了修改,添加权限请求，以兼容Android M： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.shoewann.windowmanager;import android.content.Context;import android.content.Intent;import android.graphics.PixelFormat;import android.net.Uri;import android.os.Build;import android.provider.Settings;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.Gravity;import android.view.View;import android.view.WindowManager;import com.shoewann.windowmanager.view.FloatView;import java.lang.reflect.Method;public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); (findViewById(R.id.btn_show)).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (!commonROMPermissionCheck(MainActivity.this)) &#123; requestAlertWindowPermission(); &#125; else &#123; setUpFloatView(); &#125; &#125; &#125;); &#125; public void setUpFloatView() &#123; Log.d(TAG, "setUpFloatView() called"); WindowManager windowManager = (WindowManager) getSystemService(WINDOW_SERVICE); FloatView floatView = new FloatView(getApplicationContext()); WindowManager.LayoutParams params = new WindowManager.LayoutParams(); params.type = WindowManager.LayoutParams.TYPE_PHONE; params.format = PixelFormat.RGBA_8888; params.gravity = Gravity.START | Gravity.TOP; params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; params.width = 200; params.height = 200; params.x = 0; params.y = 0; floatView.setImageResource(R.mipmap.ic_launcher_round); windowManager.addView(floatView, params); &#125; private static final int REQUEST_CODE = 1; //判断权限 private boolean commonROMPermissionCheck(Context context) &#123; Log.d(TAG, "commonROMPermissionCheck() called with: context = [" + context + "]"); Boolean result = true; if (Build.VERSION.SDK_INT &gt;= 23) &#123; try &#123; Class clazz = Settings.class; Method canDrawOverlays = clazz.getDeclaredMethod("canDrawOverlays", Context.class); result = (Boolean) canDrawOverlays.invoke(null, context); &#125; catch (Exception e) &#123; Log.e(TAG, Log.getStackTraceString(e)); &#125; &#125; return result; &#125; //申请权限 private void requestAlertWindowPermission() &#123; Log.d(TAG, "requestAlertWindowPermission() called"); if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123; Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION); intent.setData(Uri.parse("package:" + getPackageName())); startActivityForResult(intent, REQUEST_CODE); &#125; &#125; @Override //处理回调 protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if (Settings.canDrawOverlays(this)) &#123; Log.i(TAG, "onActivityResult granted"); setUpFloatView(); &#125;else &#123; Log.i(TAG, "onActivityResult denied"); &#125; &#125; &#125; &#125;&#125; 运行,效果图如下 SDK &gt;= Android O到了Android O 的设备运行上面在M上二次修改的动态请求权限的代码，程序抛出运行时异常，随后崩溃，这又是为什么呢？ 1234567891011121314151617E/AndroidRuntime: FATAL EXCEPTION: main Process: com.shoewann.windowmanager, PID: 17929 android.view.WindowManager$BadTokenException: Unable to add window android.view.ViewRootImpl$W@d422e7c -- permission denied for window type 2002 at android.view.ViewRootImpl.setView(ViewRootImpl.java:789) at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:356) at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:93) at com.shoewann.windowmanager.MainActivity.setUpFloatView(MainActivity.java:54) at com.shoewann.windowmanager.MainActivity$1.onClick(MainActivity.java:34) at android.view.View.performClick(View.java:6294) at android.view.View$PerformClick.run(View.java:24770) at android.os.Handler.handleCallback(Handler.java:790) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:164) at android.app.ActivityThread.main(ActivityThread.java:6494) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807) 查阅Android Oreo官方文档，Alert windows行为变化 应用程序使用SYSTEM_ALERT_WINDOW权限时，不再支持如下窗口类型在其他应用和系统窗口之上显示警告窗口了： TYPE_PHONE TYPE_PRIORITY_PHONE TYPE_SYSTEM_ALERT TYPE_SYSTEM_OVERLAY TYPE_SYSTEM_ERROR 应用必须使用一个被叫做TYPE_APPLICATION_OVERLAY类型的新窗口类型替代。 当使用TYPE_APPLICATION_OVERLAY类型的窗口为你的应用程序去显示警告窗口，请记住新窗口的如下特征： 一个应用程序的警告窗口总是显示在系统窗口之下，比如状态栏和输入法。 系统能够移除和重置窗口大小，使用TYPE_APPLICATION_OVERLAY类型的窗口去提高屏幕演示 通过打开通知栏窗帘，用户能够访问设置去屏蔽一个应用通过TYPE_APPLICATION_OVERLAY窗口类型去显示警告窗口的显示 针对该行为变化，对上面的示例代码进行了修改，以兼容Android O： 更改TYPE_PHONE为TYPE_APPLICATION_OVERLAY 12- params.type = WindowManager.LayoutParams.TYPE_PHONE;+ params.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY; 运行,效果图如下 以上就是简单的对Android WindowManager悬浮窗行为变化的简单总结。如有不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
        <category>WindowManager</category>
      </categories>
      <tags>
        <tag>Android O</tag>
        <tag>WindowManager</tag>
        <tag>Android M</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 模拟器快速启动和主要功能]]></title>
    <url>%2F2017%2F12%2F19%2Fquick-boot-top-features-in-android%2F</url>
    <content type="text"><![CDATA[原文来自：Quick Boot &amp; the Top Features in the Android Emulator 今天我们很高兴的宣布Android模拟器快速启动。使用快速启动，您能在6秒内启动模拟器。快速启动通过快照模拟器会话来工作，因此您能够在几秒钟内重新加载。快速启动是在Android Studio 3.0 canary更新通道首次发布，我们很高兴的的在今天的更新中将这一个功能作为稳定版本发布。 除了这个新功能以外，我们也想突出显示最近发布的一些主要功能，自从两年前对Android模拟器进行了改造，我们继续将焦点放在改善速度、兼容性和添加一些丰富的功能，加速您的应用程序开发和测试。随着最近所有的变化，今天绝对值得去更新Android模拟器到最新版并使用它。 主要的5个功能 快速启动 —— 今天作为一个稳定功能发布，快速启动允许您在6秒之内恢复您的Android模拟器会话。首次您开始启动Android模拟器的Android虚拟设备，它必须执行冷启动(就像启动设备一样)，但是随后的启动速度很快，系统将会恢复在您最后关闭模拟器时的状态(像唤醒设备一样)。我们通过完全重新设计旧式仿真器快照架构，使用虚拟传感器和GPU加速工作来完成了这个。无需额外的请求，因为快速启动在Android模拟器v27.0.2版本上是默认开启的。 Android CTS 兼容性 —— 每发布一个版本的Android SDK，我们都将确保Android模拟器已经为您的应用程序做好了需要的开发准备，从测试向后兼容的Android KitKat到集成了最新APIs的开发者预览版。对于增加模拟器系统镜像产品的质量和可靠性，我们现在从Android Nougat (API 24) 或者更高的对Android 兼容性的测试套件(CTS)构建有资格的最终版Android系统镜像 — 相同的测试套件官方Android物理设备必须通过。 Google Play支持 —— 我们知道大多数的应用程序开发者使用Google play 服务，在Android模拟器系统镜像上是很难保持服务的最新。为了解决这个问题，我们现在提供的Android系统镜像包括了Play商店的应用程序。Google Play 服务现开始从Android Nougat (API 24)可以使用了。这些新的模拟器镜像，您可以从您模拟器里面的Play 应用商店里面更新Google Play服务，正如您会在物理设备上操作的一样。还有就是，您现在能够使用Google Play应用商店测试结束到结束安装、更新和购买流程。 性能提高 —— 使模拟器更快速以及性能是我们团队正在进行的一个目标。我们持续的观察运行在您的开发机器上的模拟器对性能的影响，尤其是内存使用情况。使用最新版的Android模拟器，我们现在按需求分配RAM(内存)，而不是在您的AVD中定义最大的内存大小去分配和固定内存。对于Linux (KVM) 、macOS® (Hypervisor.内核)我们通过挖掘本地虚拟管理程序来实现这个，以及对Microsoft® Windows®增强Intel® HAXM (v6.2.1 或者更高版本)，它使用新的按需要分配内存。 额外的还有，再过去的几个版本中，我们有改善CPU和I/O性能，同时增强了GPU的性能，包括了对OpenGL ES 3.0的支持。看一下像ADB推送这样常见的任务，突出了Android CPU和I/O管道的改进： 对于GPU性能，我们创建了一个简单的GPU仿真压力测试应用程序去测量时间的推移。我们发现最最新版本的模拟器能够渲染比之前更高速的帧率，它是少数模拟器之一能够准确的按照Android规范去渲染OpenGL ES。 更多的功能点除了这些主要的功能以外，这儿还有一大堆额外的功能，我们在过去的一年中已经添加到了Android 模拟器，您可能还不知道： Wi-Fi支持 —— 从API 24的系统镜像开始，您能创建一个包含了连接到一个虚拟的数据网络和一个虚拟的Wi-Fi访问点的AVD Google cast 的支持 —— 当使用一个Google Play 系统镜像，您能够在相同的Wi-Fi网络下够投屏幕和音频内容到Chromecast设备。 拖拽APKs和文件 —— 简单的拖拽一个apk到Android模拟器的窗口去触发一个app应用程序的安装。您也能够拖拽任意其它文件，并在您的Android虚拟设备里的/Downloads文件夹下发现它们。 主机复制&amp;粘贴 —— 您能够复制&amp;粘贴文本在Android模拟器和您的开发机器之间。 虚拟的两个手指捏&amp;缩放 —— 当您的应用程序像集成了Google Maps，按下Ctrl键(在Microsoft® Windows®或者Linux上)或者⌘ (在macOS®上)，并在屏幕上出现手指叠加以帮助捏和缩放操作。 GPS位置 —— 手动选择一个GPS点或者在Android模拟器的位置下选项卡下设置GPS点。 虚拟传感器 —— 在扩展控制面板上是一个支持传感器专用的页面，包括了加速度，方向，接近度以及更多 摄像头支持 —— 您能够使用一个摄像头或者您的笔记本内置的摄像头作为一个在AVD里面虚拟的摄像头。在AVD设置页面里面的高级设置页面验证您的相机设置。 主机键盘 —— 您能够使用您真实的键盘去输入文本内容到Android虚拟设备。 虚拟短信和拨号 —— 在扩展控制面板，您能够触发一个虚拟的短信或者拨号的去测试您应用里电话的依赖。 屏幕缩放 —— 在主工具栏，点击放大镜图标进入放大模式，然后选择一个您需要检测的屏幕区域。 窗口重置大小 —— 简单的拖拽Android模拟器窗口的一个角去改变您想要的大小 网络代理的支持 —— 通过到代理选项卡下的设置页面，添加一个自定义的HTTP代理到您的Android模拟器会话。 Bug 报告 —— 您能够通过使用在扩展控制面板的Bug报告部分，快速的为您的应用程序生成一个bug报告，并分享到您的团队或者发送反馈到Google 了解更多关于Android模拟器的内容，参考模拟器文档 从这里开始这些所有的功能和改善都可以使用了，去下载并现在使用Android 模拟器v27.0.2+，您能够从Android Studio中的SDK Manager里面获得。对于一个快速的体验，我们建议您创建和运行x86版本的模拟器系统镜像，使用最新版本的Android 模拟器，安装 Intel® HAXM(如果适用)和显卡驱动。 我们感谢您反馈任何您喜欢的意见建议，问题或者您希望看到的功能。如果您发现了一个bug、issue或者有一个功能请求随时提出问题,我们无疑没有完成，但是我们希望您对到目前为止的改进感到兴奋。 以上是对Google官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
        <category>Android Emulator</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>Android Emulator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDD China 2017之旅]]></title>
    <url>%2F2017%2F12%2F18%2Fgdd-china-2017-in-shanghai-trip-record%2F</url>
    <content type="text"><![CDATA[2016年，那个时候我还在上海。去年的GDD上海场我没有去参加，当时是有些遗憾；今年2017年的GDD如期而至，两天都在上海举办，而我已经不在上海，回到了成都。这时的我决定去参加，因为我是谷歌爱好者，梦寐有机会去参加一次谷歌总部的活动，既然出国不行，那在国内举办活动更近了，并且这次大会我可以和我一直只能在电视和社交软件上的关注的谷歌大佬面对面，更不容错过！ 通过GDD大会邮件的报名、筛选，我有幸成为了大会的嘉宾之一，GDD China 2017 活动举办的时间越来越近了。12月12日下午下班，没来得及吃饭，我就直奔机场，踏上成都飞往上海的航程。21：00的飞机，到上海已经23:10分，然后深夜地铁已经结束运营了，只好乘坐的士到以前上海的同事住的地方，已经是第二天凌晨12:00多了。 13日，GDD China 2017大会举办的第一天，地点在上海跨国采购会展中心。迎着朝阳，我来到了会场地点。首先需要通过安检方可进入会场，在会场外，随处可见Google的元素，Android机器人、Google Map定位图标，GDD China 2017大会代表中国元素的图案，旗帜，还有一些帐篷。会展大楼入口上面贴着醒目的“Google Developer Days China 2017”的Logo 走进会场内，一楼进门口正对的是大会3D的Logo，从左侧看是Google，从右侧看是GDD2017，旁边是签到处，我排好队在签到处提供了签到二维码领到了大会的证件以及Google的纪念礼包，里面包含了DIY音响、贴纸等。之后，到了二楼领了同声传译机，去了三楼的会场层。 我来的还算比较早，在三楼有Google各种产品的展台，AndroidThings&amp;IoT、Android Wear、Android Assistant、Codelab、GDG等等。时间越来越近了，大会参加的人也越来越多了，10:00大会即将开始，我们进入了主会场听取大会的开幕主题演讲。主会场容纳了2000-3000人，随着代表着中国元素的舞蹈拉开了GDD China 2017大会的序幕。 这种气氛仿佛是就是在Google I/O现场，我见到了Google产品总监Andrew Bowers, Google大中华区总裁石博盟(Scott Beaumont),还有李飞飞博士，Google Cloud人工智能和机器学习首席科学家，两次提到了“AI 没有国界，AI 福祉亦无边界。”，并当场宣布了：谷歌AI中国中心的成立。现场如爆裂般的欢呼。 主会场的主题演讲之后，接下来两天的活动也算正式开始了。听了一场由Pete LePage演讲的主题分享之后，就到了午餐时间。在每个活动现场的展会证上都有两天的用餐券，免费提供午餐，在会场的一楼。会场数千人从会场到就餐区，享受Google提供的西式自助餐带来的惬意。 午餐之后，距离下午的分会场活动开始还有一段时间，就在会场转了转。Google的产品展示区，你可以通过下载APP玩游戏活动糖果、通过使用Google翻译扫描明细片上地点的名称在大会现场找到当地的邮票就可以活动谷歌的抱枕、还有单人/多人的QuickDraw、根据你弹奏的曲目自动通过人工智能的方式做出一段相似的旋律、在3D空间内体验艺术的宇宙大爆炸、Tensorflow通过采集人脸数据，自动识别人脸、物联网设备的猜拳和作画等 很多很多只能在Google总部体验到的产品，都能在现场体验到。在AndroidThings展台和分会场领取一张AndroidThings的兑换券，就能去兑换一套价值不菲的AndroidThings开发套件。通过扫描证件后面的二维码反馈大会意见和建议成功就能获得Google定制的电脑包一个，不过到最后我都没有去领。 下午参加了几场分会场的活动，其中也包含了比较熟悉的演讲嘉宾Daniel Galpin、Hoi lam、Wayne Piekarski、Laurence Moroney。 本次大会还发布了Tensorflow中文网站 —— tensorflow.google.cn，并创建了Tensorflow公众号，为中国开发者提供了Tensorflow的新闻和技术资源。 After Party，晚宴时间。仿照I/O的方式，主会场变成了party场地，台下有香槟红酒、可乐雪碧、蛋糕水果自助餐，街机电竞游戏，投篮球比赛。台上乐队尽情演奏，灯光和LED显示屏伴随着音乐也嗨了起来，在音乐声中大家也慢慢的散场，每个人都提着Google提供的大礼包，结束了第一天的活动。 14日，GDD大会的第二天，也是最后一天。今天的目标除了听大会喜欢的演讲嘉宾分享技术上新东西，复习和学习以外，还有——当然是找演讲嘉宾他们合影了。 这两天的活动，由于部分主题人数爆满，临时新增加了分会场，像人工智能、机器学习、Google Cloud等等，虽然我是主要做Android Mobile开发的，但在这次大会上我没有去听Android Oreo相关的话题，应该最多的还是AndroidThings、Tensorflow相关的。 最后，荣幸的是，我成功的和Laurence Moroney、Wayne Piekarski合影了。遗憾的是，我错过了Daniel Galpin、Hoi lam、还有Ankur Kotwal的交流。 Laurence Moroney说14日当天晚上要离开，准备回去过圣诞节！Merry Christmas ~ Wayne Piekarski握了一个手，问我最后一场是他的演讲，要去不去参加，我说当然。 在离开会场时Wayne还给我发androidThings的卡劵去领，我说我已经有一个了，然后挥手道别,两天的GDD活动结束了，我体会到了很多，很多收获和感想。特别是Andrew Bowers和Anna D Goldie，中文讲的真好。 正如stormzhang说的那样：如果你没去GDD，那真是一种遗憾。 GDD 明年见 ~ 以上就是个人第一次参加GDD活动的一个简单总结]]></content>
      <categories>
        <category>GDD</category>
      </categories>
      <tags>
        <tag>GDD</tag>
        <tag>GDD China 2017</tag>
        <tag>Google Developer Days</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍Android Oreo(Go版)与Android8.1的发布]]></title>
    <url>%2F2017%2F12%2F05%2FIntroducing-android-oreo-go-edition%2F</url>
    <content type="text"><![CDATA[原文来自：Introducing Android Oreo (Go edition) with the release of Android 8.1 自Android的创建，我们的使命是将计算的力量带给每一个人。作为一个全球操作系统，Android已经发展到全球超过20亿激活设备，印度的用户人数超过了美国。 为了确保数十亿人能够访问到计算，入门级设备是功能齐全的智能手机，可以浏览网页和使用应用程序。在今年的Google I/O大会上,我们提前看了一个被我们称之为”Android Go”的项目，并让这个项目成为可能。我们激动的宣布这个软件体验——Android Oreo(Go版)——准备好了,将在明天作为Android 8.1发布的一个部分发布。 具有512MB到1GB内存的Android Oreo设备将随着Go的全面优化而来,这个Android Oreo(Go版)体验是由三个关键部分组成： 操作系统：对于操作系统的性能和存储提高,数据管理功能和内置安全优势。 Google 应用：一组新的Google应用程序,设计更轻且与首次上网的人的独特需求相关。 Google Play商店：一款调整版本的Google Play商店允许你下载任意的应用程序,但是也突出了在你设备上设计最好的应用程序。 Go 大，性能更快，更多存储，数据管理和安全性我们增强了Android Oreo（Go版）在入门级设备上对于速度和可靠性，意味着在Android Oreo（Go版）的设备上运行的平均应用程序现在快了15%，这儿有很多这样各种各样的优化——它们真的加起来了。如果所有的入门级Android设备启动应用程序的速度提高15%,将节约全球累计100万小时的时间——每天！ 入门级设备,一旦你考虑到操作系统的大小和预装的应用程序，它们通常有着非常小的存储空间可以使用。对于那些想要更大空间为了他们的音乐、应用程序以及照片的人来说这个就很沮丧了。因此，我们将优化Android Oreo（Go版）并增强我们预安装的Google应用程序占用至少50%的空间。最终的结果是，我们已经将入门级设备上面的可用空间增加了一倍。 设备运行了Android Oreo（Go版）也伴随了默认开启的Google的数据节省器功能的到来。比如说,在Chrome中的数据节省器每年节约了平均每个用户超过600MB的数据。你也能够通过使用我们内置的数据节省功能管理在后台使用数据的应用程序，给你更多控制你的数据是如何被使用的。 Android Oreo是Android最安全的版本,因此当你购买一款Android Oreo（Go版）的设备，你将能够获得所有相同的安全功能,并且当然所有的Android Oreo（Go版）的设备都内置了获取Google Play Protect。Google Play Protect一直保持你的设备工作,数据和应用程序安全。它能够扫描你的应用程序安装,甚至当你是离线状态,不管你从哪儿下载了它们。 Go 和 谷歌我们将重新设计大多数我们流行的Google应用程序去解决当地的需要。预安装在Android Oreo（Go版）设备,这套通过Google优化的应用程序包括Google Go,Google Assistant Go,YouTuBe Go,Google Map Go,Gmail Go,Gboard,Google Play,Chrome和新的File Go应用程序。 我们新的和重新想象的Google应用程序，我们将关注于使它们不仅仅更小,但是也光滑快速。比如说,Google Go——一款新的应用程序去查找里想要的信息——通过提升40%优化数据,重量大小不到5MB,并且使用简单、可点击的方式就能很快速的找到流行和趋势信息。对于Android(Go版)的Google Assistant,你能够快速的发送消息、打电话、设置闹钟以及更多利用你的声音和一个单一的屏幕触碰。 我们的存储节省功能是由Google扩展操作系统之外的一个全新的文件管理应用程序——File Go——帮助你清理空间，保持有组织。无论是来自你手机删除垃圾邮件的建议，重复的图像或者是未使用的应用程序,File Go是Android Oreo(Go版)的存储最大化功能的完美补充。 Go Play在Google商店,你能够下载任意的应用程序,并且我们也创建了一个新的部分建议流行的应用程序，调整为入门设备上运行良好。 我们很高兴的看到我们大多数的合作伙伴使用了我们建了数十亿方针，要么优化现有的应用程序，要么去创建一个新的应用程序在入门级设备上运行良好。希望将他们的经验带给数十亿新的智能手机用户。 准备.设置.Go在Android 8.1中推出Android Oreo(Go版)，合作伙伴将在不久就能够在全球的入门级设备上发布这个新版本，我们不能等待我们的合作伙伴的设备在未来的的几个月上架。 如果你是一个开发者，我们一起为下一个十亿人构建。 以上是对Google官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
        <category>Android Oreo</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Oreo Go</tag>
        <tag>Android Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公布架构组件1.0稳定]]></title>
    <url>%2F2017%2F11%2F07%2Fannouncing-architecture-components-10%2F</url>
    <content type="text"><![CDATA[原文来自：Announcing Architecture Components 1.0 Stable Android运行在数十亿台设备上,从高端手机到飞机座椅靠背。在这个庞大的设备范围Android操作系统积极的管理资源已取得了良好的表现，有的时候能构建出强大复杂的应用程序。 为了使它变得更加简单，我们在Google I/O大会上启动了一个预览版的架构组件，在应用程序架构上提供指导。包括了像生命周期管理和数据持久化等通用任务的库。总而言之，这些基础的组件通过较少的代码样本去写模块化应用程序使它成为可能。因此开发者们能够关注于创新而不是重新造轮子 —— 并且我们希望在未来保持在这个基础上去构建。 今天我们很高兴的宣布了Room和Lifecycle架构组件库到了1.0稳定。这些API已经为生产应用程序和库做好了准备，是我们建议开发者寻找架构用程序架构的帮助以及本地存储(尽管这里这里是建议，但是不要求)。Lifecycle现在也能够和支持库集成，因此你能够使用像AppCompatActivity这样标准的类去使用它们。 尽管我们在今天声明它们稳定，公测的组件已经在应用程序中一起使用了，有数十亿次安装。顶端开发者，像Zappos,已经能花费更多的时间去感谢架构组件什么是最重要的: 在Android架构组件发布之前，我们有自己的ViewModel实现，我们使用Loaders和Dependency注入，通过更改配置去保存我们的ViewModel。我们最近切换到了Android架构组件ViewModel实现，所有的样板都消失了。我们发现我们可以花费更多的时间在设计、业务逻辑以及测试上面，在写样板和担心Android生命周期上的问题也会少一点了 我们也开始去使用LiveData将它直接勾进Android生命周期里。我们使用它去回收和展示网络数据，并且不必再去关心网络呼叫订阅管理 —— Zappos公司Android软件工程师大卫亨利 架构组件提供了一个示例，灵活而适用的方法让开发者们免去了一些共同问题，因此他们能够关注于构建更棒的体验，这个是依靠于应用程序架构向导的核心构建块。 Lifecycle每一个android开发者必须要处理操作系统开始、停止以及销毁它们的活动。这就意味着管理组件的状态——比如观察被使用去更新UI界面——如同你移动通过生命周期一样。Lifecycle(生命周期)能够创建生命周期-感知组件来管理它们自己的生命周期，减少泄漏或者崩溃的可能性。Lifecycle库是像LiveData等其它架构组件的基础 LiveDataLiveData(动态数据)是一个支持数据并提供更新可观察的生命周期-感知。你的UI代码订阅更改并提供LiveData一个参考到Lifecycle。因为LiveData是生命周期-感知，当它的生命周期被开始或者被恢复，它将提供更新，但是当生命周期主被销毁，则停止提供更新。LiveData是一个简单的方式去构建被动的UI界面，更安全更高效。 ViewModelViewModel(视图模型)像Activity和Fragment一样从生命周期的实体分离视图数据和逻辑的所有权。一个ViewModel是被保留的直到与它相关联的Acitivty和Fragment永久的被抛弃——这就意味着视图数据能够像一个Fragment由于旋转而重新被创建幸存。ViewModel不仅仅是消除生命周期共同问题，它们帮助构建更模块化方便测试。 Room几乎所有的应用都需要在本地存储数据，当自从版本1开始Android绑定了SQLite和平台，直接使用它是很痛苦的。Room(房间)是一个简单的对象映射层，利用较少的样板提供满功率的SQLite。特性像编译时间查询验证并内置迁移，使构建一个强大的持久层更加容易。当与LiveData集成，让Room提供数据库支持、可观察的生命周期感知。Room对于管理本地存储，融合了简单、强大和稳健。我们希望你能够尝试它一下。 App架构向导以及更多最后但并不是不重要的，我们创建了一个应用程序架构指南 为所有的开发者提供实用的核心原则，有关使用架构组件的具体指南，因为我们从你们那儿清楚的听到了一致的答复指南是重要的。今天我们适当的更新了开发者文档去指出架构组件。我们在架构组件站点也有一套丰富的视频、代码实验室和示例应用程序可用，来获得更多。 看这个空间尽管第一组架构组件现在是稳定，我们知道这儿还有更多工作需要做。在过去的几个月中，我们听取了你的反馈进行了提高，我们也在最近启动了一个新的架构组件,PagedList，对于alpha,回应你们的反馈，用RecyclerView处理大数据集太困难了，这仅仅是开始——我们有更多基本的组件在开发，我们将在期待在接下来的几个月中宣布。 我们对架构组件的期望是让开发者在移动设备上能够专注于提供独特的全新体验。我们很荣幸我们能够最终宣布它们作为正式生产使用,我们要感谢社区，一路上给了一些很棒的反馈，我们期待这继续讨论这篇文章的评论。最后，对于那些等待这个正式启动的人来说，从今天开始 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
        <category>Architecture Components</category>
      </categories>
      <tags>
        <tag>Develop</tag>
        <tag>Android Developer</tag>
        <tag>Announcements</tag>
        <tag>Architecture Components</tag>
        <tag>Best Practices</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍Android即时应用SDK 1.1]]></title>
    <url>%2F2017%2F10%2F13%2Fintroducing-android-instant-apps-sdk-11%2F</url>
    <content type="text"><![CDATA[原文来自：Introducing Android Instant Apps SDK 1.1 自从我们在Google I/O上面公开启动,我们已经努力工作去提升开发者构建即时应用的体验。今天我们激动的宣布Android即时应用SDK1.1可用。一些高度请求的功能，像提升NDK的支持、配置APKs以此减少二进制的大小，以及一个全新的API，当用户从一个即时应用程序过渡到已安装好应用程序，去保持用户的上下文。 介绍配置APKs对于一个非常棒的即时应用体验，应用二进制需要精益和良好的结构。这也是为什么我们要介绍配置APKs 配置APKs允许开发者隔离设备－验证资源和依赖在APKs里面的本地库。对于一个应用使用配置APKs,Android即时应用核心将只会加载资源和本地库相关的给用户的设备，从而减少即时应用程序在设备上的总大小。 我们当前支持配置APKs的显示密度，CPU的体系结构(ABI),以及语言。这些，我们看到在已加载的二进制大小平均降低了10%。给定应用程序的实际节省依赖于资源文件数和本地库，能够被配置。 以一个示例来说，一个用户在一部LDPI屏幕密度的ARM设备上设置了中文语言，接收与设备无关的代码和资源，然后只能获取配置APKs是ARM本地库、中文语言、以及LDPI资源。它们将不能够接收到其他任意的配置APKs，比如x86的库，西班牙语言的字符串，或者HDPI的资源。 为你的应用设置配置APKs只需要简单的改变你的gradle文件的设置。跟随我们公开的文档步骤。 安装之后的持久化用户上下文在Android奥尼奥，即时版本应用的内置存储可以直接用于安装版本应用程序。这次发布的SDK,我们能够在旧版本的Android核心上启用这个功能，包括棒棒糖、棉花糖、和牛轧糖的设备。 提取即时应用程序的内置存储，安装应用程序现在能够调用InstantAppsClient.getInstantAppData()使用即时应用程序Google Play服务API，以及获得一个即时应用程序内置存储的ZIP文件。 检出我们示例代码和文档获取如何使用这个API的更多详细。 开始构建你的Android即时应用在最新版的SDK上构建你的即时应用程序是简单的，只需要在Android Studio里面打开SDK Manager，然后升级你的Instant App Development SDK到1.1.0。我们迫不及待的想看到你为即时应用程序构建这些新的功能特性。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
        <tag>Develop</tag>
        <tag>Android Instant Apps</tag>
        <tag>Play Console</tag>
        <tag>Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌助理能够帮助您控制Android媒体应用程序]]></title>
    <url>%2F2017%2F10%2F12%2Fthe-google-assistant-can-help-control%2F</url>
    <content type="text"><![CDATA[原文来自：The Google Assistant can help control your Android media apps 谷歌助理可用贯穿通了手机，音响，安卓电视以及更多。它能够帮助用户在一天中完成更多的工作 —— 这儿它们需要添加一些事情到去完成的列表，打开电灯，或者播放一首歌曲。 音乐是特别的,助理有大量的提供。它能够通过设备(“播放摇滚乐”)理解媒体命令，并支持媒体控制(像暂停、跳过、快进、赞成)，用户也能通过谷歌助理控制安卓媒体播放。例如，您告诉谷歌助理”暂停回放”，无需抬起手指就能暂停回放。或者说”在Universal音乐播放器上播放摇滚乐”来播放音乐 为了让用户在使用您的媒体应用中的谷歌助理时能够控制回放，您可以使用MediaSessionAPI去让这件事发生。我们建议您在制作应用程序与Google Assistant的集成时，使用MediaSession。 在您的应用程序中如何使用MediaSession ？您必须实现一个MediaSession,在与谷歌助理进行交互时处理所描述的一组规定的动作。 这里是一些示例项目，能够帮您开始在您的媒体应用程序里面使用MediaSession 媒体浏览器服务示例 Universal 音乐播放器示例 助理与Leanback样本集成示例 对于想了解学习更多关于MediaSession，这里有一些好的资源： 理解MediaSession 使用MediaSession 使用谷歌助理在安卓电视上进行视频回放 谷歌助理如何使用MediaSession？谷歌助理使用MediaSession时和其他外部控制器(比如安卓可穿戴设备)相同的方式使用MediaSession。每一个控制器都会导致您的应用程序状态变化。并且这儿需要有一个方式去响应这些变化。这就是MediaSession的发挥作用的地方。 通过使用MediaSession,谷歌助理能够控制您的应用程序的媒体播放，以及保持同步其当前状态 如何使用MediaSession测试我的应用程序？一旦您实现了MediaSession您将可能想去测试，如何在您的应用程序以外去控制媒体播放，媒体控制器测试工具被创建去模拟外部控制您的媒体播放，您可以验证当其他应用程序(比如谷歌助理)与您的应用程序就行互动时，它将可以按预期方式工作。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Assistant</tag>
        <tag>MediaSession</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google发布Google I/O 2017 安卓源代码]]></title>
    <url>%2F2017%2F08%2F19%2Fgoogle-releases-source-for-google-io-md%2F</url>
    <content type="text"><![CDATA[原文来自：Google releases source for Google I/O 2017 for Android 今天我们发布官方Google I/O 2017 Android应用程序源代码 今年这个应用基本上修改了现有的功能，并且添加了一些新的功能。它也利用了Firebase去拓展技术堆栈。在这篇文章中，我们将高亮在这个应用程序的几个显著变化，以及它们设计的注意实事项。 对于2017版本最多突出的新功能是事件约束系统，这样被设计有助于节省参会者的时间，并提供精简的会议体验。注册参会能够在之前预约会话并添加到等待列表中。在会议期间，一个预约提供了加快进入会议，而不用长时间去等待。预约的数据将会和参会者会议徽章同步，允许事件工作人员使用NFC手机验证预约，不仅仅是预约功能非常受欢迎，但是预约数据帮助了事件工作人员在I/O大会之前和之间改变会话室的大小，以次来适应实际的座位需求。 预约的功能是使用Firebase实时数据库(RTDB)和Firebase云功能实现的。RTDB提供了通过用户的设备简单的同步——我们仅仅是在我们的代码中实现了一个监听来接收更新数据库。RTDB也提供了开箱即用离线支持，允许会议数据当在旅行是面对间歇性网络连接也可以使用。云端功能在后台处理用户预约的请求过程，使用交易去确保状态的正确性(防止恶作剧用户抓住太多的座位！)并和事件系统徽章通信。 对去年而言，我们使用了内容提供者(ContentProvider)作为一个抽象层覆盖所有应用数据，也就意味着我们必须指出如何使用内容提供者去整合RTDB数据。我们需要在有两个本地缓存数据之间进行协商：1）来源于内容提供者访问现存本地SQLite数据库，2）通过RTDB被创建的本地缓存去促进离线访问。我们决定在内容提供者之下整合所有的应用数据：无论何时在RTDB里用户预约的数据改变，我们将更新内容提供者，使它成为在任何时间应用程序数据的唯一真实来源。这就意味着我们需要去在一个唯一的屏幕对RTDB保持打开连接，会话详细信息界面，用户可能正在积极地管理他们的预约。预约数据通过内容提供着支持显示在应用程序的其他部分。在离线模式下，或者是在与RTDB的片断或延迟连接的情况下，我们能够从内容提供着获取用户的最后一个预约的已知状态。 我们还必须指出将RTDB整合到整个IOSched同步逻辑中的良好模式，尤其是自从RTDB伴随着非常不同的同步模式，而不是我们在应用程序中使用的ping-fetch方法。我们决定去继续使用云端点通过设备去同步用户的数据，网络和iOS客户端（数据本身存储在数据存储区中)。当RTDB提供了开箱即用数据同步，我们想确保所有设备上的用户预约数据都是最新的，甚至当应用程序不是在前台时，我们利用云功能去整合RTDB预约数据到同步流：一旦用户改变了在RTDB中预约数据，该功能更新了端点，触发了Firebase云消息下游消息到所有用户的设备上，然后调度数据同步。 今年的应用程序还推出了一个Feed功能去通知用户关于I/O的逐个小时的发展(大多数应用的用户是远程的，Feed只是他们进入会议的一个窗口)，Feed也是通过RTDB提供动力，数据使用了一个简单的CMS推送到服务器。我们使用了一个云功能去监控RTDB feed数据;当feed数据在服务器被更新，云功能就会发送一条云消息下游消息到客户端，视觉上为用户呈现新的Feed项。 在2015和2016年里，我们为IOSched已经通过了一个MVP架构，我们在今年继续使用。这个架构提供我们很好的分离关注，方便测试，并且大致来说使我们的代码更清洁和更容易去维护。对于Feed功能，我们决定利用一个更轻量级的MVP去实验实现，灵感来源于Android Architecture Blueprints,它提供了必要的模块化，同时非常容易概念化。这里的目标是教学和实践:我们想为开发者展示替代MVP模式，我们也想去展示一个适合我们对此功能的需求的架构。 首次，IOSched大量使用了Firebase远程配置。以往，我们发现了自己当非会话数据——无线信息不能够去通知用户，穿梭时间表，折扣代码等等。- 在会议之前或会议期间改变。强制一个应用升级更新是不可行的，我们只想让应用内默认值可以更新。使用远程配置很容易的就为我们解决了这个问题。 在最后，我们最终得到一个三层系统，通知用户有关变更: 会议数据和用户数据的改变是来源于云消息和数据同步(ping和fetch模型)去进行通信。 Feed数据的变化是来源于RTDB的控制 更改应用内的产量来源于远程配置的控制 未来计划即使我们正在发布2017的代码，我们在未来几个月仍然有工作领先于我们，我们将在后台进程(并使我们的应用程序“O”符合)中去更新代码去遵循现代模式。并且在未来，我们将采用Android的架构组件去简化应用程序的整体设计，开发者可以按照GitHub上的代码进行更改。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
        <category>Google I/O</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Google I/O</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android O开发者预览版4可用,官方Android O即将到来！]]></title>
    <url>%2F2017%2F07%2F25%2Fdeveloper-preview-4-now-available%2F</url>
    <content type="text"><![CDATA[原文来自：Developer Preview 4 now available, official Android O coming soon! 当我们在Android O平台上完成最后的首尾工作时，我们在今天推出了开发者预览版4去帮助您确保您的应用程序已经准备好了。 这个版本是我们在今年夏天晚些时候为消费者启动官方Android O平台之前的最后一个预览版本，借此机会去尽快结束您的测试并发布您的更新，给用户一个平稳过渡到Android O 如果您有一个设备已经在Android Beta Program上面注册了，您将会在接下来的几天收到一个到开发者预览版4的更新升级。如果您还没有注册您的设备，仅仅访问Android Beta 站点去注册并获取更新升级。 在即将到来的Android O 正式发布版本上查看更多信息！！！ 这次升级了什么？开发者预览版4是Android O的发布候选版本，您能够使用它及时为即将发布的官方版本发布完成您的开发和测试。它包括了最终版本的系统行为、bug修复和优化，最终版的APIs(Api Level 26)已经在开发者预览版3上面可以使用了。 今天我们发布了开发者预览版4设备系统镜像，并和正式版的Android 26.0.0支持库。在接下来的几天的路上增加了SDK的更新升级、tools和Android模拟器系统进行。 我们也介绍了一个新版本的Android测试支持库，包括了像Android Test Orchestrator,多进程 Espresso以及更多的新特性。查看详细即将到来。 在Android O上测试您的应用今天开发者预览版4系统镜像给您了一个优秀的方式在接近于最终版本的Android O上面去测试您当前的应用。通过现在的测试，您能够确保您的应用提供您想作为一个用户开始去升级到官方Android O平台的体验。 在Android Beta Program上面去注册一个以支持的设备，并在今天通过OTA云端升级的方式获取更新，从Google play安装您当前的应用程序，并测试用户流。应用程序应该能够运行并且看起来很棒，您应该处理Android O的行为变化配置——在特定，特别要注意后台位置限制、通知渠道和网络的改变、安全以及标示符。 一旦您解决了任意问题，利用当前目标等级发布您的应用更新，以便用户他们在接收到Android O的时候可以使用。 利用Android O特性和APIs提高您的应用用户在运行最新版本的Android,在下载应用程序、消费内容，并进行购买方面通常是最活跃的。他们也是对于在他们喜欢的应用关于支持最新版本Android特性发声最多的。利用Android O,用户期待着像通知渠道、点、快捷方式固定、画中画和自动填充以及其他。这些特性也能随着时间的推移，更多用户升级到Android O，有助于增加与应用的互动。 利用Android的特性提高您的应用程序能够帮助您推动和用户的互动，提供新的互动，给他们更多的控制和安全，并提高性能，功能特性像图标适配、可下载字体和自动大小的文本控件能够简化您的开发和最小化您的APK大小。电池对于用户也是一个最关心的，因此他们将欣赏您的应用程序已经对于后台执行限制进行了优化，和其他O应用程序的重要系统行为的变化。 访问O开发者预览站点去学习关于所有的新特性以及API，并如何编译它们到您的应用程序中。 利用Android Studio 加速您的开发当您已经准备去构建Android O了，我们建议您升级到最新版的Android Studio 3.0,从canary 通道下载可用。除了从性能分析工具去提高应用程序，支持Kotlin程序语言,并且Gradle构建优化，Android Studio3.0利用即时应用、XML字体、可下载字体和图标适配使它开发起来更方便。 我们也建议升级到正式版的Android支持库26.0.0,现在从Google的Maven仓库到最新版本的SDK和工具以及模拟器系统镜像可用，在接下来的这几天可用了。 您能够升级您的项目的编译SDK版本到API 26去针对官方Android O API进行编译。我们也建议的您升级您的应用程序的目标sdk版本到API 26去选择和测试您的应用与Android O具体的行为更改。对于如何设置环境去使用Android O进行编译查看详细的迁移指南。 发布您的应用升级到Google PlayGoogle Play对于应用程序针对编译或者目标API 26是开启的，当您准备好了，您就能够发布您的APK更新升级到您的alpha、beta或者产品通道。 确保您升级的应用运行在Android O上的和您之前的旧版本一样好。我们建议您使用Google Play的beta测试特性去从一个小部分用户获取最早的反馈。然后做一个分阶段的推出。我们期待看到您的应用更新！ 如何获取开发者预览版4如果您还没有准备好，获取开发者预览版4是很简单的！只需要访问android.com/beta并选择您已经注册的手机或者平板。和往常一样，您也能够下载和手动刷入这个升级。Android O 开发者预览版是对于Pixel, Pixel XL, Pixel C, Nexus 5X, Nexus 6P, Nexus Player以及Android模拟器可用。当我们发布官方Android O版本的时候，已注册的设备将会自动更新。 感谢您在整个预览中的所有投入，继续去分享您的反馈和请求,我们很爱它！ 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
        <category>Android O</category>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android O</tag>
        <tag>AndroidO</tag>
        <tag>Developer Preview</tag>
        <tag>Android O Developer Preview</tag>
        <tag>DP4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Things Hackster社区]]></title>
    <url>%2F2017%2F07%2F01%2Fandroid-things-hackster-community%2F</url>
    <content type="text"><![CDATA[原文来自: Android Things Hackster Community Android Things通过提供相同的Android开发工具、一流的Android框架和Google APIs使开发者在移动设备上取得成功，建立连接到嵌入式设备更加容易。自从12月初启动了预览版，社区已经将一些惊人的想法转变成了使用平台上面令人兴奋的原型。 对于使这些制作者和开发者能够使用Android Things去分享和相互学习，我们与Hackster.io合作去创建一个社区，有志向的物联网开发者能够去展示他们的项目并通过其他人的工作获得启发。Hackster.io是一个有20万工程师和开发者的社区，专门去构建硬件连接互联网的项目。他们也通过直播研讨会设计比赛寻求教育和挑战成员。 我们急切的想看到你提出来的项目。更重要的是，我们是很兴奋的去看到你的工作怎么样启发其他开发者用Android Things去创建一些很棒的东西。访问我们Hackster.io社区去看一下其他人已经构建好了的惊人的项目，并在今天加入社区！ Android Things 在线研讨会2017年7月7日上午10点，我们将和Hackster.io合作主持一场名为Android Things引导物联网产品的在线研讨会。在此期间，你将学习到我们如何设计Android Things，去解决尝试构建物联网产品的开发者遇到的许多痛苦的经历。你将也就机会去发送有关平台和生态系统的问题，今天注册加入我们这个激动人心的活动！ 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
        <category>AndroidThings</category>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>Android Things</tag>
        <tag>IoT</tag>
        <tag>hackster</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Things 控制台开发者预览版]]></title>
    <url>%2F2017%2F06%2F29%2Fandroid-things-console-developer-preview%2F</url>
    <content type="text"><![CDATA[原文来自: Android Things Console developer preview 今天我们启动了Android Things 控制台开发者预览版，这个控制台允许开发者去管理在他们的Android Things IoT设备上运行的软件，包括创建工厂镜像，以及升级操作系统和开发者提供的APK。设备需要运行一个来源于Android Things 控制台下载的系统镜像，为了未来接收更新升级，比如即将到来的开发者预览版5。Google为over-the-air(OTA)空中升级提供了所有的基础设施，因此，开发者能够着重于它们具体的应用,不必去建立自己的实现 —— 使得它们的物联网设备会比之前更快更安全的进入市场。 让我们来逛一圈控制台，看看它提供了哪些功能： 产品创建和产品设置开发者首先定义一个产品，包括选择设备依赖的名称以及System-on-Moule(SoM)系统对模块的类型。大多数的开发者当他们在构建物联网设备的时候希望使用Google Play服务，在这里作为可选的功能被配置，OEM分区的大小也被配置，必须有足够巨大去包括任意一个APK未来增长的大小 工厂镜像一部设备需要初始化基本固件，才能从你的控制台上接收正确产品的未来更新升级。对于初学者，你能够简单的使用“创建构建配置”去构建具有你的产品配置的空包的默认工厂镜像。这个工厂镜像然后能够被下载，并刷入到你的设备，你能够通过sideloading一个APK文件开始在它上面开发。 稍候，一旦你有准备你将要部署到你的产品中的所有设备的应用程序，你能够上传捆绑到控制台。这个捆绑是一个ZIP压缩文件包含了一个主要的APK文件，用户空间驱动程序在一个APK文件中作为一个服务，任意一个额外的APK文件通过主要的APK文件被启动。一个启动动画.zip文件也是被支持的，将会在系统启动过程中被展示。上传的捆绑ZIP文件用于生成完整系统映像能够部署到设备。更多有关于捆绑ZIP文件内容的信息在文档中可用。 OTA升级这个选项卡允许开发者去选择:应将哪个系统镜像推送到产品设备的队列。开发者选择了一个，然后“推送到设备”开始这个流程，然后将更新升级安全的推送到了所有的设备上，安装到A/B分区中的一个，并在设备重启的时候进行激活。如果检测到任何故障，这个设备将会自动回滚到上一个已知版本，因此为你更新是一直是可能的。开发者将能够测试新的Android Things发布版，并决定设备是否应该自动更新。 反馈Android Things控制台当前是一个预览版，我们正在做很多功能和自定义的工作。我们鼓励所有的Android Things开发者去检出Android Things控制台并提供反馈。你能够提交错误报告和新功能请求,在Stack Overflow提出任何问题。对于学习更多有关于Android Things控制台,阅读详细文档，我们也鼓励每一个人去加入在Google+上面的Google的物联网开发者交流社区，一个很棒的资源来获得更新和讨论想法。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
        <category>AndroidThings</category>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>Developer Preview</tag>
        <tag>Android Things</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android N 静默安装和卸载]]></title>
    <url>%2F2017%2F06%2F27%2Fandroid-n-installSilent-and-uninstallSilent%2F</url>
    <content type="text"><![CDATA[最近在做静默安装和卸载功能的时候，应用程序放到系统分区(/system/priv-app/)执行pm命令实现静默安装和卸载的方式在7.0上安装、卸载失败。Google 在N上加强了安全权限，对此用本文来记录如何解决7.0上的静默安装和静默卸载。 静默安装复现错误通过7.0之前的安装方法，执行静默安装sdcard下的一个应用，然后安装失败，抛出以下异常log: 1234506-27 11:01:10.483 D/MainActivity: onClick: /sdcard/com.ifeng.news2.apk06-27 11:01:10.489 D/PackageUtils: Enter----&gt;&gt;&gt;installSilent()06-27 11:01:10.489 D/PackageUtils: installSilent—————&gt;&gt;&gt;&gt;/sdcard/com.ifeng.news2.apk06-27 11:01:10.494 D/PackageUtils: command---&gt;&gt;&gt;LD_LIBRARY_PATH=/vendor/lib*:/system/lib* pm install -r /sdcard/com.ifeng.news2.apk06-27 11:01:11.552 E/PackageUtils: installSilent successMsg:, ErrorMsg:Error: java.lang.SecurityException: Permission Denial: runInstallCreate from pm command asks to run as user -1 but is calling from user 0; this requires android.permission.INTERACT_ACROSS_USERS_FULL Error: java.lang.SecurityException: Permission Denial: runInstallCreate from pm command asks to run as user -1 but is calling from user 0; this requires android.permission.INTERACT_ACROSS_USERS_FULL 解决错误参考：Android7.0的静默安装失败问题研究 得知pm安装的命令：Runtime.getRuntime().exec(“pm install -i 包名 –user 0 apkpath”) 一开始，我被这个“包名”坑了: 1234506-27 14:58:44.239 D/MainActivity: onClick: /sdcard/com.ifeng.news2.apk06-27 14:58:44.243 D/PackageUtils: Enter----&gt;&gt;&gt;installSilent()06-27 14:58:44.243 D/PackageUtils: installSilent—————&gt;&gt;&gt;&gt;/sdcard/com.ifeng.news2.apk06-27 14:58:44.252 D/PackageUtils: command---&gt;&gt;&gt;LD_LIBRARY_PATH=/vendor/lib*:/system/lib* pm install -i com.ifeng.news2 --user 0 /sdcard/com.ifeng.news2.apk06-27 14:58:45.458 E/PackageUtils: installSilent successMsg:, ErrorMsg:Error: java.lang.SecurityException: Package com.ifeng.news2 does not belong to 10045 Error: java.lang.SecurityException: Package com.ifeng.news2 does not belong to 10045 那么，我们来看看belong to 10045的包是什么？ 可以看到10045对应的包是我当前的这个测试应用的包名com.wt.testshortcut，而不是指定需要安装apk应用的包名com.ifeng.news2 因此，我们再改之: 12345606-27 16:17:58.843 D/MainActivity: onClick: /sdcard/com.ifeng.news2.apk06-27 16:17:58.846 D/PackageUtils: Enter----&gt;&gt;&gt;installSilent()06-27 16:17:58.846 D/PackageUtils: installSilent—————&gt;&gt;&gt;&gt;/sdcard/com.ifeng.news2.apk06-27 16:17:58.856 D/PackageUtils: command---&gt;&gt;&gt;LD_LIBRARY_PATH=/vendor/lib*:/system/lib* pm install -i com.wt.testshortcut --user 0 /sdcard/com.ifeng.news2.apk06-27 16:18:18.359 E/ApkStatusReceiver: packageName--&gt;com.ifeng.news206-27 16:18:18.359 E/ApkStatusReceiver: onReceive--&gt;android.intent.action.PACKAGE_ADDED 从上面的log可以看出，我自定义的ApkStatusReceiver监听包安装、卸载、替换的广播，收到了一个包名为com.ifeng.news2的应用被添加，也就是我刚刚我们需要静默安装上去的应用，此时手机已确认该应用被成功安装。 最终pm install的命令就是：pm install -i 作为安装者的应用包名 –user 0 需要安装的应用在移动设备上的路径 源码部分 以上截图，可以看到第01515行的pm安装命令: pm install [-lrtsfd] [-i PACKAGE] [–user USER_ID] [PATH] 以上截图，可以看到-i: specify the installer package name (指定安装程序包名称),而不是指定被安装程序包名称，由此也可以推断出上面的安装命令 后记 不要忘记在AndroidManifest.xml添加 “android.permission.INTERACT_ACROSS_USERS_FULL” 权限 如果项目不是在Android源码里面编译的，而是直接在Android Studio上面开发完成，然后push到/system/priv-app/下面的，在执行sdcard下apk的安装，是需要请求外置存储读写权限的，若没有开启，将会抛出异常： 1PackageUtils: installSilent successMsg:, ErrorMsg:Error: failed to write; /sdcard/com.ifeng.news2.apk (Permission denied) Error: failed to write; /sdcard/com.ifeng.news2.apk (Permission denied) 最后，我们来看看在Terminal终端执行pm install的情况： 可以看到，之前在7.0上面执行失败的命令和成功命令都能够在Terminal终端上面执行静默安装成功。 以上就是关于7.0上静默安装的内容，接下来看看静默卸载 ….. 静默卸载复现错误在7.0上使用pm uninstall package 命令，会抛出一下异常log: 1234506-27 20:12:02.631 D/MainActivity: onClick: com.ifeng.news206-27 20:12:02.634 D/PackageUtils: Enter----&gt;&gt;&gt;uninstallSilent()06-27 20:12:02.634 D/PackageUtils: command---&gt;&gt;&gt;LD_LIBRARY_PATH=/vendor/lib*:/system/lib* pm uninstall -k com.ifeng.news206-27 20:12:03.728 D/PackageUtils: commandResult---&gt;&gt;&gt;com.wt.testshortcut.ShellUtils$CommandResult@aac543c06-27 20:12:03.743 E/PackageUtils: uninstallSilent successMsg:, ErrorMsg:Security exception: Permission Denial: runUninstall from pm command asks to run as user -1 but is calling from user 0; this requires android.permission.INTERACT_ACROSS_USERS_FULLjava.lang.SecurityException: Permission Denial: runUninstall from pm command asks to run as user -1 but is calling from user 0; this requires android.permission.INTERACT_ACROSS_USERS_FULL at com.android.server.am.UserController.handleIncomingUser(UserController.java:1267) at com.android.server.am.ActivityManagerService.handleIncomingUser(ActivityManagerService.java:17433) at android.app.ActivityManager.handleIncomingUser(ActivityManager.java:3395) at com.android.server.pm.PackageManagerShellCommand.translateUserId(PackageManagerShellCommand.java:1157) at com.android.server.pm.PackageManagerShellCommand.runUninstall(PackageManagerShellCommand.java:771) at com.android.server.pm.PackageManagerShellCommand.onCommand(PackageManagerShellCommand.java:118) at android.os.ShellCommand.exec(ShellCommand.java:94) at com.android.server.pm.PackageManagerService.onShellCommand(PackageManagerService.java:18747) at android.os.Binder.shellCommand(Binder.java:468) at android.os.Binder.onTransact(Binder.java:367) at android.content.pm.IPackageManager$Stub.onTransact(IPackageManager.java:2387) at com.android.server.pm.PackageManagerService.onTransact(PackageManagerService.java:3197) at android.os.Binder.execTransact(Binder.java:565) at java.lang.reflect.Method.invoke(Native Method) at com.qihoo360.mobilesafe.loadedmgr.b.s.a(SourceFile:287) at com.qihoo360.mobilesafe.loaded.SystemServerJar$FilterInstance.filterExecTransact(SourceFile:463) at com.qihoo360.mobilesafe.loadednative.NativeManager.execTransact(SourceFile:203) 通过以上的log，分析可以看出，出现的错误和上面静默安装的错误相同，都是: ErrorMsg:Security exception: Permission Denial: runUninstall from pm command asks to run as user -1 but is calling from user 0; this requires android.permission.INTERACT_ACROSS_USERS_FULL 解决错误我们现在来看上面静默安装(#源码部分)的第一张图，看到第01522行，命令显示的是:pm uninstall [-k] [–user USER_ID] PACKAGE 确定我们的判断是没有问题的，在7.0上执行pm指令的时候，都需要跟上[–user USER_ID] 注：其中[-k]是代表是否需要保留需要卸载应用包名的数据 因此，我们修改执行命令，同静默安装一样增加–user 0: 1234506-27 20:28:59.893 D/MainActivity: onClick: com.ifeng.news206-27 20:28:59.899 D/PackageUtils: Enter----&gt;&gt;&gt;uninstallSilent()06-27 20:28:59.899 D/PackageUtils: command---&gt;&gt;&gt;LD_LIBRARY_PATH=/vendor/lib*:/system/lib* pm uninstall -k --user 0 com.ifeng.news206-27 20:29:01.006 D/PackageUtils: commandResult---&gt;&gt;&gt;com.wt.testshortcut.ShellUtils$CommandResult@67c71a106-27 20:29:01.019 E/PackageUtils: uninstallSilent successMsg:, ErrorMsg:Exception occurred while dumping:java.lang.NullPointerException at com.android.internal.util.Preconditions.checkNotNull(Preconditions.java:94) at com.android.server.AppOpsService.checkPackage(AppOpsService.java:999) at android.app.AppOpsManager.checkPackage(AppOpsManager.java:1682) at com.android.server.pm.PackageInstallerService.uninstall(PackageInstallerService.java:879) at com.android.server.pm.PackageManagerShellCommand.runUninstall(PackageManagerShellCommand.java:792) at com.android.server.pm.PackageManagerShellCommand.onCommand(PackageManagerShellCommand.java:118) at android.os.ShellCommand.exec(ShellCommand.java:94) at com.android.server.pm.PackageManagerService.onShellCommand(PackageManagerService.java:18747) at android.os.Binder.shellCommand(Binder.java:468) at android.os.Binder.onTransact(Binder.java:367) at android.content.pm.IPackageManager$Stub.onTransact(IPackageManager.java:2387) at com.android.server.pm.PackageManagerService.onTransact(PackageManagerService.java:3197) at android.os.Binder.execTransact(Binder.java:565) at java.lang.reflect.Method.invoke(Native Method) at com.qihoo360.mobilesafe.loadedmgr.b.s.a(SourceFile:287) at com.qihoo360.mobilesafe.loaded.SystemServerJar$FilterInstance.filterExecTransact(SourceFile:463) at com.qihoo360.mobilesafe.loadednative.NativeManager.execTransact(SourceFile:203) 通过以上的log分析出，是在执行到Preconditions.checkNotNull()方法的时候抛出了异常的。 下面我们一起来看看这个流程，逆向倒推： Preconditions.checkNotNull() &lt;=== AppOpsService.checkPackage() &lt;=== AppOpsManager.checkPackage() &lt;=== PackageInstallerService.uninstall() &lt;=== PackageManagerShellCommand.runUninstall() &lt;=== PackageManagerShellCommand.onCommand() 源码分析通过对源码的分析，定位到了PackageInstallerService.uninstall()方法 PackageInstallerService.uninstall()里面调用AppOpsManager.checkPackage()，需要传递callerPackageName的参数，因为它是null了，导致后面CheckNotNull()方法抛出了java.lang.NullPointerException异常 这个callerPackageName，不是我需要去卸载应用的包名，而是我需要去执行卸载操作的应用的包名。分析上面的pm uninstall命令，也并没有明确指定哪儿需要传入我当前应用的包名。 好吧，我也尝试像静默安装一样添加当前包名的参数，使用Terminal终端来执行pm uninstall命令卸载: 结果！命令无效 ….. 再来往前看PackageManagerShellCommand.runUninstall()这个方法 这个方法是运行卸载，取出command命令里面的每一段。其中可以看到option选项只有“-k”、“–user”，“packageName”是我们需要指定卸载掉的包名。再往下看到最底部，有一个uninstall的方法，里面的第二个参数传的是“null”,它正好是我们需要传过去的callerPackageName。 是不是这个地方设置了null,导致了后面为null呢？ 我尝试着给这个null赋值一个固定的包名:com.wt.testshortcut 1234567806-28 12:13:39.306 1393-1717/system_process D/PackageManagerShellCommand: =====&gt;opt: -k06-28 12:13:39.306 1393-1717/system_process D/PackageManagerShellCommand: =====&gt;opt: --user06-28 12:13:39.306 1393-1717/system_process D/PackageManagerShellCommand: =====&gt;packageName: com.ifeng.news206-28 12:13:39.306 1393-1717/system_process D/PackageManagerShellCommand: =====&gt;splitName: null06-28 12:13:39.306 1393-1717/system_process D/PackageInstallerService: ======&gt;packageName: com.ifeng.news206-28 12:13:39.306 1393-1717/system_process D/PackageInstallerService: ======&gt;callerPackageName: com.wt.testshortcut06-28 12:13:39.306 1393-1717/system_process D/PackageInstallerService: ======&gt;callingUid: 1004506-28 12:13:39.306 1393-1717/system_process D/PackageInstallerService: ======&gt;callerPackageName: com.wt.testshortcut 此时的callerPackageName固定为com.wt.testshortcut，结果倒是没有报null的错误了，但是命令还是无效，并且应用还出现了ANR现象 ….. 尝试着给这个null赋值一个固定的包名的做法是不行的 经过同事的讨论分析，只要满足PackageInstallerService.uninstall()中不走进对callingUid的判断，不去AppOpsManager.checkPackage()代码即可。也就是需要callingUid=Process.SHELL_UID（0）或者callingUid=Process.ROOT_UID (2000) 最后的解决方式：代码里在使用pm uninstall [-k] –user 0 PackageName的基础上,并在AndroidMainifest.xml下添加android:shareUerId=”android.uid.shell”，并需要在系统里进行Android源码编译,成功的完成了静默卸载。 后记记得之前在Android M 上也是静默卸载失败，当时替换为下面的这种方式解决了卸载的问题: 123456Intent intent = new Intent();intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);PendingIntent sender = PendingIntent.getActivity(context, 0, intent, 0);PackageInstaller mPackageInstaller = context.getPackageManager().getPackageInstaller();mPackageInstaller.uninstall(pkgName, sender.getIntentSender());// 卸载APKLog.d(TAG, "uninstallApk: " + pkgName); 参考：Android M静默卸载解决方案的探索 但是上面的这种方式在Android N上也没有任何效果了。 针对上面静默卸载的方式，大家有兴趣再分析看看有没有其他的解决办法。 本文为原创文章，转载请注明出处，如有不足，欢迎指正，感谢您的阅读。]]></content>
      <categories>
        <category>Android</category>
        <category>Android N</category>
      </categories>
      <tags>
        <tag>installSilent</tag>
        <tag>uninstallSilent</tag>
        <tag>android N</tag>
        <tag>android 7.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启：AndroidThings之路]]></title>
    <url>%2F2017%2F06%2F24%2Fstart-android-things-way%2F</url>
    <content type="text"><![CDATA[一直以来都知道有AndroidThings这个东西，之前也并未有时间去过多了解。可能是因为它是涉及到物联网相关的知识，个人主要做Android软件开发，对硬件也了解甚少，并且手上也没有开发板。最近兴趣来了，也就入手了一个开发板，毕竟作为Google的物联网系统，Android开发者也是有必要去了解一下AndroidThings 我是入手的树莓派3B(Rpi3) 这里关于AndroidThings相关的入门知识，就不再次阐述了，可以参考以下站点： AndroidThings官网 [谷歌IoT开发技术专家 (GDE) 王玉成 (York Wang)的专题讲解] (http://blog.csdn.net/column/details/14625.html) 这里说一下我在搭建AndroidThings遇到的问题和解决方法,其实也相当于是王玉成(York Wang)在他csdn博客里的那篇搭建文章，评论里面提到的没有写出来的方法。 问题重现参照教程，我在公司搭建环境，开始折腾AndroidThings: usb连接rpi3开发板供电、本地有线网络连接rpi3开发板提供网络访问、HDMI转VGA线连接rpi3开发板提供屏幕显示。 一切准备就绪，屏幕亮了，出现了绿色的android,灰色的things和三个进度点。 内心是相当的激动，仿佛是开启了一个新纪元，这可能只有真正爱技术、爱谷歌、爱折腾的人才能体会的感觉。 然后进入下一个界面，据说在这个界面下面小字显示的是当前的IP地址，然后根据adb connect命令去连接。可是我找了半天，试了很多次还是显示的“Not Connected” 最后那天开箱测试，我还是被逼放弃了… 我猜想，原因很简单：有可能是公司的本地连接需要手动配置IP、默认网关、DNS、子网掩码，导致我目前直接连接上去是没有有效IP访问 解决问题后来，我联系了谷歌GDE专家王玉成 (York Wang)，请教了它，最后解决这个问题。 首先我用笔记本(Windows10)连接wifi，然后用网线连接rpi3开发板和笔记本,将wifi的网络设置为共享，这样就能分配一个IP提供给开发板访问网络，电脑跟开发板组成一个局域网 打开cmd窗口输入arp -a，可以看到当前所有的网络接口 然后输入ipconfig，查看当前的具体ip情况，找到本地连接(以太网)的ip，然后ip对应下的网段就是rpi3开发板的ip 最后我们输入adb connect 去连接设备，连接成功后，回显示成功信息，并输入adb shell 验证，可以看到显示的是rpi3 参照以上的方式我们就成功的完成了adb连接到androidThings开发板,剩下的就和普通开发android一样了,通过Android Studio建立一个androidThings的项目, 成功的运行了第一个AndroidThings项目到开发板 点击一下返回按钮，就回到了桌面(后来我才知道这货居然就是launcher桌面)，可以看到最下面已经能显示具体的网络连接和IP地址了 以上就是个人在入门androidThings时的笔记记录，如需转载，请注明出处，谢谢！]]></content>
      <categories>
        <category>Android</category>
        <category>AndroidThings</category>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>androidThings</tag>
        <tag>rpi3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView安全性的新功能]]></title>
    <url>%2F2017%2F06%2F24%2Fwhats-new-in-webview-security%2F</url>
    <content type="text"><![CDATA[原文来自: What’s new in WebView security 应用程序中对于外部和不信任内容的处理经常是重要的功能之一。新闻阅读器显示头条新闻文章、购物应用展示销售物品的目录。作为处理不信任内容而带来的相关风险是一个攻击者能够损害您的应用程序主要的方式之一，即传递给你错误格式的内容。 大多数的应用程序使用WebView来处理,并且我们在多年以来对Android做了很多改进,以此来保护它和你的应用程序抵抗妥协。Android棒棒糖(5.0),我们开始提供WebView作为一个单独的APK，每6周从Play商店更新升级，因此我们能够快速的获取到用户重要的修复。最新的WebView，我们添加了几个更重要的安全性增强功能。 在Android O中隔离渲染器进程从Android O开始，WebView将会把渲染器从主应用中分离出来运行在一个隔离的进程中，Android通过利用进程之间的隔离被提供，已经可以用于其他应用。 与Chrome类似，WebView现在提供了两个等级的隔离： 渲染器引擎已经拆分到了一个分离的进程，主应用程序隔离了来源于渲染进程的错误或者奔溃。对于一个恶意网站使用渲染器去渲染主应用程序，使它变得更加困难。 对于进一步包含它，渲染器进程是运行在一个隔离进程沙箱里面，将其限制为有限的资源。比如说，渲染器引擎不能够写入到磁盘或者在它自己的网络上会话。正如Chrome在Android上所使用的一样，它也将绑定到相同的seccomp过滤器(seccomp的blogpost即将推出).sesccomp过滤器可以减少系统调用渲染器进程可以访问的次数，也能够限制系统调用允许的参数。 结合安全浏览WebView最新版本结合了Google的安全浏览器保护去检测和警告用户关于有可能危险的站点……。当配置正确时，WebView针对安全浏览器恶意软件和网络钓鱼数据库检测网址，在用户访问一个危险的站点之前显示一个警告消息。在Chrome上，这个有用的信息每个月已经超过了2.5亿次被显示，现在它可以在Android上的WebView里使用了。 启用安全浏览对于在你的应用程序里面所有的WebViews启用安全浏览，在manifest节点下添加： 123456&lt;manifest&gt; &lt;meta-data android:name="android.webkit.WebView.EnableSafeBrowsing" android:value="true" /&gt; . . . &lt;application&gt; . . . &lt;/application&gt;&lt;/manifest&gt; 因为WebView是作为一个单独的APK分发，WebView安全浏览对于运行在Android5.0及其以上的设备今天可以使用了，仅仅只需要在你的manifest添加一行代码，你就能够马上为你的大部分用户升级你的应用，并提高安全性。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
        <category>Android O</category>
        <category>WebView</category>
      </categories>
      <tags>
        <tag>AndroidO</tag>
        <tag>Security</tag>
        <tag>Safe Browsing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android O API是最终的，让您的应用程序准备好！]]></title>
    <url>%2F2017%2F06%2F09%2Fandroid-o-apis-are-final-get-your-apps%2F</url>
    <content type="text"><![CDATA[原文来自: Android O APIs are final, get your apps ready! 在三周以前的Google I/O大会上，我们宣布了Android O开发者预览版2，以及关键的主题Fluid Experiences和Vitals，并强调了我们通过Project Treble实现模块化基础的工作。它也是我们发布第一个优质候选人的重要里程碑。我们在主题演讲和分组会议期间，谈论了大量关于Android有什么新的东西——如果你错过了直播流，这里请务查看完整的会议档案。 今天我们将在最终Android O中推出开发者预览版3，最终的系统镜像，以及Android Studio的更新，以帮助你为今年夏季晚点推出消费者获取准备。观看即将在7月另一个预览更新，将带给你最接近最终版系统的镜像。 如果你已经在Android Beta Program上面注册了你的设备，你将会在段时间内接收到一个开发者预览版3的更新。 确保你的应用兼容到Android O随着消费者在接下来的几个月即将启动，关键的第一步就是确保你当前的应用兼容到了Android O,当Android O到达用户他们的设备是，可以然他们无缝的过渡到一个新的平台。 如果你还没有测试你的应用兼容性，开始使用很简单——仅仅是在Android Beta上面注册一个受支持的设备，通过云端OTA升级到最新版本，然后从Google Play 安装你当前的应用并测试它。 这个应用应该运行，并且看起来很棒，它应该适当的处理Android O的行为变化 —— 特别要注意后台限制、网络、安全和标示符的变化 你将会完成任何必要的更新之后，我们建议您立即将兼容版本的应用发布到Google Play —— 而无需更改应用的平台目标 使用Android O功能和API来增强您的应用程序通过Android O的功能扩展你的应用，能帮助你驱动更多的参与，提供新的互动，给你的用户更多控制和安全，甚至提高你的应用的性能。 通知渠道和点给你更多的方式去为你的用户表达新的内容，带领它们返回到你的应用里面去。当用户是多个任务的时候，画中画能够让你的应用保持在屏幕上，自动填充使他们简单的输入表单数据，并帮助保持他们的数据安全。还可以检出自适应图标、XML字体资源、可下载字体、emoji表情、自动大小TextView、AAudio API和很多其他的.您还需要计划支持后台执行限制以及对于O应用程序重要系统行为的其他重要更改。 访问O 开发者预览版站点去学习有关所有的新功能和APIs，以及如何编译它们到你的应用 ![instagram_dot_500px_bestcolors](/images/instagram_dot_500px_bestcolors .gif) 画中画模式可让用户在多任务时保持使用（上）。通知点让用户在您的应用程序中处于活动状态，并让他们直接跳转应用程序的核心功能（下）。 开始获取开发者预览版3今天的预览版升级包括最终版本的android O平台，最终的API Level 26和上百个bug的修复、优化。你能够从Android Studio里面的SDK管理器下载最终的API26 SDK和从Google的Maven库下载Android支持库26.0.0beta2。 通过这些官方Android O API，您可以一起为您开发和测试应用程序所需的一切。一旦你安装了最终版的SDK，你能够升级你的项目的compileSdkVersion到API 26去针对官方Android O API进行编译。我们也建议你升级你的应用的targetSdkVersion到API26去选择和测试您的应用程序与Android O具体行为更改。有关如何设置使用Android O构建环境的详细信息，请参阅迁移指南。 APIs自从第二个开发者预览版就有改变的，所以如果你有存在的代码使用了Android O预览版的API，看看diff报告，看看你的代码哪儿可能会受到影响。 如果你将使用Android O进行开发，我们建议你升级到最终版本的Android Studio 3.0，现在canary(金丝雀)通道可以使用，除了像提高应用性能的profilling工具、对Kotlin程序语言的支持和Gradle构建优化等伟大的新功能，Android Studio 3.0包括了对即时应用、自适应图标向导，以及对XML字体和可下载字体的支持。 Android Studio 3.0包括使用Android O功能开发的工具，可让您在应用程序中预览XML字体资源。 如果你不计划使用这些新功能，您现在可以选择使用稳定通道的Android Studio 2.3.3开发Android O。请注意，使用自适应图标和可下载字体的工具以及XML字体在Android Studio 2.3.3中不可用。 将您的应用发布到Google Play中的Alpha，Beta或制作频道现在API是最终的，您可以发布APK更新编译，并可选择定位，API 26适用于您在Google Play中的alpha，beta或甚至制作频道。在预览过程中发布O目标应用程序可让您测试现有设备的兼容性，并将更新推送到运行API 26的设备，例如注册Android测试版的用户。 为了确保您更新的应用程序在Android O以及旧版本上运行良好，一个常见的策略是使用Google Play的beta测试功能，从一小群用户（包括开发者预览用户）获取早期反馈，然后在向所有用户发布更新的应用程序时进行分阶段推出。 如何获得预览更新通过Android Beta Program，开发人员和早期采用者将很快在其设备上获得开发者预览版3。如果您尚未注册，只需访问android.com/beta并选择符合条件的Android手机或平板电脑。一如以往，您也可以手动下载并刷入此更新。 O开发者预览版可用于Pixel，Pixel XL，Pixel C，Nexus 5X，Nexus 6P和Nexus Player。 非常感谢您的所有反馈。我们今年夏天将在消费者发布工作中继续分享反馈或请求。我们期待在Android O上看到您的应用程序！]]></content>
      <categories>
        <category>Android</category>
        <category>Android O</category>
        <category>Android Studio</category>
        <category>Google I/O 2017</category>
      </categories>
      <tags>
        <tag>Android O</tag>
        <tag>Develop</tag>
        <tag>Featured</tag>
        <tag>android o apis</tag>
        <tag>AndroidO</tag>
        <tag>API</tag>
        <tag>Developer Preview</tag>
        <tag>Project Treble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 宣布支持Kotlin]]></title>
    <url>%2F2017%2F05%2F19%2Fandroid-announces-support-for-kotlin%2F</url>
    <content type="text"><![CDATA[原文来自: Android Announces Support for Kotlin 今天，Android团队很高兴地宣布，我们正式增加对Kotlin编程语言的支持。Kotlin是一种精湛的设计，成熟的语言，我们相信会使Android开发更快更有趣。它已被几个主要开发商采用 —— Expedia，Flipboard，Pinterest，Square等 —— 为他们的生产应用程序。Kotlin也用Java编程语言表现出色;两种语言之间的毫不费力的互操作是在Kotlin的呼吁中占很大一部分。 Kotlin插件现在与Android Studio 3.0捆绑在一起，可立即下载。Kotlin是由JetBrains开发的,和创造IntelliJ是同一些人。所以对于IDE支持科Kotlin来说，并不奇怪。 除了IDE支持之外，我们还宣布与JetBrains进行合作，将Kotlin推向非盈利基础。 （Kotlin已经在Apache2下开源了） 对Kotlin说”你好”任何使用Java编程语言的人都很熟悉Kotlin。 12345package helloWorldfun main(args: Array) &#123; println("Hello World!")&#125; 乍一看，你会看到舒适的元素，如大括号，类，包，功能和方法。你会发现，虽然Kotlin是基于熟悉的概念，在这些模型上，它是独一无二的现代化，优雅和务实的。特别地是，Kotlin具有极高的表现力，最小的句法摩擦你的想法和你必须输入什么才能表达这些想法之间。如果在编写代码的时候，你问自己的问题，那就是为什么我必须…？你会很高兴地得知，在Kotlin，许多这些问题的答案是“你不要！” 例如，也许你已经问为什么要在实现一个简单的类时，要输入一堆getter和setter的样板，以及重写equals（）、hashCode（）和toString（）。以下是Java编程语言的典型示例（为了简洁起见，用微小的字体）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Customer &#123; private String name; private String email; private String company; public Customer(String name) &#123; this(name, "", ""); &#125; public Customer(String name, String email) &#123; this(name, email, ""); &#125; public Customer(String name, String email, String company) &#123; this.name = name; this.email = email; this.company = company; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getCompany() &#123; return company; &#125; public void setCompany(String company) &#123; this.company = company; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Customer customer = (Customer) o; if (name != null ? !name.equals(customer.name) : customer.name != null) return false; if (email != null ? !email.equals(customer.email) : customer.email != null) return false; return company != null ? company.equals(customer.company) : customer.company == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + (email != null ? email.hashCode() : 0); result = 31 * result + (company != null ? company.hashCode() : 0); return result; &#125; @Override public String toString() &#123; return "Customer&#123;" + "name='" + name + '\'' + ", email='" + email + '\'' + ", company='" + company + '\'' + '&#125;'; &#125;&#125; 在Kotlin中，你没必要键入任何一个，这一行相当于上面的整个类。 12data class Customer(var name: String, var email: String = "", var company: String = "") 历史与参考Kotlin已经有了一段时间了，它在2011年被公布，第一个预览于2012年发布。Kotlin 1.0于2016年发布，从1.0开始前进，JetBrains致力于保持向前兼容性稳定的功能。 你可以在https://kotlinlang.org/找到优秀的培训材料和参考资料,Android团队发现Kotlin Koans教程作为开始编写Kotlin片段的一种快速方式是特别有用的。这些教程的范围从简单到崇高，因为材料从基础到更复杂的Kotlin成语。 为什么选择Kotlin？为什么Android团队决定支持Kotlin？最重要的是，因为我们认为Kotlin是一种伟大的语言，将使Android应用程序更轻松，更愉快。Kotlin也是现有Android生态系统的绝佳搭档，它与Java编程语言100％兼容。您可以根据需要将Kotlin添加到现有的代码库中，并在同一个项目中自由混合两种语言。从使用Java编程语言Just Works™编写的代码调用Kotlin代码。通过一些应用自动翻译的惯例，通过其他方向通常也不需要开发人员的努力(例如，为您创建的属性getter和setter等)。在几个Kotlin注释的帮助下，您还可以自定义如何执行翻译。 最后，许多开发人员告诉我们，他们喜欢Kotlin语言。 （我们许多Android团队的开发人员也一直在说类似的东西。）已经有一个热衷于Android的Kotlin开发人员社区，Android团队在公开活动中常常对Kotlin提出疑问。Android社区已经发言了，我们听了。 一次快速旅程为了帮助您了解Kotlin周围的所有兴奋之处，这里是一次快速的、非常不完整的、特别吸引人的方面的Kotlin旅程： 可空Kotlin编译器强制可以显式声明可以保存空值的变量 —— 因此在运行时不再有NullPointerExceptions！ 12345678910var neverNull: String = "something"var mightBeNull: String? = null // "?" indicates this can be nullif (neverNull.length &gt; 0) &#123; // This is OK …&#125;if (mightBeNull.length &gt; 0) &#123; // Compiler catches this error for you …&#125; 命名参数和默认参数我们都看到有太多参数的方法来跟踪。例如： 1234567891011fun orderPizza(size: Size, pepperoni: Boolean, mushrooms: Boolean, ham: Boolean, pineapple: Boolean, pickles: Boolean, sausage: Boolean, peppers: Boolean, onion: Boolean)&#123; ...&#125;// Wait… did I just order pickles on my pizza?// Why do we even have that option?orderPizza(Size.LARGE, true, false, false, false, true, false, true, false) 将其与使用命名参数和默认参数的类似方案进行比较: 1234567891011121314fun orderPizza(size: Size, pepperoni: Boolean = false, mushrooms: Boolean = false, ham: Boolean = false, pineapple: Boolean = false, pickles: Boolean = false, sausage: Boolean = false, peppers: Boolean = false, onion: Boolean = false)&#123; ...&#125;orderPizza(Size.LARGE, ham = true, mushrooms = true) 除了帮助避免不幸的比萨结果之外，这更容易阅读。它还减少了您需要编写的重载功能的变体数量。 当声明Kotlin具有允许匹配任意表达式的switch语句的变体。 12345678// Please don't put this in your app!when &#123; password.equals("password") -&gt; println("Insecure password!") password.length &lt; 4 -&gt; println("Too short!") else -&gt; &#123; println("Secure password!") &#125;&#125; 智能铸造在你刚刚测试它是该类的一个实例之后，为什么你必须在一个类上投下一些东西？在kotlin，你不必这样做了。 1234567if (obj is String) &#123; // Compiler casts obj to a String for you. // (Would work with &amp;&amp; instead of nested ifs too.) if (obj.length &gt; 0) &#123; … &#125;&#125; 这也概括为when语句： 12345678// Assume reasonable implementations of Cat and Dogwhen (obj) &#123; is Cat -&gt; obj.meow(...) is Dog -&gt; obj.woof(...) else -&gt; &#123; … &#125;&#125; 扩展功能Kotlin让您基本上将新方法重新定位到现有的类型上,如果像许多人一样，希望String类有一个toPigLatin方法。您现在可以自行添加它，而无需创建一个新的帮助器类来包装String或者在语言委员会中服务的麻烦： 12345678910111213// The "String." prefix indicates that this method should// extend the existing String classfun String.toPigLatin() : String &#123; ...&#125;val plainOldString : String = "some text"// Can now call toPigLatin as if were a method on Stringprintln(plainOldString.toPigLatin())// Or:println("some text".toPigLatin()) 解构定义我们已经看到定义一个简单的数据类是多么容易： 12data class Order(val itemCode: String, val quantity: Int, val price: Float) 使用这些类之一作为返回类型的函数非常接近于支持多个返回值： 1234fun getOrder(...): Order &#123; ... return Order(itemCode, quantity, price);&#125; 要得到所有的方法，您可以使用解构声明语法。以下语句接受Order对象，提取其三个属性，然后将它们分配给三个变量:what, howMany 和 howMuch 。 —— 所有礼貌的Kotlin编译器，这也为您推荐正确的类型。 1val (what, howMany, howMuch) = getOrder(...) LambdasKotin对于lambdas具有非常简洁的语法，可以很容易地表达强大的功能编程范例。这是一个简单的例子，它使用lambda来测试集合中的所有内容都是String： 12fun allStrings(collection: Collection)= collection.all &#123; it is String &#125; 创建使用类似JSON的语法的构建器的能力也恰好是语法上有效的Kotlin。这个例子在这里进行了扩展的讨论： 123456789101112131415161718fun generatePage(withEmphasis : Boolean) &#123; val result = html &#123; head &#123; title &#123; +"Kotlin Builders" &#125; &#125; body &#123; h1 &#123; +"Kotlin Builders" &#125; p &#123; +"This is " if (withEmphasis) b &#123; +"really " &#125; +"interesting" a(href = "https://goo.gl/rHwJio") &#123; +"More here" &#125; &#125; &#125; &#125; println(result)&#125; 这里有几件有趣的事情。 首先，这显示了Kotlin的功能语法如何表达：在这个例子中，“html”，“head”，“body”等都只是用Kotlin编写的函数，而后面是大括号的东西是功能参数（这个 片段使用具有与HTML标签匹配的名称的函数来构建网页的表示，但当然，您可以使用此模式构建任何所需的任何名称的复杂数据结构。）第二个有趣的是“withEmphasis”条件。 这可能看起来像我们正在混合代码（if（withEmphasis）…）与数据（所有的HTML-esque标签），但是这里的“数据”实际上只是更多的代码，因为它只是真正的代码，这可以让你建立 复杂的数据结构使用声明式语法，同时还具有对Kotlin语言的全部功能的内联访问。 开始获取如果您想开始使用Kotlin，您可以立即在线开始使用代码。只需打绿色三角形即可编译并运行。 要在您的应用程序中尝试Kotlin，请按照下列步骤操作： 1、下载Android Studio 3.0 2、打开一个已存在的”.java”文件 3、调用”Code &gt; Convert Java File to Kotlin File” 然后，IDE将引导您将Kotlin依赖项添加到项目中，然后将代码转换为功能相当的Kotlin代码。（如果适用于更为惯用的Kotlin，IDE将会将所有的调用站点提供给转换的类，例如当静态方法被移动到配对对象时）。 您还可以在developer.android.com上找到更多有关如何开始使用Kotlin的信息。 以上内容根据原文使用Google Translate工具翻译而成]]></content>
      <categories>
        <category>Android</category>
        <category>Android O</category>
        <category>Android Studio</category>
        <category>Google I/O 2017</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio 3.0</tag>
        <tag>Develop</tag>
        <tag>Featured</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3.0 Canary 1]]></title>
    <url>%2F2017%2F05%2F19%2Fandroid-studio-3-0-canary1%2F</url>
    <content type="text"><![CDATA[原文来自: Android Studio 3.0 Canary 1 正巧赶上Google I / O 2017，我们提供了Android Studio 3.0 抢先看—— 今天可以在我们的Canary发行频道上下载。Android Studio是我们的官方IDE,专为Android设计，我们不断增加投资,Android Studio中的功能集中在加速您的应用程序开发流程，并提供为Android平台构建的最新工具。 为了加速您的开发流程，Android Studio 3.0包括三个主要功能： 一套新的应用程序性能分析工具,可快速诊断性能问题 支持Kotlin编程语言 为大型应用程序项目增加Gradle构建速度 Android Studio 3.0还与Android平台开发紧密集成，具有以下附加功能： 支持即时应用开发 在Android O模拟器系统图像中包含Google Play商店 为Android O开发新的向导 总的来说，这款Android Studio 3.0的第一款Canary版本具有20多种新功能。 作为Android Studio 2.4 Canaries的一部分，我们一直在静静地迭代这些功能。今天，我们在认识到我们添加了许多重要功能之后，将版本重新编号为Android Studio 3.0，我们必须在Android Gradle Plugin中引入一个罕见的变化，以提高可扩展性和构建时间。如果您要定位Android O，请创建即时应用程序，开始使用Kotlin语言开发，或使用最新的Android应用程序性能工具来提高应用程序质量，然后您应该今天下载Android Studio 3.0 Canary 1。 [Android DevByte - What’s New in Android Studio 3.0 Canary 1](https://youtu.be/rHiA66zUv8c) 请查看下面列出的组织成关键的开发人员流程，以了解Android Studio 3.0的第一个经典版本的新功能的详细信息。 开发Kotlin程序语言根据受欢迎的要求，Android Studio 3.0现在包括对Kotlin的支持。通过这种新的语言支持，您可以将现有Android应用程序代码旁边的Kotlin代码无缝添加，并可以访问Android Studio中发现的所有优秀开发工具。您可以选择使用Code → Convert Java File to Kotlin File内置的转换工具将Kotlin添加到您的项目中，或者您选择使用新建项目向导创建启用Kotlin的项目。在Android和Android Studio中更多地关注Kotlin语言支持。 Kotlin Language Conversion in Android Studio Java 8语言功能我们正在不断发展对Java 8语言特性和API的支持。随着杰克工具链的最新淘汰和迁移到基于javac的工具链，您可以访问Android Studio中使用Java 8语言功能的项目的即时运行功能。要更新项目以支持新的Java 8语言工具链，只需在“项目结构”对话框中将“源”和“目标”兼容级别更新为1.8。学到更多。 Update Project Structure Dialogue for Java 8 Language 布局编辑器使用这个Android Studio版本，您会发现布局编辑器的其他增强功能。我们已经使用更好的拖放视图插入更新了组件树，与ConstraintLayout的更新配合，布局编辑器还支持创建视图障碍，创建组，并增强链创建。学到更多。 Layout Editor Component Tree & Warning Panel 自适应图标向导Android O引入了自适应启动器图标，可以在不同的Android设备上显示不同的形状。新的自适应启动器图标向导创建新的和遗留的启动器图标资源，并提供您的自适应图标如何在不同的启动器屏幕图标蒙版上的预览。通过右键单击项目中的/ res文件夹创建一个新的资源，然后导航到→ New → Image Asset → Launcher Icons (Adaptive and Legacy),学习更多 Adaptive Icon Wizard XML字体和可下载的字体在Android Studio中使用XML字体预览和字体选择工具，现在可以将自定义字体添加到应用程序中（在定位Android O时可用）。您还可以为您的应用创建可下载的字体资源。使用可下载的字体，您可以在应用程序中使用自定义字体，同时避免将字体资源捆绑到您的APK中。 要使用可下载的字体，请确保您的设备或模拟器正在运行Google Play Services v11.2.63或更高版本。 学习更多。 Downloadable Fonts Resource Picker XML Fonts Preview Android Things的支持用Android Studio 3.0，您可以在“新建项目”向导和“新建模块”向导中，使用新的一组模板开始开发Android Things。Android Things可让您将Android开发知识扩展到物联网（IoT）设备类别。学习更多 Android Things New Module Wizard IntelliJ平台更新Android Studio 3.0 Canary 1包括IntelliJ 2017.1版本，其具有Java 8语言重构，参数提示，语义突出，可拖动断点，增强版本控制搜索等功能。学习更多 构建即时应用支持使用Android Studio 3.0，您可以在项目中创建Instant Apps。Instant Apps是您的用户可以立即运行而不安装的轻量级Android应用。为了支持这一点，Android Studio引入了两种新的模块类型：即时应用和功能,结合新的“模块化”重构动作和App Links助手,Android Studio可以帮助您将应用程序扩展到即时应用程序,要使用，您可以使用新建模块向导或右键单击一个类并导航到Refactor → Modularize,学习更多 Instant App Module Wizard 建立速度改进我们正在继续投资，使建造速度更快。对于此版本，我们专注于提高具有多个模块的项目的速度。为了实现这些速度改进并支持未来的增强，我们已经对Android Studio使用的Android Gradle插件进行了破坏的API更改，如果您依赖于以前插件提供的API，则应验证与新插件的兼容性并迁移适用的API。要测试，请更新您的build.gradle文件中的插件版本。学习更多 build.gradle 123dependencies &#123; classpath 'com.android.tools.build:gradle:3.0.0-alpha1'&#125; Google’s Maven 资源库此外，根据受欢迎的要求，我们现在在全新的Maven存储库中分发Android SDK Manager外的Android支持库maven依赖项。对于使用持续集成（CI）系统开发的用户，这将使Maven依赖关系管理变得更加容易。与最新的命令行SDK Manager工具和Gradle结合使用，使用Google的Maven存储库更易于管理CI构建。要使用新的Maven位置，请将以下URL添加到应用程序模块的build.gradle文件中。学习更多 build.gradle 12345repositories &#123; maven &#123; url "https://maven.google.com" &#125;&#125; 测试 &amp; 调试Google Play系统镜像随着对Android O Beta版本的更新，我们更新了Android Emulator O系统映像以包含Google Play商店。在Google Play商店中捆绑，您可以使用Google Play对应用进行端到端的测试，并提供了一种方便的方法来在Android虚拟设备（AVD）中保持最新的Google Play服务。就像Google Play服务在物理设备上进行更新一样，您可以在AVD上触发相同的更新。 Google Play Store in Android Emulator Update Google Play Services in Android Emulator 确保应用程序的安全性和一致的体验，包含Google Play商店的模拟器系统映像都使用发行键签名。这意味着您将无法获得提升的权限。如果您需要提升的权限（root）来帮助应用程序进行故障排除，则可以使用不包括Google应用或服务的Android开源项目（AOSP）仿真器系统映像。要开始使用，请确保使用Android Emulator v26.1 +，最新的系统映像API 24+，然后在设备定义旁边创建一个带有Google Play图标的新AVD。学习更多 Android Virtual Device Manager with Google Play Store Support Android模拟器中的OpenGL ES 3.0支持作为我们持续投资的一部分，使您的开发经验更快，Android模拟器的最新版本具有OpenGL ES 3.0对Android O系统映像的支持，同时显着改进了OpenGL ES 2.0图形性能，适用于较旧的仿真器系统映像。所有操作系统上的大多数现代显卡支持OpenGL ES 2.0加速。要使用OpenGL ES 3.0与Android模拟器，您的开发机器需要一个支持OpenGL 3.2或更高版本的Microsoft®Windows®或Linux（随着AppleMacOS®支持将来推出）的主机GPU显卡。学习更多 OpenGL ES 3.0 in Android Emulator Android模拟器中的应用程序Bug Reporter为了帮助记录您的应用程序中的错误，我们添加了一种更简单的方法来生成错误报告，其中包含所有必要的配置设置和空间来捕获您的重复步骤。此外，如果您想与Android团队分享一个特定的模拟器错误，我们还添加了一个链接，以便在Android问题跟踪器上快速生成错误。要使用此功能，请导航到Emulator Tool Bar → Extended Controls → Help → Emulator Help → File a Bug。 App Bug Reporting in Android Emulator Android中的代理支持*对于需要使用HTTP代理访问Internet的用户，我们添加了一个用户界面来管理仿真器使用的代理设置。默认情况下，Android模拟器现在将使用Android Studio的设置，但您可以覆盖网络设置的这些设置。配置导航到Extended Controls → Settings → Proxy. Android Emulator Proxy Settings Android模拟器中的Android Wear旋转控件Android模拟器现在支持Android Wear 2.0仿真器系统映像的旋转控制。现在，您可以更轻松地测试目标Android Wear设备（包括旋转输入滚动）的应用。要启用，请创建一个针对Android Wear的模拟器AVD，“旋转输入”面板应显示在扩展控件下。学习更多 Rotary input in Android Emulator APK调试对于那些只想在Android Studio中构建您的项目即可调试APK的用户，Android Studio 3.0版本现在可以调试任意的APK。这在功能上对于在另一个开发环境中开发Android C ++代码,但对Android Studio上下文中的APK进行调试和分析的人尤其有用。只要你有一个可调试版本的APK，你可以使用新的APK调试功能来分析，配置和调试APK。此外，如果您可以访问APK的来源，您可以将源连接到APK调试流程，以实现更高保真的调试过程。通过从Android Studio欢迎屏幕或File → Profile or debug APK中简单地选择Profile or debug APK开始。学习更多 Profile or Debug an APK APK Debugging 布局检查员您会发现，Layout Inspector在Android Studio 3.0中有一些额外的增强功能，可以更轻松地调试应用程序布局中的问题。一些增强功能包括将属性更好地分组成常见类别，以及查看树和属性面板中的搜索功能。当应用程序正在运行时，通过Tools → Android → Layout Inspector.学习更多 Layout Inspector 设备文件资源管理器通过流行的需求从DDMS移植到Android Studio，新的设备文件资源管理器允许您查看Android设备或模拟器的文件和目录结构。在测试您的应用程序时，您现在可以在Android Studio中直接快速预览和修改应用数据文件。 Device File Explorer 优化Android ProfilerAndroid Studio 3.0包含一套全新的工具，帮助您调试应用程序中的性能问题。我们完全重写了前一组Android监视器工具，并将其替换为Android Profiler。一旦你将应用程序部署到正在运行的设备或模拟器后，单击“Android Profiler”选项卡，现在可以访问您的应用程序的CPU，内存和网络活动的实时统一视图。每个性能事件都映射到UI事件时间轴，突出显示触摸事件，按键和活动更改，以便您在某个事件发生的时间和原因方面有更多的上下文。点击每个时间轴，挖掘您的应用程序的每个性能方面。学习更多 Android Profiler - Combined timeline view. CPU Profiler不必要的CPU处理和负载峰值是应用程序性能差的症状。使用CPU Profiler，您可以通过触发采样或仪表化的CPU跟踪来分析应用程序的CPU线程使用情况。此时，您可以使用CPU Profiler中内置的各种数据视图和过滤器来解决CPU性能问题。学习更多 CPU Profiler Memory Profiler无效率地使用内存可能导致许多设备问题，从janky UI到低内存事件。内存分析器将先前的堆查看器和分配跟踪器的功能集成在一个丰富的界面中，以帮助调试应用程序中的内存使用问题。您可以通过分析内存分配，堆转储等来诊断一系列内存问题。学习更多 Memory Profiler Network Profiler优化您的应用程序的前台和后台网络使用可以导致更高效的应用程序和更低的应用程序数据使用。网络分析器允许您监视应用程序的网络活动，检查每个网络请求的有效负载，并链接到生成网络请求的源代码行。目前，网络分析器与HttpURLConnection，OkHttp和Volley网络库协同工作。网络分析器是通过在“运行配置”框中的“分析”选项卡中选择启用高级分析功能，可以在Android O设备和仿真器之前启用的高级分析功能。 除了启用网络请求和有效载荷分析外，此复选框还可以启用顶层的事件收集，内存对象计数和内存垃圾回收。对于基于Android O的设备和模拟器，只需部署您的应用程序。学习更多 Network Profiler Network Profiler Setup for Pre- Android O Devices APK分析仪改进在Android Studio 3.0中，我们为APK分析工具添加了一些其他增强功能，可帮助您进一步优化APK的大小。通过此功能更新，您现在可以分析Instant App zip文件和AAR，并查看类和方法的dex字节码。还可以生成Proguard配置规则，并在dex查看器中加载Proguard映射文件。学习更多 APK Analyzer 总结要介绍一下，Android Studio 3.0 Canary 1包括这些新的主要功能： 开发 Kotlin语言 Java 8语言 布局编辑器改进 自适应图标向导 XML字体和可下载的字体 Android Things Intellij平台更新2017.1 构建 即时应用支持 建立速度改进 Google的Maven Repo更改 测试 &amp; 调试 模拟器Google Play系统映像 模拟器OpenGL ES 3.0支持 模拟器代理支持 应用程序Bug Reporter Android Wear Rotatory APK调试 布局检查员 设备文件资源管理器 优化 CPU Profiler Memory Profiler Network Profiler APK分析仪改进 查看发行说明了解更多详情。 开始获取下载如果您使用的是以前版本的Android Studio，则可以和稳定版本一起安装Android Studio 3.0 Canary 1。你可以从官方的Android Studio Preview下载页面下载这个升级。正如本博客中提到的，有一些突破性的Gradle插件API更改来支持IDE中的新功能。因此，您还应该将当前项目中的Android Gradle插件版本更新为3.0.0-alpha1，以测试和验证您的应用程序项目设置。 我们感谢您喜欢的任何反馈意见、您希望看到的问题或功能。如果您发现错误或问题，请随时提出问题。在我们的Google+专页或Twitter上与我们联系——Android Studio开发小组。]]></content>
      <categories>
        <category>Android</category>
        <category>Android O</category>
        <category>Android Studio</category>
        <category>Google I/O 2017</category>
      </categories>
      <tags>
        <tag>Android Studio 3.0</tag>
        <tag>Develop</tag>
        <tag>Featured</tag>
        <tag>Canary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的新功能：Android O开发者预览版2以及更多]]></title>
    <url>%2F2017%2F05%2F19%2Fwhats-new-in-android-o-developer%2F</url>
    <content type="text"><![CDATA[原文来自: What’s New in Android: O Developer Preview 2 &amp; More 全球拥有着数十亿部Android设备，Android已经超出了我们最疯狂的期望。今天我们在Google I/O上展示出了一系列推动着Android向前的方式，通过O的推出、新工具为帮助开发者去创建更多高性能的应用，以及被我们称之为Android Go的早期预览的项目 —— 我们正在为入门级设备构建全新的体验 Android O中的流畅体验今天你能够在移动设备上面做什么是非常不可思议的，在我们的口袋里依靠它们作为作为电脑是多么简单。在Android O,我们专注于创建流畅的体验，让Android更加强大、易于使用。今天我们突出强调了一些： 画中画：让用户同时管理两个任务。无论是当你在检查你的日历的时候与你的朋友进行视频通话，还是当你在看一部特殊的烹饪技术视频时阅读一篇新的食谱。我们设计了PIP，可在任何尺寸的屏幕上提供无缝多任务，并且应用程序易于支持它。 通知点：扩大通知范围，开发人员在其应用程序中展现活动的新方式，推动参与。建立在我们独特和高度评价的通知系统上，点操作对大多数应用程序零影响 —— 我们甚至从您的图标中提取点的颜色。 通过Google自动填充：通过将Chrome的自动填充功能添加到Android，可以简化设置新设备并同步密码。一旦用户选择加入，对于大多数应用程序而言自动填充工作开箱即用。开发者能够通过提供有关预期数据类型的提示或在自定义视图中添加支持，优化他们的自动填充应用程序。 Android TV的新主屏幕：使用户可以轻松查找，预览和观看应用提供的内容。应用程序可以发布一个或多个频道，用户可以控制主屏幕上显示的频道。您可以开始使用新的TvProvider支持库API创建频道。 智能文本选择：在Android O中，我们在设备上应用了机器学习去复制/粘贴，去让Android识别实体，像地址、URL域名、电话号码以及电子邮箱地址。通过选择整个实体并显示正确的应用程序，以根据实体的类型执行操作，这个使复制/粘贴体验更佳。 Tensorflow 精简版：随着Android继续利用机器学习去提高用户的体验，我们希望我们的开发者合作伙伴能够做到这一点。今天我们分享了一下TensorFlow 精简版的早期看法，一个基于Tensorflow的项目即将到来。Google开源了机器学习库，Tensorflow精简版是用于嵌入式用例的快速和轻便而被特殊设计。由于许多设备上的场景需要实时性能，因此我们还在研究一种新的神经网络API，TensorFlow可以利用它来加速计算。我们计划在今年晚些时候向开发人员提供这两项维护更新，所以请继续关注！ (Android O: Picture-in-picture) ![instagram_dot_500px_bestcolors](/images/instagram_dot_500px_bestcolors .gif) (Android O: Notification dots) 在Android中使用Vitals我们认为Android的基础是至关重要的，所以我们投资Android Vitals,一个专注于优化电池寿命、启动时间，图形渲染时间和稳定性的项目，今天我们展示了迄今为止所做的一些工作，并引入了新的工具来帮助开发人员了解其应用程序中的电源，性能和可靠性问题： 系统优化：在Android O中，我们在整个系统中做了大量工作，使应用程序运行更快更流畅。例如，我们在运行时进行了广泛的更改 —— 包括新的优化，如并发压缩垃圾收集，代码位置等。 后台限制：到目前为止，应用程序在后台无意中会过度使用资源是相当容易的，这可能会对系统的性能产生不利影响。所以在O，我们介绍了新的限制后台位置和Wi-Fi扫描,以及应用程序在后台运行的方式发生变化,这些边界防止过度使用 —— 它们将延长电池寿命并释放内存。 Play Console中的新的Android Vitals仪表板：：今天我们推出了6款Play Console仪表板，帮助您准确定位应用程序中的常见问题 —— 崩溃率过高、ANR速率、冻结帧、渲染缓慢、唤醒过多和唤醒锁，包括受影响的用户数量。指导解决问题的最佳方式，您可以访问Play Console，查看您的应用的数据，然后了解如何解决任何问题。 Android GoAndroid的任务之一是将计算机带给每个人,我们很高兴看到更多的用户第一次上线，因为入门级智能手机的价格下降,我们希望帮助制造商继续提供低成本的设备，为这些用户提供一个很好的体验。今天，我们深入探讨了一种新的体验，我们专门为具有1GB或更少内存的Android设备构建 —— 在内部我们称之为“Android Go”，它围绕着三件事设计： 操作系统 ： 我们正在优化Android O，以便在入门级设备上顺利，高效地运行 应用 ： 我们还在设计Google应用程序，以减少内存，存储空间和移动数据，包括YouTube Go，Chrome和Gboard等应用程序。 Play ： 在入门级设备上，Play商店将通过突出显示为这些设备专门设计的应用来促进更好的用户体验 —— 例如使用较少内存，存储空间和移动数据的应用程序 —— 同时仍然允许用户访问整个应用程序目录。 Android Go体验将于2018年推出，适用于拥有1GB或更少内存的Android设备。我们建议您尽快为这些设备准备好应用 —— 构建Billions，了解提供有用的离线状态的重要性，减少APK大小，并尽量减少电池和内存使用。 O开发者预览版2，现在公开测试今天发布的O Developer Preview 2是我们第一个测试版本的候选，可以在您的主要手机或平板电脑上进行测试，我们邀请那些想要尝试Android O测试版的用户现在注册到android.com/beta —— 在Nexus 5X，6P和Player以及Pixel，Pixel XL或Pixel C设备上预览Android O是一种非常方便的方式。 随着更多用户开始通过Android测试版程序在设备上获取Android O,在是时候测试你的应用程序的兼容性，解决任何问题,并尽快发布更新。有关步骤和推荐的时间表，请参阅迁移指南。 今天晚些时候，您可以下载更新的Android O开发工具，包括Canary通道的Android Studio，SDK和工具，Android O系统映像和模拟器。随着这些，您将能够从我们的新Maven repo下载支持库26.0.0测试版和其他库。从SDK Manager更改Maven意味着您的构建配置略有变化,但是您可以更灵活地将库更新与CI系统进行集成。 当您准备开始使用Android O开发应用程序时，有关您可以在应用程序中使用的所有功能的详细信息，请访问O 开发者预览网站，包括通知渠道和点，画中画，自动填充等。 自第一个开发者预览后，API已经发生变化，因此，请查看diff报告，以查看代码可能受到的影响。 感谢您向我们提供的反馈意见。请继续下去。请继续关注Android O功能，API，问题或请求，有关在哪里报告反馈的详细信息，请参阅反馈和错误页面。]]></content>
      <categories>
        <category>Android</category>
        <category>Android O</category>
        <category>Google I/O 2017</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Go</tag>
        <tag>Android O</tag>
        <tag>Develop</tag>
        <tag>Featured</tag>
        <tag>Developer Preview</tag>
        <tag>Google I/O</tag>
        <tag>Android TV</tag>
        <tag>Dashboard</tag>
        <tag>notifications</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android O中对于短信验证无需请求权限]]></title>
    <url>%2F2017%2F05%2F15%2Fandroid-O-does-not-require-permission-for-SMS-verification%2F</url>
    <content type="text"><![CDATA[Android O 针对SMS（短信）认证的方式进行了改进，引入了专门的API。应用程序可以使用它们来检索应用程序通过SMS（短信）发出去的验证码，因此，Android O中的应用程序请求SMS将不再需要权限 定义短信验证也被称为”短信认证“，是为了验证用户的合法性。现在国内很多应用都使用了手机验证码作为注册、登录的首选方式，其次就是使用邮箱和第三方的方式。 原理当一部Android设备输入了手机号码，发出了请求验证码操作，后台服务器就会向客户端发送包含密码字串的短信，然后客户端输入该字串，发送到服务器进行验证。如果成功通过了服务器的验证，客户端就成功的完成了短信验证，进入到指定的功能界面。 现状客户端接收到服务器下发的短信，主要有两种可能的解决方案来管理短信 方式1: 用户收到了服务器下发到客户端的验证码短信，收到后手动输入或复制粘贴到正确的位置 方式2: 开发者通过代码让程序读取用户最近收到的短信，并找到该应用程序的相应消息，自动填充到正确的位置 缺点 从Android M开始需要额外的添加android.permission.READ_SMS权限请求 应用程序必须搜索相应的短信 一旦授予了读取短信的权限，应用程序就能控制整个短信的阅读权限，有可能追踪到用户的敏感性短信内容 其他应用程序也能够获取到开发者自己应用的短信内容 用户或许不是真实的 改进Android O 在SmsManager中引入了新的API——createAppSpecificSmsToken() 参数： intent (PendingIntent)返回值： String类型 (令牌包含在短信中。 令牌将是11个字符长) 1、后台服务器生成一个token(令牌),并将其发送给Android客户端 2、Android 客户端通过利用createAppSpecificSmsToken() API 接收token信息 3、一旦收到信息，在没有任何权限的情况下，获得一个回调到PendingIntent 这意味着不需要手动输入验证码或token令牌值进入，甚至没有必要有通过读取短信来自动检测代码这个过程。有了这个新的API，我们可以直接得到我们的应用程序的回调。 *””Create a single use app specific incoming SMS request for the the calling package. This method returns a token that if included in a subsequent incoming SMS message will cause intent to be sent with the SMS data. The token is only good for one use, after an SMS has been received containing the token all subsequent SMS messages with the token will be routed as normal. An app can only have one request at a time, if the app already has a request pending it will be replaced with a new request. “”* 为呼叫包创建一个单一的应用程序特定的传入请求短信。这个方法返回一个token，如果包含在后续传入的短信中，将会导致短信数据意图被发送。这个token仅适合一次使用，在收到一条包含了token的短信后，token的所有后续SMS短信消息将正常路由。一个应用程序一次只能有一个请求，如果这个应用程序已经有了一个请求等待，它将被替换为一个新的请求。 优点使用此API最大的好处是不需要任何READ_SMS权限。此外，消息的内容也将直接发送到我们应用程序的意图中。该方法的另一个积极点是短信将不再显示在消息历史中，这特别提高了用户数据的安全性，因为没有其他应用程序将能够读取内容。 结语应用程序请求SMS将不再需要权限,这实际上是Android O中一个很不错的功能，很高兴看到Google继续添加这样的功能。大家觉得如何呢？]]></content>
      <categories>
        <category>Android</category>
        <category>Android O</category>
      </categories>
      <tags>
        <tag>SMS</tag>
        <tag>createAppSpecificSmsToken</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google的Project Treble帮你升级Android系统]]></title>
    <url>%2F2017%2F05%2F13%2Fgoogle-project-treble-help-you-update-android-system%2F</url>
    <content type="text"><![CDATA[随着Android版本的的不断迭代升级更新,到目前已经是Android O版本了。但是依然面临着严重的碎片化问题，大多数像谷歌的亲儿子Pixel和Nexus系列的高端旗舰Android设备，能及时获得安全和操作系统更新。但是在中低档设备的领域，更新是很少的，有时更是闻所未闻的。为了应对这一问题，Google今日推出被成为“迄今为止Android最低级别的系统架构的最大变化的新功能”——Treble项目，能让Android系统升级更快。 目前的升级方式 先来看看目前一个Android系统版本发行的生命流程 1、Google向全球开放最新的代码 2、芯片厂家(如：高通，联发科）适配驱动程序 3、适配过后的驱动程序，提交给手机厂商，华为等厂家开始适配新的谷歌系统 4、运营商的设备制造商与新版本进行测试和认证 5、设备制造商和运营商将新版本提供给用户 有此可见，以上这5步释放周期很慢。 Google表示通过Treble项目，重新设计Android，使制造商将设备更新到更新，更便宜，成本更低，从而将设备更新到新版本的Android。 介绍Treble项目概念核心 将供应商实施（由芯片制造商大部分编写的器件特定的低级软件）从Android OS Framework中分离出来，这是通过在Android OS框架和供应商实现之间引入新的供应商界面来实现的。新的供应商接口由供应商测试套件（VTS）验证，类似于CTS，以确保供应商实现的前向兼容性。 新旧对比 传统方式：没有正式的供应商界面，当设备移动到较新版本的Android时，需要更新Android版本上的大量代码 Treble方式：通过稳定的供应商界面，可以访问Android的硬件特定部分，设备制造商可以通过更新Android操作系统框架来选择向消费者提供新的Android版本，无需芯片制造商提供任何其他工作 后记 Google表示推出的Treble项目将会在Android O及其更高版本上使用（事实上在Android O 预览版上已经在使用Treble项目）。 除此之外，Google还直接与设备制造商直接将其任何代码更改直接实现为通用的ASOP代码库。这意味着当Android O发布时，这些代码更改将不需要被这些公司修补。将会在今年夏天将推出O的同时在source.android.com上发布Project Treble的完整文档。 希望谷歌能通过这个Treble项目改善主要问题，并提供更快的市场上所有的智能手机的更新。 一起期待在下周的Google I/O 2017 开发者大会上获得更多相关的信息。]]></content>
      <categories>
        <category>Android</category>
        <category>Android O</category>
      </categories>
      <tags>
        <tag>Project Treble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gvr Unity SDK (七) —— Unity 添加图片]]></title>
    <url>%2F2016%2F12%2F13%2Fgvr-unity-sdk-load-image%2F</url>
    <content type="text"><![CDATA[上一篇讲了《Gvr Unity SDK (六) —— Unity调用Android接口》，打包好的Android代码,作为plugin放到Unity中，调用其接口，实现数据交互。本节学习如何为Unity3d添加图片 本节讲解其中的Texture2D图片的加载,前面添加全景图片SkyBox，也算是添加图片中的一种类型。 手动添加图片 准备一张需要显示的图片 新建项目，导入gvr-unity-sdk,拖拽GvrViewerMain和GvrReticle到Hierarchy下相应的位置，在Assets下新建Resource文件夹，将图片拖进Assets/Resource下 修改Textrue Type 为 Sprite （2D and UI）,然后Apply 在Hierarchy下右键create==&gt;UI===&gt;Image，创建一个Image 此时的Image位置大小还需要调整，选中Canvas/Image，Image右边的Pos X 、Pos Y 、Pos Z都设置到0的位置，这里我将显示原图的大小，图片的大小是(1920x1080)，就设置Width为1920,Hight为1080,然后将Assets下的Daydream.png拖拽到source Image后面的参数栏里 这样，图片就加载到了Image里面了，然后对UI进行微调一下。选中Canvas,将右边的Image右边的Pos X 、Pos Y 、Pos Z都设置到0的位置,Width也为1920,Hight也为1080，Render Mode 设置为World Space 此时，双击选中Main Camera，可以看到Main Camera已经和Canvas重叠了 最后，再次选中Canvas 缩放为0.05,并将Pos z 值设置大一点，再次，选中相机查看效果（这步需要多次重复进行微调，直到合适为止） 点击播放按钮，播放一下预览效果 代码添加图片 将上面Image配置里面的Source Image设置为None（sprite） 在Resource下面新建一个C# Script，定义一个名称AddPic.cs，然后双击用VS或者Mono打开 加载服务器图片 比如我需要下载这张图片：https://developers.google.cn/vr/images/daydream-logo.png 123456789101112131415161718192021222324252627282930313233343536373839using UnityEngine;using System.Collections;using UnityEngine.UI;using System.IO;public class AddPic : MonoBehaviour&#123; //定义一个Image，在后面属性栏调用该脚本的时候进行捆绑到对应的Image对象上 public Image image; // Use this for initialization void Start () &#123; //格式:StartCoroutine(方法名)， StartCoroutine (&quot;DownloadPic&quot;); &#125; IEnumerator DownloadPic () &#123; //加载网络资源格式：WWW www = new WWW ((http://）或者（https://）)域名地址); WWW www = new WWW (&quot;https://developers.google.cn/vr/images/daydream-logo.png&quot;); yield return www; Debug.Log (www); //判断是否为空，并且没有Error if (www != null &amp;&amp; string.IsNullOrEmpty (www.error)) &#123; //得到纹理 Texture2D txt2d = www.texture; //将2D纹理编码转换成PNG byte[] pngData = txt2d.EncodeToPNG (); //将字节数组写入到本地路径下 File.WriteAllBytes (&quot;C:\\Users\\shoewann\\Desktop\\daydream-logo&quot;, pngData); //创建一个Sprite Sprite sprite = Sprite.Create (txt2d, new Rect (0, 0, txt2d.width, txt2d.height), new Vector2 (0, 0)); //将Sprite添加到image上 image.sprite = sprite; &#125; &#125;&#125; 回到Unity界面，选中Image，将AddPic.cs长按拖拽到右边的属性栏底部 点击添加过去的Add Pic (Script)脚本下面Image后面的小齿轮，选择Image，表示需要讲该Image对象捆绑，作为参数传给AddPic.cs脚本，去执行里面的下载图片完成后的赋值。 点击播放按钮，查看效果 查看本地保存图片位置，图片也是存在的，这样，就是Unity加载网络图片的方法。 加载资源图片加载资源文件里面的图片，就必须要放到Assets/Resources下(注意：一定要是Resources，不是Resource，不要忘记加s) Resources下面需要加载的图片可以不用手动转换成Sprite （2D and UI），直接将需要的图片放到该目录下即可(下面的图片中的Daydream.png是前面示例转换过的，没有进行重新添加图片)。 然后修改一下上面的AddPic.cs脚本文件，加载Assets/Resources/Daydream.png这张图片 123456789101112131415161718192021222324252627282930using UnityEngine;using System.Collections;using UnityEngine.UI;public class AddPic : MonoBehaviour&#123; public Image image; // Use this for initialization void Start () &#123; //格式：Texture2D txt2d = (Texture2D)Resources.Load(文件名); Texture2D txt2d = (Texture2D)Resources.Load(&quot;Daydream&quot;); Sprite sprite = Sprite.Create (txt2d, new Rect (0, 0, txt2d.width, txt2d.height), new Vector2 (0, 0)); image.sprite = sprite; //==================华丽的分割线，以下为补充内容============================= //这里，说一说Texture2D的LoadImage(byte[] byte)方法 //举个例子，比如在这个地方需要加载Android端Launcher上所有已安装应用的Icon图标 //那么首先要在Android端从AppInfo里面读出Drawable类型的图标，转换成Bitmap，最后转换成byte[]数组 //----------------------------------- //在Unity端，通过如下方式加载获取并加载： //byte[] icon = jo.call&lt;byte[]&gt;(&quot;方法名&quot;，参数)； //Texture2D txt2d = new Texture2D(宽度,高度); //txt2d.LoadImage(icon); //Sprite sprite = Sprite.Create (txt2d, new Rect (0, 0, txt2d.width, txt2d.height), new Vector2 (0, 0)); //image.sprite = sprite; //==================华丽的分割线，以上为补充内容============================= &#125; &#125; 回到Unity，确认Image右边AddPic.cs脚本的地方有绑定Image对象作为了参数 点击播放按钮，查看效果 加载本地图片 这里以PC平台为示例，加载PC本地磁盘上的资源图片(以下为本节测试图片) 然后修改一下上面的AddPic.cs脚本文件，加载图片文件的路径为C:\Users\shoewann\Desktop\android_n.jpg 12345678910111213141516171819202122232425262728293031using UnityEngine;using System.Collections;using UnityEngine.UI;using System.IO;public class AddPic : MonoBehaviour&#123; public Image image; // Use this for initialization void Start () &#123; //格式:StartCoroutine(方法名)， StartCoroutine (&quot;LocalLoadPic&quot;); &#125; IEnumerator LocalLoadPic () &#123; //加载本地文件资源格式: WWW www = new WWW (&quot;file://&quot;+@&quot;路径&quot;） WWW www = new WWW (&quot;file://&quot;+@&quot;C:\Users\shoewann\Desktop\android_n.jpg&quot;); yield return www; Debug.Log (www); if (www != null &amp;&amp; string.IsNullOrEmpty (www.error)) &#123; Texture2D txt2d = www.texture; Sprite sprite = Sprite.Create (txt2d, new Rect (0, 0, txt2d.width, txt2d.height), new Vector2 (0, 0)); image.sprite = sprite; &#125; &#125; &#125; 点击播放按钮，查看效果 本节gvr-unity-sdk之Unity添加图片相关内容到此结束，更多功能需要自行扩展，未完待续。]]></content>
      <categories>
        <category>Google VR</category>
      </categories>
      <tags>
        <tag>Google VR</tag>
        <tag>Daydream</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gvr Unity SDK (六) —— Unity调用Android接口]]></title>
    <url>%2F2016%2F12%2F10%2Fgvr-unity-sdk-call-android-sameple%2F</url>
    <content type="text"><![CDATA[上一篇讲了《Gvr Unity SDK (五) —— 添加全景SkyBox》，在Unity的工作空间中如何为自定义添加全景SkyBox，本节学习如何使用Unity3d调用Android代码接口 Unity 调用Android的代码接口，需要将Android逻辑代码写好，然后打包成架包放到Unity3d中，提供给Unity3d调用，本节以一个简单的示例来说明。 Android 端创建Android项目 首先打开Android Studio ，新建一个Android项目GvrSample 然后，找到Unity安装目录，在如下路径找到classes.jar文件 将classes.jar文件复制粘贴到Android Studio工程里app/libs下面 之后选中该classes,jar 文件，右键==&gt; Add as Library,弹出的Module选择app ，点击ok，等待系统添加完成 编写功能逻辑代码 在MainActivity下面，更改默认的AppCompatActivity为UnityPlayerActivity,去掉OnCreate方法里面的布局调用代码。 这里，以Unity端4个Button点击，调用该类的4个方法，输出指定的信息为例 12345678910111213141516171819202122232425262728//无参数无返回值的方法 public void Method_A() &#123; Log.d(TAG, "Method_A: 调用=&gt;[无参数、无返回值]A方法"); Log.d(TAG, "Method_A: 没有传递参数给我，不需要返回参数给Unity3d"); &#125; //无参数有返回值的方法 public String Method_B() &#123; Log.d(TAG, "Method_B: 调用=&gt;[无参数、有返回值的B方法"); Log.d(TAG, "Method_B: 没有传递参数给我,需要返回特定的数据给Unity3d"); return "方法B中某特定返回值"; &#125; //有参数无返回值的方法 public void Method_C(int a) &#123; Log.d(TAG, "Method_C: 调用=&gt;[有参数、无返回值]的C方法"); Log.d(TAG, "Method_C: 有传递参数"+a+"给我,不需要返回特定的数据给Unity3d"); &#125; //有参数有返回值的方法 public String Method_D(int a,int b) &#123; Log.d(TAG, "Method_D: 调用=&gt;[有参数、有返回值]的D方法"); Log.d(TAG, "Method_D: 有传递参数"+a+"，"+b+"给我,需要返回特定的数据给Unity3d"); if (a&gt;b)&#123; return "方法D中，返回最大值："+a; &#125; return "方法D中，返回最大值："+b; &#125; 打开app下面的builde.gradle文件，更改apply com.android.application为com.android.library,之后，删除或者注释下面的 applicationId,点击右上角的Sync Now,最后,选择菜单栏Build==&gt;Build Apk 然后会在app/build/output/aar下面生成app-debug.aar文件 获得Android接口 将生成好的app-debug.aar文件拷贝出来，然后该后缀并解压到文件夹下，其中的classes.jar文件就是后面需要用到的了 Unity3d 端 新建Unity3d项目，3D 类型 创建 UI 在工作空间左侧的Hierarchy下新建一个Button，结构为Canvas/Button/Text，选中Canvas,再右侧的Inspector下面的Canvas属性，更改Render Mode为World Space 然后设置它的Width和Hight都为200dp 就是这样的效果 现在，选中Button，按Ctrl+D，在Button下面克隆出Button （1）、Button （2）、Button （3） 选中这4个Button，沿着Y轴拖拽按钮，使它的位置在Canvas矩形框范围内的顶部 选中左侧Button （1） ,沿着Y轴向下，调整好Button （1）的位置 选中Button （2） ,沿着Y轴向下，调整好Button （2）的位置 选中Button （2） ,沿着Y轴向下，调整好Button （3）的位置 接下来就是修改按钮上面文字了 展开Cavans/Button，选中里面的Text控件，在右边的Text (Script)下修改Text为无参数无返回值 同理,展开Cavans/Button (1)，选中里面的Text控件，在右边的Text (Script)下修改Text为无参数有返回值 展开Cavans/Button (2)，选中里面的Text控件，在右边的Text (Script)下修改Text为有参数无返回值 展开Cavans/Button (3)，选中里面的Text控件，在右边的Text (Script)下修改Text为有参数有返回值 再次选中Canvas，在右侧的Inspector里面设置Pos x、Pos Y、Pos Z都为0,同时，修改下面的Scale 对应的 X 、Y、Z值为0.25, 点击Main Camera可以看到当前的UI视图，但是还需要调整 再次选中Canvas,右侧设置Pos Z 值为40，可以合适的看到场景中的UI了 添加GVR SDK 现在需要参照之前的做法，导入gvr-unity-sdk下面的packge，将GvrViewerMain和GvrReticle拖到Hierarchy指定的地方，点击播放按钮进行播放，查看效果 创建响应脚本 在Assets下新建一个Script文件夹，创建一个Button1 C# 脚本 同理，在下面依次创建Button2、Button3、Button4 编写脚本内容分别用VS或者Mono打开 Button1、Button2、Button3、Button4这四个脚本文件 Button1，创建调用无参数无返回值的A方法 123456789101112using UnityEngine;using System.Collections;public class Button1 : MonoBehaviour &#123; public void CallAndroidMethod_A()&#123; AndroidJavaClass jc = new AndroidJavaClass (&quot;com.unity3d.player.UnityPlayer&quot;); AndroidJavaObject jo = jc.GetStatic&lt;AndroidJavaObject&gt; (&quot;currentActivity&quot;); jo.Call (&quot;Method_A&quot;); &#125;&#125; Button2，创建调用无参数有返回值的B方法 12345678910111213using UnityEngine;using System.Collections;public class Button2 : MonoBehaviour &#123; public void CallAndroidMethod_B()&#123; AndroidJavaClass jc = new AndroidJavaClass (&quot;com.unity3d.player.UnityPlayer&quot;); AndroidJavaObject jo = jc.GetStatic&lt;AndroidJavaObject&gt; (&quot;currentActivity&quot;); string getMethod_B=jo.Call&lt;string&gt; (&quot;Method_B&quot;); Debug.Log (&quot;getMethod_B:==&gt;&quot; + getMethod_B); &#125;&#125; Button3，创建调用有参数无返回值的C方法 123456789101112using UnityEngine;using System.Collections;public class Button3 : MonoBehaviour &#123; public void CallAndroidMethod_C()&#123; AndroidJavaClass jc = new AndroidJavaClass (&quot;com.unity3d.player.UnityPlayer&quot;); AndroidJavaObject jo = jc.GetStatic&lt;AndroidJavaObject&gt; (&quot;currentActivity&quot;); jo.Call(&quot;Method_C&quot;,1); &#125;&#125; Button4，创建调用有参数有返回值的D方法 12345678910111213using UnityEngine;using System.Collections;public class Button4 : MonoBehaviour &#123; public void CallAndroidMethod_D()&#123; AndroidJavaClass jc = new AndroidJavaClass (&quot;com.unity3d.player.UnityPlayer&quot;); AndroidJavaObject jo = jc.GetStatic&lt;AndroidJavaObject&gt; (&quot;currentActivity&quot;); string getMethod_D=jo.Call&lt;string&gt; (&quot;Method_D&quot;,1,2); Debug.Log (&quot;getMethod_D:==&gt;&quot; + getMethod_D); &#125;&#125; 添加物理响应和事件触发 为Main Camera添加Physics Raycaster 为Event System添加Gaze Input Module并移到standalone Input Module上面 为Button绑定脚本事件 选中Button在右边Add Component添加Button1脚本，并添加Event Trigger响应事件，在Event Trigger里添加Pointer Click事件，绑定到控件Button,调用脚本Button1里面的CallAndroidMethod_A()方法 同理，选中Button （1）在右边Add Component添加Button2脚本，并添加Event Trigger响应事件，在Event Trigger里添加Pointer Click事件，绑定到控件Button （1）,调用脚本Button2里面的CallAndroidMethod_B()方法 选中Button （2）在右边Add Component添加Button3脚本，并添加Event Trigger响应事件，在Event Trigger里添加Pointer Click事件，绑定到控件Button （2）,调用脚本Button3里面的CallAndroidMethod_C()方法 选中Button (3)在右边Add Component添加Button4脚本，并添加Event Trigger响应事件，在Event Trigger里添加Pointer Click事件，绑定到控件Button（3）,调用脚本Button4里面的CallAndroidMethod_D()方法 添加Android 接口到Unity 将上面打包解压后的classes.jarAndroid功能架包添加到Plugins/Android/libs下 修改合并Plugins/Android下的AndroidManifest.xml 运行并响应事件按照前面讲的，打包时填写的公司名和产品名，要和下面对应一致，并且同时也要和android端的包名一致。 当点击第一个按钮: 无参数无返回值 输出: 当点击第二个按钮: 无参数有返回值 输出: 当点击第三个按钮: 有参数无返回值 输出: 当点击第四个按钮: 有参数有返回值 输出: 本节gvr-unity-sdk之Unity调用Android接口相关内容到此结束，更多功能需要自行扩展，下一节继续《Gvr Unity SDK (七) —— Unity 添加图片》]]></content>
      <categories>
        <category>Google VR</category>
      </categories>
      <tags>
        <tag>Google VR</tag>
        <tag>Daydream</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gvr Unity SDK (五) —— 添加全景SkyBox]]></title>
    <url>%2F2016%2F12%2F04%2Fgvr-unity-sdk-create-vr-skyboxes%2F</url>
    <content type="text"><![CDATA[上一篇讲了《Gvr Unity SDK (四) —— 焦点事件触发》，在Unity的工作空间中如何为为创建视觉焦点的GameObject对象触发焦点事件，本节学习如何更改默认的skybox，自定义创建全景的Skybox 首先你需要一张全景的图片，可以到Google collections或者Google Photo Sphere社区下载，本例提供一张示例全景图片(最好要Sphere的，能首尾连接在一起) 在Project窗口里的Assets下的Sample里创建一个Resource文件夹，将上图添加到该目录 选中图片，在右侧Inpector下面将Texture Type(纹理类型)改为Advanced(高级)，将Mapping改为Latitude-Longitude Layout ,点击底部的Apply应用 稍等片刻，图片转换成功 回到Sample下面的Material文件夹，新建一个Material,命名为newSkybox 选中newSkybox，右侧的Inpector下面，更改shader为Skybox/Cubemap 在Cubmap (HDR) 右边，点击选择刚刚创建好的newSkybox 点击菜单栏Window ==&gt; Lighting,切换到Scene选项卡下面，看到第一个选项Skybox,点击后面的小齿轮，找到创建好的newSkybox，点击选中 这样自定义的全景Skybox就被加载到场景中了，可以找到刚刚的Material文件夹下面的newSkybox，通过滑动Rotation进度条的值，来设置合适的第一视觉方向 最后选中Hierarchy下面的Plane，右键，Delete将它移除，点击播放按钮，按住Alt并滚动鼠标，进行环顾四周 本节gvr-unity-sdk添加全景SkyBox相关内容到此结束，下一节继续《Gvr Unity SDK (六) —— Unity调用Android接口》]]></content>
      <categories>
        <category>Google VR</category>
      </categories>
      <tags>
        <tag>Google VR</tag>
        <tag>Daydream</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gvr Unity SDK (四) —— 焦点事件触发]]></title>
    <url>%2F2016%2F12%2F04%2Fgvr-unity-sdk-respond-event-trigger%2F</url>
    <content type="text"><![CDATA[上一篇讲了《Gvr Unity SDK (三) —— 创建视觉焦点》，在Unity的工作空间中如何为已经创建GameObject对象创建视觉焦点，本节学习如何为创建视觉焦点的GameObject对象触发焦点事件 创建C#脚本文件 在Unity工作空间Project窗口下，为Asstes下的Sample创建一个Script文件夹，里面用来保存C#脚本，然后在里面创建一个叫做CubeScript的脚本，以此为Cube对象响应焦点事件 双击CubeScript打开编辑器进行编辑，根据配置不同，会有Microsoft Visual Studio和Mono Develop两种工具打开，本例是用Mono Develop进行编辑的。打开文件后，会生成默认的代码配置 编辑C#脚本文件然后，进行脚本编辑，以下是一个简单的示例来说明: 1234567891011121314151617181920212223242526272829303132333435363738394041424344using UnityEngine;using System.Collections;public class CubeScript : MonoBehaviour &#123; // 定义一个方法，传入boolean类型的参数 public void SetGazedAt(bool gazedAt) &#123; //通过传入的gazedAt值不同，通过三目运算符真假设置组件渲染材料颜色，true为蓝色、false为黄色 GetComponent&lt;Renderer&gt;().material.color = gazedAt ? Color.blue : Color.yellow; &#125; //定义一个向上移动的方法 public void MoveUp() &#123; //在U3d里用Vector3表示空间内的坐标，参数分别是(float x,float y,float z) //通过每调用一次该方法，让组件向y轴方向位移1f的距离 transform.position += new Vector3 (0f, 1f, 0f); &#125; //程序开始 void Start() &#123; //调用设置渲染材料颜色的方法，默认设置参数为false SetGazedAt(false); &#125; //当焦点进入组件范围 public void OnGazeEnter() &#123; ，设置渲染材料颜色的方法，设置参数为true SetGazedAt(true); &#125; //当焦点退出组件范围 public void OnGazeExit() &#123; //设置渲染材料颜色的方法，设置参数为false SetGazedAt(false); &#125; //当点击组件时 public void OnGazeTrigger() &#123; //调用组件移动的方法 MoveUp(); &#125;&#125; 绑定C#脚本文件回到Unity工作空间，选中Cube对象，在Cube右侧Inspetor属性栏的底部，点击Add Component，在搜索栏里输入创建的脚本CubeScript,然后选中添加 添加完成后，点击CubeScript后面的小齿轮，将它Move Up到Event Trigger上面 点击Event Trigger里面的Add New Event Type,添加一个事件类型，选择Pointer Enter,在添加的Pointer Enter面板上，点击右下角的+,添加一项 然后点击左边选择Cube对象，右边下拉框，选择定义的脚本名称CubeScript下面的OnGazeEnter()方法 同理，再两次分别点击Add New Event Type，分别选择Pointer Exit和Pointer Click,分别点击+,分别选择上Cube对象，分别选择上CubeScript下面的OnGazeExit()方法和OnGazeTrigger()方法 最后点击播放按钮，查看效果，按住Alt，滚动鼠标。 当准星不在Cube对象上，准星是圆点，Cube是黄色 当准星在Cube对象上，准星是圆圈，Cube是蓝色 当准星在Cube对象上，点击Cube，Cube向上位移1f 本节gvr-unity-sdk 焦点事件触发相关内容到此结束，下一节继续《Gvr Unity SDK (五) —— 添加全景SkyBox》]]></content>
      <categories>
        <category>Google VR</category>
      </categories>
      <tags>
        <tag>Google VR</tag>
        <tag>Daydream</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gvr Unity SDK (三) —— 创建视觉焦点]]></title>
    <url>%2F2016%2F12%2F04%2Fgvr-unity-sdk-create-event-trigger%2F</url>
    <content type="text"><![CDATA[上一篇讲了《Gvr Unity SDK (二) —— 创建GameObject》，在Unity的工作空间中如何创建GameObject对象，本节学习如何为GameObject对象添加视觉焦点 其实在第一节，细心点会发现，运行效果的时候可以看到屏幕中心有个瞄准的白点，那就是用来瞄准焦点的。那是我们在那个时候拖动GvrReticle到Main Camera下面，早已经完成了本节创建视觉焦点的第一步。 然后我们选中Main Camera，在右侧Inspetor属性栏的底部，点击Add Component，在搜索栏里输入Physics Raycaster,然后选中添加 添加过后是这样的，Physics Raycaster组件被添加到了Inspetor属性栏的底部 接下来我们首先在场景中添加Event System系统事件，在Unity工作空间上半部分左侧的Hierarchy空白的地方，单击右键==&gt; UI==&gt;Event System(或者选择菜单栏==&gt;Game Object==&gt;UI==&gt;Event System),在Event System右侧Inspetor属性栏的底部，点击Add Component，在搜索栏里输入GazeInputModule（凝视输入）,然后选中添加 添加过后是这样的，GazeInputModule组件被添加到了Inspetor属性栏的底部，然后点击GazeInputModule后面的小齿轮，选择Move Up将GazeInputModule移到Standalone Input Module上面 选中Cube,为它添加视觉焦点，同样在Cube右侧Inspetor属性栏的底部，点击Add Component，在搜索栏里输入Event Trigger,然后选中添加 之前的准星默认是白色的一个点，下面来自定义一下准星的颜色。选择Main Camera下面的GvrReticle，在GvrReticle右侧Inspetor属性栏的底部GvrReticleMaterial下面可以看到默认的颜色是白色，点击后面的拾色器，自定义颜色 此文中以红色为例 再次点击播放按钮，查看效果，按住Alt，滚动鼠标，当准星在Cube对象上，准星由圆点变成了圆环，表示了选中了该对象；当准星不在Cube对象上，准星由圆环变成了圆点，表示了取消选中了该对象。 本节gvr-unity-sdk创建视觉焦点相关内容到此结束，下一节继续《Gvr Unity SDK (四) —— 焦点事件触发》]]></content>
      <categories>
        <category>Google VR</category>
      </categories>
      <tags>
        <tag>Google VR</tag>
        <tag>Daydream</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gvr Unity SDK (二) —— 创建GameObject]]></title>
    <url>%2F2016%2F12%2F03%2Fgvr-unity-sdk-create-gameobject%2F</url>
    <content type="text"><![CDATA[上一篇讲了《Gvr Unity SDK (一) —— 项目引入》，成功的将Gvr Unity SDK导入到了Unity的工作空间中，本节以创建GameObject来讲Gvr Unity SDK 的使用 创建GameObject 接下来我们首先在场景中添加一块Plane(平面)，在Unity工作空间上半部分左侧的Hierarchy空白的地方，单击右键==&gt; 3D Object==&gt;Plane(或者选择菜单栏==&gt;Game Object==&gt;3D Object==&gt;Plane),然后在右边的属性栏里面将它的X，Y，Z三个方向都放大3倍 这里要重点说明一下图中的X、Y、Z轴，看到图中的Main Camera，以它为中心，红色的是X轴(控制左右)、绿色的是Y轴(控制高低)、蓝色的是Z轴(控制远近) 然后我们点击播放按钮，查看效果 之后，我们来给Plane平面换一个颜色。在Assets窗口下，新建一个文件夹来保存自己的东西，我这里新建了Sample为例，在Sample下面新建一个Material文件夹来保存Material资源。在Material文件夹下，单击右键==&gt;Create==&gt;Material,命名为Plane 选中刚刚创建的Plane，在右侧的属性栏中，点击Albedo后面的拾色器，选择颜色 我这里以绿色为例 然后，将绿色的Plane，长按拖拽进场景中的Plane上面，然后点击播放按钮，查看效果 以创建Plane对象同样的方式，在Unity工作空间上半部分左侧的Hierarchy空白的地方，创建一个Cube和在Material文件夹下创建一个Cube的Material，同样用拾色器，选择颜色，我这里以黄色为例 再次点击播放按钮，查看效果 最后按以下Ctrl+S保存一下(通常有这个习惯的人，早已经完成了这步了)，这便是一个Scene场景，下次可以通过双击这个打开一个场景 运行打包到设备首次运行，点击File==&gt;Build &amp; Settings，点击Add Open Scenes,添加场景进行Build左下角，这里我只选择Android平台，然后选择Player Settings 在右边的Inspector下面填上公司名和产品名，也需要填到下面填包名的地方 这两个地方一定要保持一致 然后再设置一下方向，在Resolution and Presentation下面的Oritation，更改Auto Rotation为Landscape Left 最后点击Build &amp; Run，定义一个文件名，进行保存，稍候就会运行到设备上 本节gvr-unity-sdk创建GameObject相关内容到此结束，下一节继续《Gvr Unity SDK (三) —— 创建视觉焦点》]]></content>
      <categories>
        <category>Google VR</category>
      </categories>
      <tags>
        <tag>Google VR</tag>
        <tag>Daydream</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gvr Unity SDK (一) —— 项目引入]]></title>
    <url>%2F2016%2F12%2F03%2FImport-gvr-unity-sdk-into-the-project%2F</url>
    <content type="text"><![CDATA[Google 为虚拟现实(VR)提供了两个虚拟现实（VR）平台：Cardboard，世界上最受欢迎和可访问的移动VR平台，以及Daydream,一个用于低延迟，沉浸式和交互式移动VR的新平台。Google VR SDK包括您为这些平台开发所需的一切内容，包括库，API文档，开发人员示例和设计指南。 平台分类 Gooogle VR 官方页面为我们开发VR应用，提供了4种Api: Unity: Google VR SDK for Unity，允许您轻松地适应现有的Unity 3D应用程序的虚拟现实或从头开始构建自己的VR体验。支持Daydream和Cardboard Android: Google VR SDK for Android ，让您创建应用程序，显示3D场景与双目渲染，呈现空间音频，跟踪和反应头部运动，并与应用程序交互。支持Daydream和Cardboard iOS: Google VR SDK for iOS，可让您在Objective-C中为本地iOS应用程式建立VR体验。支持Cardboard Unreal Engine4: 虚幻引擎4原生支持Google VR，允许您使用新的和现有的UE4项目构建移动VR体验。支持Daydream和Cardboard 我们可以根据自己的需求选择合适的平台API，本文将开始介绍Unity平台Daydream SDK的相关使用。 Gvr for Unity 包含了什么？Unity对Google VR的原生支持，使其更容易去: 从头开始一个新的VR Unity项目 将现有的Unity 3D应用程序适配到VR 创建一个可以轻松切换进入和退出VR模式的应用程序 与Google VR的集成，提供了： 用户头部跟踪 并排立体渲染 检测用户与系统的交互（通过触发器或控制器） 用于特定VR查看器的自动立体声配置 VR观看者镜头的失真校正 当您将手机插入到查看器中时，可以使用对齐标记来帮助将屏幕置于镜头下方 自动陀螺漂移校正 Unity的Google VR SDK具有以下额外功能： 白日梦控制器支持 空间化音频呈现 一个简单的标线预制和相关脚本，用于基于凝视的用户交互 VR模拟在Unity编辑器的播放模式，使用鼠标和alt /控制键平移或倾斜摄像头 一个“头显演示”场景显示一个简单的纸板游戏，和一个“控制器演示”场景集成了白日梦控制器 FPS显示预览，显示应用程序的呈现性能 下载、安装UnityGoogle VR Unity 版本的SDK请求 Unity开发工具是5.2.1或者更高版本 以下提供最新Unity开发工具(5.4.2F2-GVR12)下载和gvr-unity-sdk下载: Windows :下载 OS X :下载 gvr-unity-sdk: 下载 (在此就不细说具体安装过程了，如果安装过程遇到了问题可以在本文底部留言。作为Android开发者，Unity我也是才入门，如果你是小白，那我们一起学习。以下内容就是我这段时间学习gvr-unity的相关内容，仅供参考，可能有不足的地方，欢迎指正） 项目引入首先我们解压我们下载的gvr-unity-sdk，然后打开Unity工具，点击右上角的NEW创建一个新的项目，填入项目名和保存路径 点击Create project后，该窗体关闭，稍等片刻将会打开主窗体,如果过程没有什么问题，将会是下面这样 在上半部分的左侧是Hierarchy,默认包含了场景名称，及其下面的Main Camera(主相机)，Directional Light（方向灯） 然后，我们看到下半部分左侧的Project窗口，然后选中Assets，鼠标右键 ==&gt; Import Package==&gt;Custom Package，找到之前解压的gvr-unity-sdk，打开其中的GoogleVRForUnity.unitypackage文件 然后弹出一个对话框，需要我们导入需要的文件，这里我只会用到Android平台，所以我取消选中Plugin下面的iOS、x86和x86_64，其他的都选中，然后点击Import导入 然后又会弹出一个对话框，需要导入包，然后继续点击Import Package 再次点击下一个对话框的Import gvr-unity-sdk的项目导入到工作空间之后，将在Project窗口下，Asstes下的两个根文件:Google VR 和 Plugin 展开Google VR，找到Prefabs,将GvrViewerMain长按拖到Hierarchy下面 然后再找到Prefabs下面的UI,将里面的GvrReticle长按，拖到拖到Hierarchy下面的Main Camera里 看到工具顶部中间的三个按钮，一个是三角形的播放按钮，一个是双竖线的暂停按钮，还有一个是三角形和双竖线的下一个按钮，点击播放按钮，查看效果 按住Alt并滑动鼠标可以环视周围的场景，再次点击点击播放，退出播放模式，取消查看 如果你发现下面有报错的地方，不管它，因为当前没有绑定任何对象，所以会有错误的log输出，直接点击旁边的clear清除掉log 至此，完成了gvr-unity-sdk的项目导入 本节gvr-unity-sdk项目导入相关内容到此结束，下一节继续《Gvr Unity SDK (二) —— 创建GameObject》]]></content>
      <categories>
        <category>Google VR</category>
      </categories>
      <tags>
        <tag>Google VR</tag>
        <tag>Daydream</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最后的Android7.1开发者预览版升级]]></title>
    <url>%2F2016%2F11%2F23%2Ffinal-update-to-android-7-1-developer-preview%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Final update to Android 7.1 Developer Preview 今天我们推出了升级到Android 7.1开发者预览版 —— 我们发布最终版Android7.1.1平台到生态系统之前的最后一次。Android7.1.1包括了在Pixel和Pixel XL设备已经可以使用到的功能特性，并且添加了基于Android7.1平台的优化和首要错误修复。开发者预览版2，您能够确保您的应用已经为Android 7.1.1做好了准备，消费者将很快在他们的设备上运行它。 正如十月的时候强调的,我们也扩张了设备范围，您能够在Nexus 5X,Nexus 6P,Nexus 9和Pixel C设备上收到开发者预览版的升级。 如果有一部被受支持的设备，并且在Android测试计划已经注册，您将会在接下来的一周收到开发者预览版2的升级。如果您还没有注册您的设备，请访问站点注册您的设备并获取升级。 在12月初，我们将推出Android 7.1.1到全系列支持的设备以及Pixel和Pixel XL设备。 更新升级了什么？开发者预览版2是Android 7.1.1的发布候选者，您可以用它来完成您的应用程序开发，并测试准备即将到来的最终版本。其中包括了接近最终系统的行为和UI，以及整个系统和Google应用程序的最新错误修复和优化。 它也包括了在开发者预览版1中已经介绍过的开发者功能特性和APIs(API Level 25)，如果您还没有探索开发者功能特性，您将需要查看应用快捷方式，圆形图标资源和图片键盘支持等，您可以在此处查看开发人员功能的完整列表。 开发者预览版2 ，我们也升级了Android Studio中的 SDK 构建和平台工具。Android 7.1.1平台和API等级25模拟器系统镜像。最终版版本的支持库(25.0.1)也是可以使用的了，对于您去添加图片键盘支持,底部导航栏以及其他特性，去运行在API等级25或者更早期的设备。 对于API等级25更详细的检出在开发者预览版站点的API不同点和已经更新升级过的API参考 为您的应用准备7.1现在是时间去优化您的应用了，看起来最好的Android7.1.1。对于获得开始，升级到Android Studio2.2.2，然后通过Android Studio里面的SDK管理器下载API等级25平台，模拟器系统镜像，和工具。 安装API 等级25 SDK 之后，您能够升级的您的项目的compileSdkVersion到25去编译构建和测试新的APIs,如果您在做兼容性测试，我们建议升级您的应用的targetSdkVersion到25，利用兼容性行为禁用去测试您的应用。针对于如何去利用API等级25SDK去设置您的应用的详细过程，查看预览版建立 如果您在添加应用快捷方式或者圆形桌面图标到您的应用，您能够使用Android Studio的built-in Image Assets Studio去快速帮助您创建不同大小的图标，参见Material Design设计向导。您能够在API等级为25的Google APIs模拟器上面去测试您的圆形图标，包括圆形图标和新的Google Pixel桌面的支持。 如果您在添加图片键盘支持，您能够使用包括在预览版系统镜像中的Messenger和Google键盘应用去测试，因为它们包括对这个新API的支持。 使用Firebase Test Lab for Android扩展测试为了帮助扩展测试，确保利用Firebase Test lab for Android在云端进行测试。在预览期间不对所有虚拟设备,包括开发者预览版2(API25)进行收费。您能够使用自动爬行(Robo Test)去测试您的应用，不需要去写任何的测试脚本，或者您能够上传您自己仪器(例如:Espresso)测试，您能够在这儿上传您的测试。 将您的应用程式发布到Google Play的Alpha，Beta或制作频道在您完成了最终版的测试，您能够发布您编译的更新和可选择定位，API25到Google Play。您能够在Google Play Consolez中发布到您的alpha,beta,或者甚至制作通道，推送您的应用更新升级到那些运行Android 7.1用户的设备上，比如Pixel和Android Beta设备。 在您的合格设备上获取开发者预览版2如果您有符合资格的设备已注册Android Beta Program，设备将会在记下来的一周获得开发者预览版2的更新升级。您无须任何操作。如果您还没有注册计划，最简单的方式就是通过访问android.com/beta选择您合格的Android电话或者平板 ——— 您将会不久会收到这个预览版OTA升级。一如既往，您也能够下载并手动刷入这个更新升级 正如刚才提到的,这个开发者预览版更新对于Nexus 5X, Nexus 6P, Nexus 9, 和 Pixel C devices都可用。 我们期望从12月开始，在短短几个星期内推出Android 7.1.1的最终版本，我们将推出Android 7.1.1到全系列支持预览版的设备，以及最近推出的Pixel和Pixel XL设备。那时候，我们还会将来源码推送到AOSP，因此我们的设备制造商合作伙伴可以在其设备上向消费者提供此新平台更新。 与此同时，我们继续欢迎您在开发者预览版 issue 追踪、N预览版开发者社区或者Android Beta社区的反馈，因为我们正在努力争取在12月的最终消费者发布！ 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 7.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Firebase特性之Robo测试实验室]]></title>
    <url>%2F2016%2F11%2F06%2Fandroid-in-firebase-robo-test-lab%2F</url>
    <content type="text"><![CDATA[上一篇我们讲到了《Firebase特性之崩溃报告》，在这篇文章中，我们来共同学习一下如何在Androids上使用Firebase的测试实验室。 测试前的准备要在Androids上使用Firebase的测试实验室，首先要做的就是参照上一篇的内容，如果你之前在Firebase上创建过项目可以跳过继续直接进行后面下一步步骤；或者也可以在本地用Android Studio创建一个新的项目，参照上一篇的配置配置好本地和Firebase云端环境，当你本地Android Studio环境和Firebase云端空间项目都创建成功后，确保本地项目已经添加了google-services.json文件和相关依赖，就可以开始下一步操作。 选择测试项目 点击左侧的Test Lab 在Androids上使用Firebase的测试实验室,然后点击RUN YOUR FIRST TEST按钮 选择测试类型当前页面会提示让你选择测试类型,有两种类型: Robo测试 Robo测试在各种设备上自动探索您的应用程序，以查找缺陷并报告发生的任何崩溃。 Robo测试不需要你编写应用测试。 仪器测试 运行您编写的Espresso，Robotium或UIAutomator 2.0测试，以在各种设备上测试您的应用程序。 Robo测试与使用Android UI框架中的元素的应用兼容：如果您的应用程序使用其他UI框架（如Unity），测试可能只会探索您的应用程序的第一个屏幕。你可以点击查看更多 本节我们来总结类型之一的Robo测试的相关使用 Robo测试配置测试我们选择默认的Robo测试，然后点击CONTINUE继续 这里需要上传应用的APK文件，然后选取您要测试的尺寸。 等待上传成功…… 上传成功后，点击CONTINUE继续 这里选择你想测试的设备、API等级、方向、和地区，每一个尺寸你必须至少要选择一个，然后点击当前页面右下角的START XX TESTS按钮。（示例：我这里选择了虚拟设备Nexus 5、API Level 23(Android 6.0.x)、方向横屏和竖屏、地区美国（en_us） ） 开始测试下面开始进入Robo测试界面，开始测试上面我配置的示例，然后等待测试结果: 等待几分钟，然后测试完成了，２个pass,都通过了： 分析测试然后我们点开测试配置的,其中一个设备进去，可以看到一些测试的详细的信息(测试结果、测试时间、测试用时、地区、方向),重点是下面的LOGS、SCREENSHOTS、ACTIVITY MAP、VIDEO LOGS 测试时打印的日志 SCREENSHOTS 测试时屏幕截图 ACTIVITY MAP Activity 地图 VIDEO 视频记录的测试过程 下面是视频对应的gif动态图效果（ps:图片是720x1280的，有点大，可以点击下面的图片，查看效果）: 最后我们点击详细页面右上角的VIEW SOURCE FILES，可以查看源文件，是放在Google云平台的 以上简单的介绍了如何使用Firebase实验室Robo测试类型的相关内容，有关Firebase的其他特性，后续总结。如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
        <category>Firebase</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>Firebase</tag>
        <tag>Android</tag>
        <tag>Google Cloud</tag>
        <tag>Testing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Firebase测试实验室里的Android开发者预览版]]></title>
    <url>%2F2016%2F11%2F05%2Fandroid-dev-preview-in-firebase-test-lab%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Test on Android 7.1 Developer Preview in Firebase Test Lab 为了提供最好的用户体验的大门，对于Android的Firebas测试实验室允许您测试您的应用以确保它们在多个设备配置兼容。跨越系统版本、屏幕方向和地区，点击一次，您就能够在Google云的上百台设备配置上运行您的测试，并且您能给很快的收到结果。 今天，我们非常激动的宣布Android 7.1 开发者预览版在Firebase测试实验室虚拟设备可以用了。除了使用Android Beta方案在您的物理设备上测试Android 7.1开发者预览版本，或者是在您本地Android模拟器上，您还可以使用Firebase测试实验室将应用测试扩展到上百个Android虚拟设备。 您也能够使用Firebase测试实验室来执行自己的测试。如何您还没有一个任意的测试脚本，Robo测试是在新平台上进行基本兼容性测试的理想选择。它会抓取您的应用程序，以尝试找到崩溃。您也可以在Android Studio中利用Espresso 测试记录器去记录自己的仪器测试，而无需编写任何代码。 从现在起至12月底（2016年12月31日），Firebase测试实验室将会在Firebase Blaze计划上，对所以虚拟设备免费提供，以此帮助您确保您的应用程序和Android 7.1开发者预览版兼容，以及与其他Android版本。 为您的应用API 等级25做准备，然后去Firebase测试实验室控制台运行您的第一个测试。 测试愉快！ (Robo测试揭开Flood-It！应用在Android 7.1开发者预览中的崩溃) 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
        <category>Firebase</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>Firebase</tag>
        <tag>Android</tag>
        <tag>Google Cloud</tag>
        <tag>Testing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的AES加密解密技术]]></title>
    <url>%2F2016%2F11%2F03%2FAES-in-Android%2F</url>
    <content type="text"><![CDATA[最近需要在项目中加密数据，首先想到要使用到AES加密技术。在网上找了很多，都是适合Java工程，在Android上无法正常达到预期的解密。花了两天的时间终于找到了可以在Android上顺利实现加密解密的代码，在这里有必要的记录一下。 简介对于AES的概念，以下摘自维基百科，它是这样解释的: 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 其余的就不多说了，以下直接进入主题 … Android中的用法以下示例是基于Android的，Java不通用 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.wt.aes;import java.security.SecureRandom;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/** * Created by shoewann on 16-9-23. */public class AESUtils &#123; public static String encrypt(String seed, String cleartext) throws Exception &#123; byte[] rawKey = getRawKey(seed.getBytes()); byte[] result = encrypt(rawKey, cleartext.getBytes()); return toHex(result); &#125; public static String decrypt(String seed, String encrypted) throws Exception &#123; byte[] rawKey = getRawKey(seed.getBytes()); byte[] enc = toByte(encrypted); byte[] result = decrypt(rawKey, enc); return new String(result); &#125; private static byte[] getRawKey(byte[] seed) throws Exception &#123; KeyGenerator kgen = KeyGenerator.getInstance("AES"); SecureRandom sr = SecureRandom.getInstance("SHA1PRNG", "Crypto"); sr.setSeed(seed); kgen.init(128, sr); // 192 and 256 bits may not be available SecretKey skey = kgen.generateKey(); byte[] raw = skey.getEncoded(); return raw; &#125; private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception &#123; SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); byte[] encrypted = cipher.doFinal(clear); return encrypted; &#125; private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception &#123; SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); byte[] decrypted = cipher.doFinal(encrypted); return decrypted; &#125; private static String toHex(String txt) &#123; return toHex(txt.getBytes()); &#125; private static String fromHex(String hex) &#123; return new String(toByte(hex)); &#125; private static byte[] toByte(String hexString) &#123; int len = hexString.length() / 2; byte[] result = new byte[len]; for (int i = 0; i &lt; len; i++) result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue(); return result; &#125; private static String toHex(byte[] buf) &#123; if (buf == null) return ""; StringBuffer result = new StringBuffer(2 * buf.length); for (int i = 0; i &lt; buf.length; i++) &#123; appendHex(result, buf[i]); &#125; return result.toString(); &#125; private final static String HEX = "0123456789ABCDEF"; private static void appendHex(StringBuffer sb, byte b) &#123; sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f)); &#125;&#125; 示例调用12345678910111213141516171819202122232425262728293031323334package com.wt.aes;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;/** * Created by shoewann on 16-9-23. */public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; String content="我是需要加密的数据内容"; String key="com.sina.com"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); try &#123; Log.d(TAG,"加密前："+content); //encrypt （加密） String encrypt = AESUtils.encrypt(key, content); Log.d(TAG,"加密后："+encrypt); //decrypt （解密） String decrypt = AESUtils.decrypt(key, encrypt); Log.d(TAG,"解密后："+decrypt); &#125; catch (Exception e) &#123; e.printStackTrace(); Log.d(TAG,"ERROR："+e.getMessage()); &#125; &#125;&#125; 运行结果,如果是这样: 根据以上log信息可以看出，数据能在设备上成功被加密和解密出来，说明你当前的调试设备版本在Android 7.0(API 24)以下，你依然可以使用以上的方式来加密解密。 Android N 已弃用Crypto 如果你在Android系统版本是7.0的设备上运行以上代码，结果是这样的: 根据以上的log信息可以看出，在Android 7.0 新版本 Android SDK 不再支持 Crypto,至于详细可以访问http://android-developers.blogspot.com/2016/06/security-crypto-provider-deprecated-in.html或者查看之前我翻译提交的这篇文章。 以下是，修改过后的工具类: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.wt.aes;import java.nio.charset.StandardCharsets;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/** * Created by shoewann on 16-9-23. */public class AESUtils &#123; public static String encrypt(String seed, String cleartext) throws Exception &#123; byte[] rawKey = deriveKeyInsecurely(seed,32).getEncoded(); byte[] result = encrypt(rawKey, cleartext.getBytes()); return toHex(result); &#125; public static String decrypt(String seed, String encrypted) throws Exception &#123; byte[] rawKey = deriveKeyInsecurely(seed,32).getEncoded(); byte[] enc = toByte(encrypted); byte[] result = decrypt(rawKey, enc); return new String(result); &#125; private static SecretKey deriveKeyInsecurely(String password, int keySizeInBytes) &#123; byte[] passwordBytes = password.getBytes(StandardCharsets.US_ASCII); return new SecretKeySpec( InsecureSHA1PRNGKeyDerivator.deriveInsecureKey( passwordBytes, keySizeInBytes), "AES"); &#125; private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception &#123; SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); byte[] encrypted = cipher.doFinal(clear); return encrypted; &#125; private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception &#123; SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); byte[] decrypted = cipher.doFinal(encrypted); return decrypted; &#125; private static String toHex(String txt) &#123; return toHex(txt.getBytes()); &#125; private static String fromHex(String hex) &#123; return new String(toByte(hex)); &#125; private static byte[] toByte(String hexString) &#123; int len = hexString.length() / 2; byte[] result = new byte[len]; for (int i = 0; i &lt; len; i++) result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue(); return result; &#125; private static String toHex(byte[] buf) &#123; if (buf == null) return ""; StringBuffer result = new StringBuffer(2 * buf.length); for (int i = 0; i &lt; buf.length; i++) &#123; appendHex(result, buf[i]); &#125; return result.toString(); &#125; private final static String HEX = "0123456789ABCDEF"; private static void appendHex(StringBuffer sb, byte b) &#123; sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f)); &#125;&#125; 以上的工具类中InsecureSHA1PRNGKeyDerivator这个类，可以在示例代码里找到 通过再次调用以上的工具类中的加密解密的方法，就可以在Android 7.0上成功加密解密出数据: 以上是对Anroid 中使用AES及在7.0上使用相关问题，原创不易，如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android N</category>
        <category>加密解密</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[终止Eclipse作为Android开发工具的支持]]></title>
    <url>%2F2016%2F11%2F03%2Fsupport-ended-for-eclipse-android%2F</url>
    <content type="text"><![CDATA[原文来自：ByJamal Eason, Product Manager, Android ———— Support Ended for Eclipse Android Developer Tools 随着Android Studio 2.2的发布，现在是时候与Eclipse Android开发工具说再见了。我们正式结束了对它们的支持和开发。从未有过更好的时间切换到Android Studio,体验我们对Android开发工作流程的改进。 Android StudioAndroid Studio，是Android官方的IDE工具，功能强大的代码编辑与高级代码完成和重构。它包括了强大的静态分析,将Android工程团队的智慧带给您，帮助您轻松应用Android编码最佳实践,并且包括在Java和C++同时调试以帮助修复任何漏洞。当您将其与性能工具相结合时，一个快速、灵活的构建系统、代码模板、GitHub集成、及其高性能、功能丰富的模拟器，您将获得针对操作系统对于许多形状因素进行深入Android定制的开发环境。它是在Google Play前125个应用和游戏中的92％被使用的开发环境，我们不断创新，以处理每一个Android开发需求。 Android Studio 2.2中有什么新东西Android Studio 2.2是来源与Android Studio 2.0伟大的功能进行构建的。这里超过20种新功能去改进开发，无论您是设计，迭代还是测试，值得注意的变化包括: Instant Run - 超快速迭代引擎现在更可靠，可用于更多类型的更改 Layout Editor - 新的用户界面设计器，比以往更容易创建漂亮的应用程序体验 Constraint Layout - 用于构建动态用户界面的新的灵活布局引擎 - 设计用于使用新的布局编辑器 C++ Support - 现在支持CMake和ndk-build以及改进的编辑和调试体验 APK Analyzer - 检查APK以帮助您简化APK并调试multi-dex问题 GPU Debugger(beta) - 捕获OpenGL ES命令流，并使用GPU状态检查重播它们 Espresso Test Recorder(beta)- 记录与您的应用程序的互动，并输出UI测试代码 对于我们的ADT粉丝所有您喜欢的ADT工具现在是Android Studio的一部分，包括DDMS、Trace Viewer、Network Monitor、和CPU Monitor，我们还改进了Android Studio的辅助功能，包括键盘导航增强和屏幕阅读器支持。 在2015年结束的时候就已经宣布了终止Eclipse作为Andorid开发工具(ADT)的开发和官方支持。包括了Eclipse ADT插件和Android Ant 构建系统。通过Studio的最新更新，我们完成了转换。 迁移到Android Studio开始,下载和安装 Android Studio,对于大多数的开发者，包括那些具有C / C++项目。迁移与导入现有Eclipse ADT项目一样简单，在Android Studio中使用File &gt; New&gt; Import Project菜单选项,有关迁移过程的详细信息，请参阅迁移指南。 反馈和开源贡献我们致力于使Android Studio成为构建Android应用程序的最佳集成开发环境,因此如果有缺少功能或其他挑战，阻止您切换到Android Studio，我们想听听[调查]！您还可以直接向团队提交错误或功能请求，并通过我们的Twitter或Google+帐户通知我们。 Android Studio是一个开源项目，所有的免费提供。如果您有兴趣贡献或学习更多，请查看我们的开源项目页面。 以上是对Anroid 官网博客文章的部分翻译，如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 7.1 应用快捷键详解]]></title>
    <url>%2F2016%2F10%2F21%2Fandroid71-dev-preview-app-shortcuts%2F</url>
    <content type="text"><![CDATA[上一篇讲到了Android 7.1的预览版发布，今天这篇来说说其中的App Shortcut的使用。 Android 7.1允许在你的应用中定义具体动作的快捷键，这些快捷键能够被支持显示到launcher桌面上。比如说Nexus 和Pixel设备上已经提供了这个了。快捷键能让你的用户快速在你的应用中开始一个通用的或者建议的任务。 每一个快捷键引用了一个或者更多的intent,当用户在你的应用中选择了快捷键，每一个都会启动一个具体的动作。你能够表现出来的动作示例包括如下这些： 在一款地图类应用中导航用户去一个特定的位置 在一款社交类应用中发送消息给一个朋友 在一款媒体类应用中播放下一集电视剧 在一款游戏类应用中加载最后一次保存的游戏进度 你能够在你的应用中发布两种不同类型的快捷键： 静态快捷键定义在一个资源文件中，打包到一个APK中，因此，你必须等到你的应用直到更新升级整个应用，才能去改变这些静态快捷键的详细内容。 动态快捷键在运行时使用ShortcutManager API发布，在运行的过程中，你可以去发布、更新、移除它的快捷键。 你能够在你的应用中一个时间里发布5个快捷键（静态快捷键和动态快捷键结合在一起）。用户，然而，能够复制应用的快捷键到launcher桌面上，创建一个固定的快捷键。用户能够在你的应用中创建和访问一个没有限制数量大小的固定快捷键和触发动作。你的应用不能够移除这些快捷键，但是能够禁用它们。 注意： 虽然其他的应用不能够访问在你快捷键中的元数据，launcher桌面它自己能访问这个数据，因此，这些元数据应该隐藏敏感的用户信息。 静态快捷键静态快捷键应该在你的应用内部提供一个链接去生成动作，这些动作应该和你应用的当前版本的生活时间保持一致。对于静态快捷键较好的候选包括查看已发送的信息、设置一个闹钟和显示一个用户一天的锻炼活动。对于创建一个静态的快捷键，完成如下的顺序步骤: 1、在你应用的manifest文件(AndroidManifest.xml)中找到一个activity的intent filtes，action是设置的andorid.intent.action.MAIN并且category是设置的android.intent.category.LAUNCHER 2、添加一个节点到这个activity，引用在应用中定义的快捷键资源文件: 12345678910111213141516171819&lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;!-- 添加如下代码 --&gt; &lt;meta-data android:name="android.app.shortcuts" android:resource="@xml/shortcuts" /&gt; &lt;!--添加如上代码--&gt; &lt;/activity&gt; &lt;/application&gt; 3、创建一个新的资源文件（res/xml/shortcuts.xml）,这个文件就是定义在应用的manifest的快捷键 4、在这个新的资源文件中，添加一个根节点，包含了一个的list集合节点。每一个节点中包含了关于一个静态快捷键的信息，包括它的图标、它的描述、和它在应用内部启动的intent意图: 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shortcuts xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;shortcut android:shortcutId="id0" android:enabled="true" android:icon="@mipmap/ic_launcher" android:shortcutShortLabel="@string/shortcutShortLabel" android:shortcutLongLabel="@string/shortcutLongLabel" android:shortcutDisabledMessage="@string/shortcutDisabledMessage"&gt; &lt;intent android:action="android.intent.action.VIEW" android:targetPackage="com.xw.appshortcuts" android:targetClass="com.xw.appshortcuts.MainActivity" /&gt; &lt;categories android:name="android.shortcut.conversation" /&gt; &lt;/shortcut&gt; &lt;!-- 这里指定更多的快捷键 --&gt;&lt;/shortcuts&gt; 以下是对上面的shortcut标签相关属性的解释： shortcutId, 表示唯一的id enabled, 表示这个shortcut是否可用 shortcutShortLabel, 这里是配置的短名称, 下面还会有长名称, 如果长名称显示不下, 就显示短名称 shortcutLongLabel, 这里是配置的长名称, launcher会优先选择长名称显示 shortcutDisabledMessage, 这个配置是在我们选择一个不可用的shortcut时给用户的一个提示 动态快捷键动态的快捷应该在你的应用内部提供一个具体的链接，上下文敏感动作。这些动作能够在用户使用你的应用中进行改变，并且他们甚至能够在当你的应用运行的时候进行改变。对于动态快捷键较好的候选包括打电话给某一个人、导航到一个固定的位置、和查看一款固定游戏当前的分数。 这个ShortcutManager API允许你完成如下的动态快捷键操作: 发布：使用setDynamicShortcuts(List)去重新定义动态快捷键实体类集合，或者使用addDynamicShortcuts(List)去增加一个已经存在的动态快捷键集合。 更新：使用updateShortcuts(List)方法。 移除：移除一个设置的动态快捷键使用removeDynamicShortcuts(List)，或者使用removeAllDynamicShortcuts()方法去移除所有的动态快捷键。 具体示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.xw.appshortcuts;import android.content.Intent;import android.content.pm.ShortcutInfo;import android.content.pm.ShortcutManager;import android.graphics.drawable.Icon;import android.net.Uri;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = "MainActivity"; private List&lt;ShortcutInfo&gt; shortcutInfos;//快捷键集合 private String[] shortLabel = null;//每个快捷键的短名称 private String[] longLabel = null;//每个快捷键的长名称 private String[] url = null;//每个快捷键的意图跳转域名 private int[] icon = null;//每个快捷键的图标 //============================================ private ShortcutManager shortcutManager = null; private Button setDynamicShortcuts = null;//加载动态快捷键的按钮 private Button disableShortcuts = null;//禁用移除快捷键的按钮 private Button updateShortcuts = null;//更新快捷键的按钮 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; /** * 初始化视图 */ private void initView() &#123; this.updateShortcuts = (Button) findViewById(R.id.updateShortcuts); this.disableShortcuts = (Button) findViewById(R.id.disableShortcuts); this.setDynamicShortcuts = (Button) findViewById(R.id.setDynamicShortcuts); this.updateShortcuts.setOnClickListener(this); this.disableShortcuts.setOnClickListener(this); this.setDynamicShortcuts.setOnClickListener(this); &#125; /** * 初始化数据 */ private void initData() &#123; shortcutManager = getSystemService(ShortcutManager.class); shortLabel = new String[]&#123;"Google", "Youtube", "Facebook", "Twitter"&#125;; longLabel = new String[]&#123;"Open Google", "Open Youtube", "Open Facebook", "Open Twitter"&#125;; url = new String[]&#123;"https://www.google.com/", "https://www.youtube.com/", "https://www.facebook.com/", "https://www.twitter.com/"&#125;; icon = new int[]&#123;R.mipmap.ic_google,R.mipmap.ic_youtube,R.mipmap.ic_facebook,R.mipmap.ic_twitter&#125;; &#125; /** * 设置动态快捷键 */ private void setDynamicShortcuts() &#123; shortcutInfos = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; shortLabel.length; i++) &#123; ShortcutInfo shortcut = new ShortcutInfo.Builder(this, String.valueOf(i)) .setShortLabel(shortLabel[i]) .setLongLabel(longLabel[i]) .setIcon(Icon.createWithResource(this, icon[i])) .setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(url[i]))) .build(); shortcutInfos.add(shortcut); &#125; shortcutManager.setDynamicShortcuts(shortcutInfos); &#125; /** * 禁用并移除快捷键 */ private void disableShortcuts() &#123; List&lt;ShortcutInfo&gt; list = shortcutManager.getPinnedShortcuts(); if (list != null) &#123; for (ShortcutInfo info : list) &#123; //移除下标为0的快捷键 if (info.getId().equals("0")) &#123; shortcutManager.disableShortcuts(Collections.singletonList(info.getId()), "快捷方式已无效,请手动删除"); shortcutManager.removeDynamicShortcuts(Collections.singletonList(info.getId())); &#125; &#125; &#125; &#125; /** * 更新快捷键 * @param index */ private void updateShortcuts(int index) &#123; ShortcutInfo info = new ShortcutInfo.Builder(this, String.valueOf(index)) .setShortLabel("GitHub") .setLongLabel("Open GitHub") .setIcon(Icon.createWithResource(this, R.mipmap.ic_github)) .setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.github.com"))) .build(); shortcutManager.updateShortcuts(Collections.singletonList(info)); &#125; /** * 点击事件 * @param view */ @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.setDynamicShortcuts: setDynamicShortcuts(); break; case R.id.disableShortcuts: disableShortcuts(); break; case R.id.updateShortcuts: updateShortcuts(0); break; default: break; &#125; 运行效果： 动态增加快捷键: (长按图标弹出) (将每一个快捷键拖出来固定到桌面) (固定到桌面的和快捷键集合弹出) 动态更新快捷键: (更新Google为==&gt;GitHub) 动态禁用移除快捷键: (禁用GitHub) 系统代码结构 通过sdk下的hierarchyviewer工具，可以看到长按桌面图标弹出的部分是一个DeepShortcutsContainer,其中包括了一个白色箭头的View和显示每一个快捷键的条目DeepShortcutsView组成。每一个DeepShortcutsView快捷键item又是由一个显示图标的View和一个DeepshortcutsTextView组成。 以上就是简单的对Android 7.1上面App Shortcut方面的概括总结，部分内容源于官方文档，如有不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 7.1</tag>
        <tag>App Shortcuts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现在可用：Android 7.1开发者预览版]]></title>
    <url>%2F2016%2F10%2F20%2Fandroid71-dev-preview-available%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Now available: Android 7.1 Developer Preview 几周以前我们宣布Android 7.1 开发者预览版已经在准备中了。今天你可以通过下载SDK和工具获得这个新的发布。对于获取到7.1发布在你的合格手机上面，你的设备在Android Beta program上注册。如果你的设备已经注册了，你将会收到自动升级。 开发者预览版中有什么？Android 7.1开发者预览版给你一切需要在这个新的平台上测试你的应用，或者使用新的功能特性扩展延伸它，像应用快捷方式和图像键盘的支持。它包括一个升级的SDK和工具、文档和示例，以及模拟器和设备镜像对于运行你的应用在已经支持的设备上。 我们继续使用像在N和更早发布的模型，Android7.1是一个增量升级，这儿有一些不同的亮点： 既然7.1已经在Pixel上面被启动了，我们对于Nexus系列设备在测试质量方面进行最初的开发者预览版传送，我们的目标是梳理出任何设备特定问题。 我们最终新的API版本为API 等级25 我们把应用目标新的API公开发布在Google Play，这样你就可以更新你的应用程序只要你准备好了。 最初的预览版之后，我们计划在11月会传送一个升级，紧接着是最终版公开发布到Android开源项目(AOSP)在12月，最初可以在Nexus 5x,Nexus 6P 和 Pixel C设备上使用，我们将在11月去扩展开发者预览版到其他设备。 为你的应用获取Android 7.1做准备开始，升级到Android Studio 2.2.2并下载API Level 25 platform,emulator system images 和 tools.在Android Studio中通过SDK Manager可以下载最终版本的API Level 25 SDK 可用。 一旦你安装了API Level 25 SDK,你就能够升级的的项目的compileSdkVersion到25去构建和针对这个新版APIs测试.如果你在进行兼容性测试，我们建议你升级你的应用的targetSdkVersion到25去测试你的应用测试禁用的兼容性行为。对于如何去建立你的应用使用API 25 SDK ,看建立预览 如果你添加了应用快捷键或者圆形桌面icon到你的应用，你可以使用Android Studio的 built-in Image Asset Studio 去快速帮你创建不同大小的icons,见Material Design向导 Google APIs模拟器镜像伴随着Android API Level 25的sdk，包括圆形icons的支持和全新Google Pixel 启动器，Google API 系统镜像允许你在支持环形图标的设备上，去测试你的应用的圆形应用图标看上去怎么样。同时，如果你正在开发动态壁纸，你也能够使用新的系统镜像在Android 7.1的模拟器上去测试增强预览版元数据。 对于帮助你添加图像键盘的支持，你能够使用Messager和Google 键盘应用被包括在预览版的系统镜像中去测试，作为它们包括这个新的API的支持。 伴随着API Level 25的SDK，我们也要升级Android Support Library到25.0.0，，这个新的版本让你添加图像键盘的支持向后兼容到API Level 13。它也介绍了BottomNavigationView 小部件，从材料设计想到去实现bottom navigation pattern. 在API Level 25上面的详细检出API diffs和已更新的API refenrence在developer preview site 在Google Play上发布你的应用到alpha,beta或者production通道既然Android 7.1是最终版，你能够发布更新兼容，目标可选，API 25到Google Play.你现在能够发布应用升级，使用API 25到在Google Play Developer Console上你的alpha,beta,或者甚至是production通道。通过这种方式，推送你的应用升级给那些运行在Android 7.1设备上的用户，比如Pixel和Android Beta设备。 在你合格的设备上如何获取Android 7.1开发者预览版如果你已经在Android Beta program注册了,你的合格的设备将会马上收到Android 7.1开发者预览版升级，在你那边不需要做任何操作。如果你还没有在Android Beta上注册，最简单的开始方式是访问android.com/beta,并选择你合格的Android 电话或者平板——你将不久会通过云端收到这个(或者晚点)预览版升级。如果你已经注册的设备并且不想接收到这个升级，仅仅是访问Android Beta和取消注册这个设备。你也能够下载并手动的刷入这个升级 我们欢迎你反馈在开发者问题跟踪、N 开发者预览版社区、或者是Android Beta 社区作为我们工作，朝向在11月的消费者发布。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 7.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[即将到来：Android 7.1 开发者预览版]]></title>
    <url>%2F2016%2F10%2F12%2Fandroid-71-developer-preview%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Coming soon: Android 7.1 Developer Preview 今天，我们包装最终平台版本Android 7.1牛轧糖。你可能在上周的活动中已经先睹为快了。它是依赖于Android 7.0增加升级的，但是对于消费者和开发者来说包含了新的功能特性——从平台对Daydream VR的支持，到A/B系统升级，再到App快捷方式和图像键盘支持。 我们已经一直与设备制造商密切合作，让他们为Android 7.1做准备，接下来我们会给您可以访问此更新，你就可以开始让你的应用做好准备。 本月晚些时候，我们将把Android 7.1平台作为一个开放开发者预览版带给你，类似于我们之前对Android7.0所做的那样。你将能够在这个新的平台上面进行测试和编译，尝试最终功能特性。 和往常一样，我们讲通过Android Beta Program进行开发者预览版的传递，这样使得参与它更加令人难以置信的容易。 在Android 7.1中是什么？Android 7.1提供生产率、安全和Android 7.0的性能、伴随着各种优化和Bug修复、功能特性以及新的APIs(API Level 25) 对于开发者来说，Android 7.1添加了新的功能来帮助你紧密结合的驱动和传递，提高用户的体验，比如： App快捷方式API—— 让你能够直接在Launcher桌面进行按键操作，并带领你的用户瞬间深度的进入你的应用。你能够创建多达5个快捷方式，无论是静态的或是动态的。 圆形应用图标支持—— 让你提供精美漂亮的圆角图标资源，看上去匹配Pixel和其他launcher 增强的动态壁纸元数据—— 让你提供有关您的动态壁纸，以此来作为壁纸预览显示任何选择器的元数据。你能够显示已存在的元数据，比如标签、描述、和作者，还有一个新的上下文URL和标题链接到更多的信息。 Android 7.1也还增加了这些备受开发商要求的功能平台: 图像键盘支持 —— 用户可以从自己的键盘输入的内容，让他们表达自己通过定制贴纸，GIF动画等来扩展内容类型。应用程序可以告诉他们接受什么类型的内容键盘，键盘可以提供所有他们提供给用户的图片和其他内容。对于广泛的兼容性，这个API也将在支持库可用。 存储管理器意图 —— 让一个应用带领用户朝向一个新的设置屏幕去清理没有使用的文件，并释放设备上的存储空间。 对于运营商和呼叫应用，这个平台包括了新的APIs去支持多终端呼叫和新的电话配置选项 (App shortcuts) (Image keyboard support) 让您的应用做好准备Android 7.1是增量升级，但是它是一如既往的重要，确保你的应用看上去和运行都很棒——尤其是当设备已经开始接触到消费者了。 Android 7.1开发者预览版会给你，你需要利用它们的一切新的功能特性去测试你的应用程序或扩展，像快捷方式或者图像键盘。包括新APIs的SDK、编译工具、文档和示例，以及在已经支持的Nexus设备模拟器和设备系统镜像去运行你的应用。我们也将包括一个启动器和支持快捷方式的应用，一个键盘和支持图像键盘的应用。 如果你想自动接收到开发者预览版，访问Android Beta并注册你的设备，如果你的之前注册了一个设备并没有取消注册，你的设备将会收到升级。如果你已经注册了，但是你又不想接收升级，尽快访问Android Beta去取消设备注册。 最初，我们将提供开发者预览版给Nexus 5X, Nexus 6P, and Pixel C 设备，在预览结束扩展到其他支持的设备。在Android 7.1.x平台发布。由于在十二月初，我们将推出更新支持的设备 —— Nexus 6, 5X, 6P, 9, Player, Pixel C,支持 Android One devices —— 以及 Pixel 和 Pixel XL设备。 消费设备即将到来我们正在与我们的伙伴合作，将会在未来的几个月带着Android7.1给生态系统的设备，所以我们建议只要Android 7.1开发者预览版下载可用。测试您的应用程序的兼容性和优化它们,让它们看起来是最好的，比如通过提供圆形的应用程序图标，添加程序快捷方式。 同时，敬请关注，我们会尽快分享关于开发者预览版的更多详细信息！ 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 7.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中使用Nio通道与内存映射]]></title>
    <url>%2F2016%2F10%2F08%2Fandroid-nio-channel-operation-file%2F</url>
    <content type="text"><![CDATA[NIO 是non-blocking的简称，在jdk1.4 里提供的新api 。Sun 官方标榜的特性如下： 为所有的原始类型提供(Buffer)缓存支持。字符集编码解码解决方案。 Channel ：一个新的原始I/O 抽象。 支持锁和内存映射文件的文件访问接口。 提供多路(non-bloking) 非阻塞式的高伸缩性网络I/O 。 在分析公司前辈写的项目，无意中发现了其中使用到了Java nio相关的东西。于是这几天就在学习Java nio，也看了Ron Hitchens著的《Java NIO》这本书。 复制文件先来看一个例子：以复制一个大小为2.5M的apk文件为例。 传统IO的方式 12345678910111213141516171819202122long startTime = System.currentTimeMillis();try &#123; FileInputStream input = new FileInputStream(sourceFile); BufferedInputStream inbuff = new BufferedInputStream(input); FileOutputStream out = new FileOutputStream(targetFile); BufferedOutputStream outbuff = new BufferedOutputStream(out); byte[] b = new byte[1024]; int len = 0; while ((len = inbuff.read(b)) != -1) &#123; outbuff.write(b, 0, len); &#125; outbuff.flush(); outbuff.close(); out.close(); inbuff.close(); input.close();&#125; catch (Exception ex) &#123; ex.printStackTrace();&#125; finally &#123; long endTime = System.currentTimeMillis() - startTime; Log.d(TAG, "传统IO方式：耗时" + endTime + "ms");&#125; 调用，输出： 110-08 21:09:23.970 2575-2575/com.shoewann.demo D/MainActivity: 传统IO方式：耗时94ms 传统IO的方式：耗时94ms NIO通道的方式 12345678910111213141516171819202122long startTime = System.currentTimeMillis();try &#123; //文件(输入、输出) Stream流 FileInputStream fis = new FileInputStream(srcFile); FileOutputStream fos = new FileOutputStream(targetFile); //文件(输入、输出) Channel通道 FileChannel fcIn = fis.getChannel(); FileChannel fcOut = fos.getChannel(); //从文件输入通道传输byte数据到文件输出通道 fcIn.transferTo(0, fcIn.size(), fcOut); //关闭文件(输入、输出) Channel通道 fcOut.close(); fcIn.close(); //关闭文件(输入、输出) Stream流 fos.close(); fis.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; long endTime = System.currentTimeMillis() - startTime; Log.d(TAG, "nio通道方式：耗时" + endTime + "ms");&#125; 调用，输出： 110-08 21:09:26.103 2575-2575/com.shoewann.demo D/MainActivity: nio通道方式：耗时79ms NIO通道的方式：耗时79ms速度比传统IO的方式快，当然比起NIO通道复制，下面的这种内存映射的方式还更快 内存映射的方式 1234567891011121314151617181920212223242526long startTime = System.currentTimeMillis();try &#123; //创建源文件和目标文件的随机访问文件对象 RandomAccessFile raf = new RandomAccessFile(srcFile, "r"); RandomAccessFile wraf = new RandomAccessFile(targetFile, "rw"); //创建文件Channel通道 FileChannel in = raf.getChannel(); FileChannel out = wraf.getChannel(); //源文件的通道大小 long size = in.size(); //内存映射通道 MappedByteBuffer inBf = in.map(FileChannel.MapMode.READ_ONLY, 0, size); //写入到输出通道 out.write(inBf); //关闭输入输出通道 in.close(); out.close(); //关闭随机访问文件对象 raf.close(); wraf.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; long endTime = System.currentTimeMillis() - startTime; Log.d(TAG, "内存映射文件方式：耗时" + endTime + "ms");&#125; 调用，输出： 110-08 21:09:28.168 2575-2575/com.shoewann.demo D/MainActivity: 内存映射文件方式：耗时35ms 内存映射的方式：耗时35ms 通过以上的示例，可以看出对文件进行复制操作，内存映射文件的方式是最快的，nio通道方式仅次其后，传统IO方式相对前面两种较慢。但是，内存映射文件和nio通道的方式都是基于传统IO的方式进行衍生而来。 读文件123456789101112RandomAccessFile rRaf = new RandomAccessFile(file, "r");FileChannel fcIn = rRaf.getChannel();long size = fcIn.size();int len = (int) file.length();byte[] bytes = new byte[len];MappedByteBuffer inBf = fcIn.map(FileChannel.MapMode.READ_ONLY, 0, size); for (int i = 0; i &lt; len; i++) &#123; bytes[i] = inBf.get(i);//取出每个元素&#125;String str = new String(bytes, "utf-8");fcIn.close();rRaf.close(); 写文件123456RandomAccessFile wRaf = new RandomAccessFile(file, "rw");FileChannel fcOut = wRaf.getChannel();//fcOut.position(fc.size()); // 移动到文件末尾，进行追加 fcOut.write(ByteBuffer.wrap(encrypt.getBytes()));fcOut.close();wRaf.close(); 以上就是Android中使用Nio通道与内存映射的示例，如有不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>nio</tag>
        <tag>io</tag>
        <tag>文件读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 7.0 应用之间的文件共享]]></title>
    <url>%2F2016%2F09%2F27%2Fandroid-n-sharing-files-between-apps%2F</url>
    <content type="text"><![CDATA[For apps targeting Android 7.0, the Android framework enforces the StrictMode API policy that prohibits exposing file:// URIs outside your app. If an intent containing a file URI leaves your app, the app fails with a FileUriExposedException exception.To share files between applications, you should send a content:// URI and grant a temporary access permission on the URI. The easiest way to grant this permission is by using the FileProvider class. For more information on permissions and sharing files, see Sharing Files. 以上是官方文档给出的介绍，大致意思也就是: 对于面向 Android N 的应用，Android 框架执行的 StrictMode API 政策禁止向您的应用外公开 file:// URI。 如果一项包含文件 URI 的 Intent 离开您的应用，应用失败，并出现 FileUriExposedException 异常。 若要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。 进行此授权的最简单方式是使用 FileProvider 类。 如需有关权限和共享文件的更多信息，请参阅共享文件。 1234567FileProviderpublic class FileProvider extends ContentProvider java.lang.Object ↳ android.content.ContentProvider ↳ android.support.v4.content.FileProvider 示例我们先来看看以下的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158package com.xw.fileproviderdemo;import android.Manifest;import android.content.Intent;import android.content.pm.PackageManager;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Bundle;import android.os.Environment;import android.provider.MediaStore;import android.support.v4.app.ActivityCompat;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.Toast;import java.io.File;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = "MainActivity"; private android.widget.Button btntakepic; private android.widget.ImageView imgshow; private static final int REQUEST_CODE_TAKE_PHOTO = 0;//拍照请求码 private static final int REQUEST_CODE_CLIP_PHOTO = 1;//裁剪请求码 private File mOutputFile; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); this.imgshow = (ImageView) findViewById(R.id.img_show); this.btntakepic = (Button) findViewById(R.id.btn_take_pic); this.btntakepic.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; Log.d(TAG, "=====onClick====="); switch (v.getId()) &#123; case R.id.btn_take_pic: takePhoto(); break; default: break; &#125; &#125; /*** * 调用相机拍照 */ private void takePhoto() &#123; Log.d(TAG, "=====takePhoto: ====="); /*+++++++针对6.0及其以上系统，读写外置存储权限的检测+++++++++*/ if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED &amp;&amp; ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; // TODO: Consider calling // ActivityCompat#requestPermissions // here to request the missing permissions, and then overriding // public void onRequestPermissionsResult(int requestCode, String[] permissions, // int[] grantResults) // to handle the case where the user grants the permission. See the documentation // for ActivityCompat#requestPermissions for more details. return; &#125; if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123; String sdPath = Environment.getExternalStorageDirectory() .getAbsolutePath(); mOutputFile = new File(sdPath, System.currentTimeMillis() + ".jpg");//拍照之后照片的路径 try &#123; if (!mOutputFile.exists()) &#123; mOutputFile.createNewFile(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Uri uri = Uri.fromFile(mOutputFile);//指定保存拍照后文件的Uri Log.i(TAG, "takePhoto: uri:===" + uri); Intent newIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//设置Action为拍照 newIntent.putExtra(MediaStore.EXTRA_OUTPUT, uri);//将拍取的照片保存到指定Uri startActivityForResult(newIntent, REQUEST_CODE_TAKE_PHOTO); &#125; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); Log.d(TAG, "=====onActivityResult====="); if (requestCode == REQUEST_CODE_TAKE_PHOTO) &#123; onTakePhotoFinished(resultCode, data); &#125; else if (requestCode == REQUEST_CODE_CLIP_PHOTO) &#123; onClipPhotoFinished(resultCode, data); &#125; &#125; /** * 拍照完成 * * @param resultCode * @param data */ private void onTakePhotoFinished(int resultCode, Intent data) &#123; Log.d(TAG, "=====onTakePhotoFinished====="); if (resultCode == RESULT_CANCELED) &#123; Toast.makeText(this, "take photo canceled", Toast.LENGTH_SHORT) .show(); return; &#125; else if (resultCode != RESULT_OK) &#123; Toast.makeText(this, "take photo failed", Toast.LENGTH_SHORT) .show(); &#125; else &#123; /*调用裁剪图片的方法进行裁剪图片*/ clipPhoto(Uri.fromFile(mOutputFile)); &#125; &#125; /** * 裁剪照片 * * @param uri */ private void clipPhoto(Uri uri) &#123; Log.d(TAG, "clipPhoto====&gt;" + uri); Intent intent = new Intent("com.android.camera.action.CROP"); intent.setDataAndType(uri, "image/*"); // 下面这个crop=true是设置在开启的Intent中设置显示的VIEW可裁剪 intent.putExtra("crop", "true"); // aspectX aspectY 是宽高的比例 intent.putExtra("aspectX", 1); intent.putExtra("aspectY", 1); intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); startActivityForResult(intent, REQUEST_CODE_CLIP_PHOTO); &#125; /** * 裁剪照片完成 * * @param resultCode * @param data */ private void onClipPhotoFinished(int resultCode, Intent data) &#123; Log.d(TAG, "=====onClipPhotoFinished====="); if (resultCode == RESULT_CANCELED) &#123; Toast.makeText(this, "clip photo canceled", Toast.LENGTH_SHORT) .show(); return; &#125; else if (resultCode != RESULT_OK) &#123; Toast.makeText(this, "take photo failed", Toast.LENGTH_SHORT) .show(); &#125; Bitmap bm = BitmapFactory.decodeFile(mOutputFile.getAbsolutePath()); imgshow.setImageBitmap(bm); &#125;&#125; 以上示代码通过调用系统的照相机拍照，保存图片到sdcard，并裁剪显示到界面上。我们通过这个示例为代表，来说明本节的内容。 复现问题当然在Android 7.0以下，你依然可以使用上面的代码来实现拍照裁剪显示。但是当你使用的设备是Android 7.0及其以上的时候，使用以上代码，就会抛出开篇所提到的FileUriExposedException异常 android.os.FileUriExposedException:file://…. exposed beyond app through ClipData.Item.getUri() 解决方案定义FileProvider1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.xw.fileproviderdemo"&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.xw.fileproviderdemo.takePhoto.provider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" /&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; 注： exported:必须为false,为true会报安全异常 grantUriPermissions:为true 表示授予该URI临时访问权限 验证可用的文件在res/xml资源目录下创建指定的xml文件 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="images" path="."/&gt;&lt;/paths&gt; 以上代码表示的是：可以访问外部存储目录更目录下的文件，因为拍照后的图片是保存在Environment.getExternalStorageDirectory()下的，也就是,故path的值这里用.号来代表当前的路径，name的值可以自定义。 注： 节点必须包含以下一个或者多个子节点: files-path 代表：Context.getFilesDir(). cache-path 代表：getCacheDir(). extenal-path 代表：Environment.getExternalStorageDirectory(). external-files-path 代表：Context#getExternalFilesDir(String) Context.getExternalFilesDir(null). external-cache-path 代表：Context.getExternalCacheDir(). 给Files生成Content URI1234567891011private void takePhoto() &#123; .... //Uri uri = Uri.fromFile(mOutputFile);//指定保存拍照后文件的Uri /*将file uri的获取方式由fromfile改变为由FileProvider.getUriForFile获取其中Authority应与AndroidManifest定义的保持一致*/ Uri uri= FileProvider.getUriForFile(this, "com.xw.fileproviderdemo.takePhoto.provider", mOutputFile); Log.i(TAG, "takePhoto: uri:===" + uri); Intent newIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//设置Action为拍照 newIntent.putExtra(MediaStore.EXTRA_OUTPUT, uri);//将拍取的照片保存到指定Uri startActivityForResult(newIntent, REQUEST_CODE_TAKE_PHOTO); ....&#125; 以上的代码，将getUriForFile()返回的uri打印出来是:content://com.xw.fileproviderdemo.takePhoto.provider/image/xxxx.jpg 由此可以看出:image:就是xml中的子节点里定义的android:name的值com.xw.fileproviderdemo.takePhoto.provider/image对应的路径就是/storage/emulated/0那么com.xw.fileproviderdemo.takePhoto.provider/image/xxxx.jpg对应的路径就是/storage/emulated/0/xxxx.jpg 通过以上的代码修改，可以解决takePhoto()方法中拍照时的FileUriExposedException异常再次运行项目，可以进行拍照了，拍照完成后，接下来需要进行裁剪，BOOM……Crash…Stop !!!,项目又崩溃了，然后抛出以下的异常： 给URI临时授权同理，抛出的异常和上面takePhoto()一样,都是FileUriExposedException异常 将接收该uri的目的App的PackageName通过grantUriPermission（）函数进行设置,授予读写权限: 12345678910111213141516private void clipPhoto(Uri uri) &#123; Log.d(TAG, "clipPhoto====&gt;" + uri); this.grantUriPermission("com.android.camera", uri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION); Intent intent = new Intent("com.android.camera.action.CROP"); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);//请求URI授权读取 intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);//请求URI授权写入 intent.setDataAndType(uri, "image/*"); // 下面这个crop=true是设置在开启的Intent中设置显示的VIEW可裁剪 intent.putExtra("crop", "true"); // aspectX aspectY 是宽高的比例 intent.putExtra("aspectX", 1); intent.putExtra("aspectY", 1); intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); startActivityForResult(intent, REQUEST_CODE_CLIP_PHOTO);&#125; 同样，调用的时候也将file uri的获取方式由fromfile改变为由FileProvider.getUriForFile获取: 123/*调用裁剪图片的方法进行裁剪图片*/ //clipPhoto(Uri.fromFile(mOutputFile)); clipPhoto(FileProvider.getUriForFile(this, "com.xw.fileproviderdemo.takePhoto.provider", mOutputFile)); 最后，再次运行，所有Exception都解决了，Perfect ～ ! 效果如下： 以上就是简单的对Android 7.0上面权限改变之文件共享方面的概括总结，如有不足，欢迎指正，谢谢]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 7.0</tag>
        <tag>Nougat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展Web技术和Android]]></title>
    <url>%2F2016%2F09%2F22%2FExtending-Web-Technology-with-Android%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Extending Web Technology with Android 纸飞机开始被作为一个简单的想法 —— “如果你能够扔一个纸飞机从一个屏幕到其他屏幕？” 我们概念的核心是将来自全世界的人团结在一起，使用强有力的web —— 一种即时连接到其他的。现代化web技术，特别是JavaScript和OpenGL,在每一个屏幕上使体验更有力量。 纸飞机最初的特色是在2016 Google I/O大会上，在Keynote上连接了参会者和户外的观众长达30分钟。在2016年国际和平日公开启动，我们创建了一个Android Experiment,在Google Play上也是一大特色，充实了现有的web技术和原生的Android Nougat功能，比如当一个飞机在世界的其他地方被抓获，丰富了通知。 介绍当用户添加一个邮编来预先填充它们的位置，创建并且折叠他们自己的飞机。一个简单的扔的手势启动飞机进入虚拟世界，用户访问桌面版网站将会看到它们的飞机进入屏幕飞行。 之后，用户能够检回，并看到他们自己的飞机已经抓住围绕着世界，在飞机上的每一个邮票读起来像一个密码，一个3D地球高亮飞行线路和已经旅行过的距离。 除了标记他们自己的飞机，用户能够手势操作他们的手机，像一个网去抓住一个从其他地方已经抛出的飞机，捏来并拧开它，表明这个地方它已经访问过了。然后他们能够添加他们自己的邮票，然后将它放回群中。 WebView在Google I/0的台上，我们开发的纸飞机运行时范围从50英尺的屏幕跨设备运行，桌面和移动端使用了Web的最新技术。 webGL从程式化的低多边形地球到植绒面,WebGL是采用了渲染3D元素，使之体验更有动力。我们写了自定义GLSL着色器来照亮地球，变形目标作为用户捏来打开或关闭纸时的动画。 Web套接字当用户“扔”一个飞机，一段信息是发送websockets到后端服务器，它被传递到所有的桌面电脑可视化的飞机起飞。 Web工作者飞机群模拟跨越，使用WebWorkers多线程计算每一架飞机的位置，并传达消息返回给主线程使用WebGL呈现出来 要创建的伟大工程，跨平台的体验，我们扩展了Web和原生Android代码，这个能够是我们利用Android中内置Chromium，去使应用程序的视图层与已经存在的网页代码进行深度整合，加入深度整合的操作系统，比如有丰富的通知和后台服务。 如果你对学习更多有关如何桥接WebView和Java代码有兴趣，看看这个GitHub库里的教程 通知Firebase 云端消息（FCM）使用发送推送通知到Android应用上，当一个用户的飞机已经其他人被抓住并扔出去了，一个通知会显示多少个城市和它航行的里程就会发送到这个飞机的FCM创建者设备上。传出通知去管理以确保它们不会过于频繁的发送到设备上。 后台服务我们实现一个后台服务去一天运行一次，对本地存储检查，以确保用户上次访问的应用程序运行。如果一个用户在两周以来都没有去访问过，该应用就会发送一条通知去邀请用户回到应用中去创建一架新的飞机。 网络通讯我们的应用运行在Google云平台的网络服务器上，对于邮票我们利用内置的地理编码头得到接近相似的位置，并套接字.IO流去连接到套接字全部服务器上的所有设备。 用户连接到他们附近的服务器，传达消息到一个单独的主服务器以及任何桌面版计算机观看该区域的经历体验。 往前看这种方法的工作对我们来说非常好，让光滑，跨平台和外形迷人的体验，连接来自全世界的人，扩展web和原生功能已被证明是一个有价值的途径，以提供高品质的体验前进。在Android Experiments网站上你能够学习更多相关的。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 2.2]]></title>
    <url>%2F2016%2F09%2F20%2FAndroid-Studio-2-2%2F</url>
    <content type="text"><![CDATA[原文来自：ByJamal Eason, Product Manager, Android ———— Android Studio 2.2 Android Studio 2.2 今天可以下载使用了。在2016年Google I/O 大会上已经被预览了，Android Studio 2.2是我们IDE最新版，全世界上百万的Android开发者在使用。 增强包装，这个版本有三个主要的主题：速度、智能、和Android 平台支持。利用比如新的Layout Editor（布局编辑器）创建一个应用用户界面更快、更直观，让开发更加快速。我们新的APK analyzer(分析器), 增强布局审查，扩展代码分析让开发更加智能。Intellij的2016.1.3特性以及更多。最后，作为Android应用开发的官方IDE，Android Studio 2.2包括支持在Android7.0中所有的最新版开发者特性，像代码完成去帮助你添加Android平台特性，像多窗口支持、快速设置API，或者重新设计Notification通知。当然，内置的Android Emulator 模拟器去测试所有推出的这些。 在这个版本中，我们改进了Android Frameworks 和 IDE 去创建一个约束布局，新的布局管理器更有力的去帮助你在一个平面上去设计大的和复杂的布局，同时也精简层次。ConstraintLayout像一个标准的Android support library（Android支持库）集成到你的应用中，在利用新的布局编辑器中平行去被构建。 Android Studio 2.2 包括了20+种特性贯穿了在开发过程中的每一个主要阶段：设计、开发、编译&amp;测试，从利用新的ConstraintLayout设计UIs,到利用Android NDK开发C++代码，到利用最新版的Jack编译器去编译，到创建一个Espresso去测试你app中的cases，Android Studio 2.2 升级你一定要去，不要错过了。这儿以下是上面说的一些更多详细的： 设计 布局编辑器 : 创建Android应用用户界面现在是很容易的了，使用全新的用户界面设计器。使用新的蓝图模式和调整每个插件能看到新的属性面板的属性，快速构建你的应用程序用户界面的结构。 约束布局 ：这个新的布局是一个灵活的布局管理器对于你的应用，允许你创建一个动态的用户界面没有嵌套多个布局，向后兼容到Android API Level 9(姜饼)。约束布局工作最好使用在Android 2.2上的全新的布局编辑器。学习更多 开发 提高对C++的支持 :你现在能够是利用CMake 或者 ndk-build从Gradle去编译你的C++项目。从CMake迁移项目编译系统到Android Studio现在是无缝的了。你将也能找到C++支持在全新的wizard项目在Android Studio中，加上了一大批对于C++编辑的bug修复和debug体验，学习更多 示例浏览器 : 使用Android Studio 2.2 引用Android Sample Code 示例代码现在是更容易了，在内置的代码编辑窗口，在Google Android 示例代码找到你应用代码的事件去帮助你跳跃开始你的app应用开发。 编译 即时运行的提高 : 在Android Studio 2.0中介绍了，Instant Run是我们主要的、长期投资的，去使Android开发快速，重量轻。自从推出，它对许多开发者已显著提高编辑、编译、运行、运行周期迭代。在这个版本中，我们已经做了很多的稳定性和可靠性改进Instant Run（即时运行），如果您先前已禁用即时运行，我们建议您重新启用它，让我们知道，如果你遇到进一步的问题。(在Windows/Linux上：Settings → Build, Execution, Deployment → Instant Run , 在OS X 上 ：Preferences → Build, Execution, Deployment → Instant Run). 有关我们所做的修复的详细信息，请参阅Andr​​oid Studio 2.2中发布说明。 APK 分析器 : 很简单的检查你的APK的内容，去了解每个组件的大小贡献。当你调试到mult-dex这个特性能对你有帮助，另外，利用APK分析器你能够比较一个APK的两个版本.学习更多 构建缓存(试验性) ：我们将继续我们的投资，以提高构建速度，推出了新的实验构建的缓存，这将有助于减少双方完全和增量构建时间。只需添加android.enableBuildCache =true 到你的gradle.properties文件中。学习更多 测试 Android 模拟器中的虚拟传感器：Android 模拟器现在包括了一个新的组是虚拟传感器控制，利用新的UI控制，你现在能够测试Android 传感器 比如加速度、温度、磁力仪等等更多。学习更多 Espresso 测试记录器(Beta) :该Espresso测试记录器以让你轻松通过记录与您的应用程序创建交互UI测试;它然后将会为你输出UI测试代码.你记录你和一个设备互动，然后，添加树到你应用特殊快照中的验证UI节点上，Espresso记录器然后就会保存记录，并进行自动化生成一个对应的UI测试。你能够在本地运行测试、在持续集成服务器上、或者是使用Firebase Test Lab for Android,学习更多 GPU 调试器(Beta) : 该GPU调试器现在还在Beta阶段，对于分析你现在能够在你的Android 设备上捕捉OpenGL ES指令流，然后从Android Studio里面回复它。你也能够完全审查给予任意OpenGL ES指令流的GPU的状态，去更好的理解和调试你的图形输出。学习更多 总的来说，Android Studio 2.2包括主要的特性和更多的： 设计： 布局编辑器 约束布局 布局审查器(试验性) 在Vector Asset Studio中支持PSD文件 开发 ： Firebase插件 升级代码分析&amp;Lint检查 加强无障碍支持 提高C++编辑支持&amp;调试 Itellij2016.1.3平台升级 示例浏览器 提高字体渲染 编译 ： Jack编译器改进 Java8语言支持 C++ ndk-build 或者CMake 合并Manifest视图器 编译缓存(试验性) OpenJdk支持 Instant Run即使运行改进 测试： Espresso 测试记录器 APK分析器 GPU调试器(试验性) 模拟器虚拟传感器 学习更多有关Android Studio 2.2通过重新查看发布说明和预览博客文章 开始获取下载如果你有上一个版本的Android Studio，你能够在菜单导航栏(Help → Check for Update (Windows/Linux系统) , Android Studio → Check for Updates (OS X系统))正式版渠道上检查更新,你也能够从官方下载页面进行下载，去获取Android Studio所有的新功能和改进,你应该也会升级Android Gradle 插件版本到2.2.0在你当前的app项目中。 以上是对Anroid 官网博客文章的部分翻译，如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 7.0 Nougat 最后的包装关闭]]></title>
    <url>%2F2016%2F08%2F23%2Ftaking-final-wrapper-off-of-nougat%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Taking the final wrapper off of Android 7.0 Nougat 今天，Android 7.0牛轧糖将会开始推出给用户，从Nexus设备开始。在同一时间，我们推送了Android 7.0源码到Android开源项目(AOSP),这个新版本的Android延长公开可用性到更广泛的生态系统。 在这个正式版上我们和你在过去的几个月中一起努力，获得你们的反馈，同时也确保你的应用程序已经准备好运行在这些用户的牛轧糖设备上 牛轧糖里面是什么Android 牛轧糖反映全世界成千上万粉丝和开发人员喜欢你的输入，在Android 牛轧糖中超过了250种基本功能特性，包括Android中的VR模式 ，在牛轧糖中，我们已经在Android栈的所有层面工作————从操作系统是如何读取传感器数据到如何发送像素到显示————到特别内置到提供高质量的移动VR体验 牛轧糖带你了一大批新特性，以帮助使Android功能更强大，更高效，更安全。它介绍了一个新的JIT/AOT编译器来提高软件性能，确保应用安装的更快，占用更少的存储空间。它也添加了对Vulkan平台的支持，一个低开销，高性能跨平台的API，3D图形。多窗口的支持让用户能够在同一时间运行两个应用。直接回复能让用户不用打开应用程序，直接在通知栏上回复。一如既往，Android的构建利用强大的安全层和加密去保护你的私有数据私有，因此牛轧糖引入了一些新的特性像基于文件的加密、无缝更新和直接启动 你能够在牛轧糖开发者资源这里找到所有，包括在行为改变和在你的应用中你能够使用的新特性的详细介绍。对于开发者有什么新的概述是可以使用在这里 ,你能够在这里探索牛轧糖里对于新用户的特性。 下一波用户从今天开始和接下来几周的推出，Nexus 6, Nexus 5X, Nexus 6P, Nexus 9, Nexus Player, Pixel C, and General Mobile 4G (Android One) 将会获得一个Android 7.0牛轧糖云端软件的升级。包括即将来到的LG V20 将会成为市面上第一个使用Android牛轧糖的新智能手机，开箱的。 所有的这些新设备开始运行牛轧糖，现在是发布你新的应用升级到Google Play的时候了，我们建议理想的编译目标API24。如果你是一直测试最后几分钟的变化，一个伟大的战略是使用Google Play’s beta testing feature从一个小组用户去获得尽早的反馈——包括使Android7.0牛轧糖——做一个分阶段发布，发布更新后的应用给所有用户。 对于牛轧糖接下来是什么？我们已经移动牛轧糖到一个新的定期维护计划，在未来几个季度。实际上，我们已经在第一个牛轧糖版本开始维护工作，这将带来持续的改进和润色，我们打算今年秋天把那个给你作为一个开发者预览版。敬请关注！ 我们将很快关闭对开发者开放的错误预览版记录，但是请保持反馈！如果你仍然看到有问题， 你在预览版跟踪器提交，只是文件新问题对Android 7的AOSP问题跟踪器。 感谢您成为预览的一部分,这是我们在今年早些时候分享了an eye towards giving everyone the opportunity，使下一个版本的Android更强大。您继续反馈是非常有益的在塑造这个最终版本，不是为了某一个用户，而是为了整个Android生态圈。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 7.0</tag>
        <tag>Nougat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter开发之入门篇]]></title>
    <url>%2F2016%2F08%2F18%2FFlutter-get-started%2F</url>
    <content type="text"><![CDATA[上一节对于Flutter环境搭建的学习，本节向导将会快速的描述在ios或者Android上创建和运行你的第一个Flutter应用 开始之前对于写一个Flutter应用，你将需要安装好Flutter SDK。同时你也需要设置一个Linux或者Mac开发机器去在Android 或者ios上运行和测试你的应用。见Flutter搭建篇将会描述如何搭建你的开发环境的 创建你的第一个Flutter应用对于创建一个开始的项目，打开terminal终端，然后运行flutter命令这儿是一个示例 1$ flutter create myapp 以上的命令创建一个Flutter项目目录，被叫做myapp，它包含了一个简单的示例，使用了Material Design在这个项目的目录中，对于你的app代码是在myapp/lib/main.dart 运行你的Flutter应用使用flutter run命令运行你的Flutter应用到你已经连接成功的所有设备或者模拟器(flutter devices命令将会列出你已经连接成功的设备或者模拟器) 对于从命令行运行你的应用：1、打开一个teminal终端,并改变它的目录到你的app根目录下(对于你的项目，这个相同的目录下包含了一个pubspec.yaml文件)2、运行如下命令: 1$ flutter run 另外，如果你是使用的Atom editor和Flutter package,你能够通过选择在项目lib/main.dart中的文件，然后在主界面上点击运行app的快捷键开始你的Flutter应用。快捷键依赖于你使用的开发机器的操作系统: Linux Ctrl+R Mac Command+R 如果程序能正常工作，你应该能看到你的应用已经在你的设备或者模拟器上面启动起来了 iOS (iPhone 6s Plus) Android (Nexus 6) 以上操作就完成了Flutter的入门操作 以上部分具体内容来源Flutter官网，对其译文并扩展，如有不足，欢迎指正。]]></content>
      <categories>
        <category>Dart</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter开发之搭建篇]]></title>
    <url>%2F2016%2F08%2F17%2FFlutter-setup%2F</url>
    <content type="text"><![CDATA[Google的Git源码库出现了一种新的开源操作系统叫Fuchsia,该系统的UI用户界面层使用的是Dart语言开发的Flutter，渲染器是Escher，应用程序框架是Mojo。那么我们先来了解一下这个Flutter Flutter，是一个帮助开发者从一个单一的代码库，去构建ios和Android上高性能、高保真的移动设备应用新项目。 本节向导将描述如何搭建你的开发环境，在ios或者Android上运行Flutter应用 系统要求要安装和运行Flutter，你的开发环境必须满足这些最低要求： 操作系统：Mac或者Linux(64位).Windows已加入支持计划 工具：Flutter在你的环境中依靠这些命令行工具才可以使用.bash,mkdir,rm,git,curl,unzip 获取 Flutter SDK对于获取Flutter,使用git去clone仓库，然后添加flutter工具到你的path： 12$ git clone https://github.com/flutter/flutter.git -b alpha$ export PATH=`pwd`/flutter/bin:$PATH 运行以下命令来看看是否有您需要安装完成设置任何依赖关系： 1$ flutter doctor 在第一次运行flutter命令的时候,它将会下载它的依赖并且自己编译，后续运行的时候应该会快 一旦你已经安装任何缺少的依赖，再一次运行flutter doctor命令，来验证是否已正确设置一切。 Google Analytics（分析）Flutter 工具使用了Google Analytics进行使用情况的数据统计报告功能和基本崩溃报。随着时间的推移，这些数据能够帮助提高Flutter工具。为了禁用报告，在终端输入flutter config --no-analytics，对于要显示出当前analytics分析报告的状态，在终端输入flutter config Analytics是不会在最初的运行或任何涉及flutter config运行去发送。这让用户选择退出分析，而不发送任何数据。见Google的隐私政策https://www.google.com/intl/en/policies/privacy/ ios环境设置这步是可选的，对于在ios中使用Flutter开发之前，在任何时间都是可以被执行的对于在ios上开发Flutter应用，你需要一个带有Xcode7.2或者更高版本的Mac设备： 1.安装Xcode7.2或者更高版本(来源网页下载或者Mac App Store) 2.确保Xcode EULA是通过通过任一开放一次的Xcode签名了并且确认了，或者从命令行运行sudo xcodebuild -license 利用Xcode，你将能够在一个IOS设备上或者在一个模拟器上运行Flutter应用 建立ios模拟器对于准备在ios模拟器运行和测试你的Flutter，如下步骤：1、在你的Mac，找到来源于Spotlight的模拟器，或者通过使用以下命令： $ open -a Simulator2、确保你的模拟器是使用的一个64位的设备（iphone5s或者之后的版本），通过在模拟器的Hardware&gt;Device菜单中检查设置。 3、依赖于的你的机器屏幕大小进行开发，根据开发该机的屏幕尺寸，模拟高密度的ios设备可能会溢出屏幕，在模拟器中设置设备的缩放，在Window下&gt;Scale菜单中。 部署到ios设备对于部署你的Flutter应用到一个物理的ios设备，你将需要一些额外的工具： 1、安装homebrew 2、打开终端。对于在ios设备上部署Flutter应用，运行这些命令去安装工具。 12$ brew tap flutter/flutter$ brew install ideviceinstaller ios-deploy 您还需要建立一个供应配置文件为您的开发者账户。要了解如何设置您的个人资料,请查阅 Apple’s official documentation Android环境设置这步是可选的，对于在Android中使用Flutter开发之前，在任何时间都是可以被执行的对于在Android上开发Flutter应用，你能够使用一个Mac或者一个linux(64位)的机器： 1、安装Android Studio2、Android Studio，安装最新版的Android SDK和Android SDK Platform-Tools，如Adding SDK Packages所述 设置你的Android设备对于准备在Android上运行和测试你的Flutter应用，你将需要一个运行在Android4.1(API level 16)或者更高的Andoid设备1、开启开发者模式在你的设备，通过访问设置 &gt; 关于手机，点击版本号行7次2、在 设置 &gt; 开发者选项，开启USB3、使用USB数据线将手机和电脑连接在一起，如果在你的设备上提示了，授权你的电脑访问你的设备4、在终端运行flutter devices命令验证Flutter识别到你已经连接的Android设备 默认情况下，Flutter使用的adb工具和Android SDK版本是依赖的。如果你先Flutter使用一个不同版本安装的Android SDK,你必须设置ANDROID_HOME到你的环境变量是具体的安装目录。 Atom 编辑器我们建议使用Atom进行编辑，运行，和调试Flutter应用。然后，使用我们命令行工具，你能够使用任你可以用任何编辑器来开发Flutter应用对于安装Atom：1、从atom.io站点下载Atom2、从下载文件进行解压，并执行Atom 配置Atom开发环境在你在A创建你的Flutter项目之前，你将需要执行这些起飞前的任务：1、启动Atom编辑器2、通过以下这些步骤安装Flutter package: 从菜单栏，打开Packages &gt; Settings View &gt; Install Packages/Themes 在Install Packages区域，输入flutter并且点击Packages按钮 你应该能看到Flutter包已经显示出来了，点击按钮进行安装这个包 3、打开Packages &gt; Flutter &gt; Packages Settings，设置FLUTTER_ROOT区域为你安装Flutter SDK的根目录的路径 4、打开Packages &gt; Dart &gt; Packages Settings，设置Dart SDK Location 区域为你Flutter SDK的根文件夹bin/cache/dart-sdk目录的路径 5、如果你在Mac上使用Atom，你应该安装atom和apmshell命令。从菜单栏这样操作，点击Atom&gt;Install Shell Commands 以上操作就完成了Flutter的环境搭建操作，下一篇来学习Flutter入门 以上部分具体内容来源Flutter官网，对其译文并扩展，如有不足，欢迎指正。]]></content>
      <categories>
        <category>Dart</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design组件之Bottom sheets]]></title>
    <url>%2F2016%2F08%2F02%2FMaterial-Design-Bottom-sheets%2F</url>
    <content type="text"><![CDATA[Google Material Design之Bottom Sheet文档 本节介绍Material Design中的组件之一Bottom Sheet 如何添加？1、在你的builde.gradle文件中，添加最新版的appcompat和design依赖库. 1234dependencies &#123; compile 'com.android.support:appcompat-v7:X.X.X' //这里的X.X.X代表版本 compile 'com.android.support.design:X.X.X'//这里的X.X.X代表版本&#125; 2、设置app:layout_behavior属性的值@string/bottom_sheet_behavior,将允许你的View或者ViewGroup作为一个bottom Sheet展现出来 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="300dp" android:orientation="vertical" android:padding="16dp" app:layout_behavior="@string/bottom_sheet_behavior"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Dandelion Chocolate" android:textAppearance="@style/TextAppearance.AppCompat.Display1" android:textColor="@android:color/black"/&gt;&lt;/LinearLayout&gt; 提示：你能够使用behavior_peekHeight属性设置bottom sheet的默认高度3、添加你的视图作为直接为CoordinatorLayout的一个孩子，实现bottom sheet的特性 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" &gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appbarLayout" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" &gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/appbar" android:layout_height="?attr/actionBarSize" android:layout_width="match_parent" android:minHeight="?attr/actionBarSize" android:background="?attr/colorPrimary" app:elevation="4dp" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" &gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!-- Your content --&gt; &lt;include layout="@layout/content_main" /&gt; &lt;!-- Bottom Sheet --&gt; &lt;include layout="@layout/bottom_sheets_main" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 提示：你能够在&lt;include&gt;节点下包裹你的View或者ViewGroups,为了保持整理你的布局。请记住，bottom sheet中的滑动容器（scrolling container）必须支持嵌套滑动（比如 NestedScrollView, RecyclerView, 或者API 21以下的ListView/ScrollView）。 4、根据一个视图有着底部特性设置的引用来获得一个BottomSheetBehavior的引用，使用BottomSheetBehavior里的from方法 1234567891011121314151617LinearLayout bottomSheetViewgroup = (LinearLayout) findViewById(R.id.bottom_sheet);BottomSheetBehavior bottomSheetBehavior = BottomSheetBehavior.from(bottomSheetViewgroup);//如果你想接收状态改变的回调，可以加一个BottomSheetCallbackbottomSheetBehavior.setBottomSheetCallback(new BottomSheetCallback() &#123; @Override public void onStateChanged(@NonNull View bottomSheet, int newState) &#123; // React to state change &#125; @Override public void onSlide(@NonNull View bottomSheet, float slideOffset) &#123; // React to dragging events &#125; &#125;); 5、对于展开你的bottom sheet使用setState方法并传递参数BottomSheetBehavior.STATE_EXPANDED 1bottomSheetBehavior.setState(BottomSheetBehavior.STATE_EXPANDED); 提示：你能够处理来源于setState方法的这些状态： STATE_COLLAPSED： 默认的折叠状态， bottom sheets只在底部显示一部分布局。显示高度可以通过 app:behavior_peekHeight 设置（默认是0） STATE_DRAGGING ： 过渡状态，此时用户正在向上或者向下拖动bottom sheet STATE_SETTLING: 视图从脱离手指自由滑动到最终停下的这一小段时间 STATE_EXPANDED： bottom sheet 处于完全展开的状态：当bottom sheet的高度低于CoordinatorLayout容器时，整个bottom sheet都可见；或者CoordinatorLayout容器已经被bottom sheet填满。 STATE_HIDDEN ： 默认无此状态（可通过app:behavior_hideable 启用此状态），启用后用户将能通过向下滑动完全隐藏 bottom sheet Modal bottom sheets BottomSheetDialog创建一个BottomSheetDialog,例如： 123456789BottomSheetDialog dialog = new BottomSheetDialog(context);View view = LayoutInflater.from(context).inflate(R.layout.bottom_sheet_list, null);RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.bottom_sheet_recycler_view);recyclerView.setLayoutManager(new LinearLayoutManager(context));recyclerView.setAdapter(new SimpleAdapter());dialog.setContentView(view);dialog.show(); BottomSheetDialogFragment1、创建一个类继承BottomSheetDialogFragmentinflated一个布局，将会作为你的Modal bottom Sheet的内容而被使用 1234567891011121314151617public class ModalBottomSheet extends BottomSheetDialogFragment &#123; static BottomSheetDialogFragment newInstance() &#123; return new BottomSheetDialogFragment(); &#125; @Override public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View v = inflater.inflate( R.layout.bottom_sheet_modal, container, false); return v; &#125;&#125; 2、创建一个你的modal bottom sheet实例并且使用它的show方法去显示，需要传递的参数是一个SupportFragmentManager和一个String. 12ModalBottomSheet modalBottomSheet = new ModalBottomSheet();modalBottomSheet.show(getSupportFragmentManager(), "bottom sheet");]]></content>
      <categories>
        <category>Android</category>
        <category>Material Design</category>
      </categories>
      <tags>
        <tag>Bottom Sheets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design组件之Buttons]]></title>
    <url>%2F2016%2F08%2F01%2FMaterial-Design-Components-Buttons%2F</url>
    <content type="text"><![CDATA[Google Material Design之Buttons文档 本节介绍Material Design中的组件之一Buttons,包含3中Button的简单添加和使用，它们分别是Floating Action Button、Raised Button以及Flat Button Floating Action Button 如何添加？1、在你的builde.gradle文件中，添加最新版的appcompat和design依赖库. 1234dependencies &#123; compile 'com.android.support:appcompat-v7:X.X.X' //这里的X.X.X代表版本 compile 'com.android.support.design:X.X.X'//这里的X.X.X代表版本&#125; 2、确保你的Activity继承了android.support.v7.app.AppCompatActivity. 123public class MainActivity extends AppCompatActivity&#123; ...&#125; 3、在layout.xml文件里的任意位置定义你的FloatActionButton. 1234&lt;android.support.design.widget.FloatActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/ic_fab"&gt; 如何设置Style? 背景颜色1、在你的values/style.xml中自定义style. 123&lt;style name="MyFloatActionButton" parents="Theme.Appcompat.Light"&gt; &lt;item name="colorAccent"&gt;@drawable/pink&lt;/item&gt;&lt;/style&gt; 2、使用android:theme应用这个style到FloatActionButton 12345&lt;android.support.design.widget.FloatActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/ic_fab" android:theme="@style/MyFloatActionButton"&gt; 水波纹颜色当你按压FloatActionButton使用app:rippleColor去改变颜色达到水波纹的效果 1234&lt;android.support.design.widget.FloatActionButton android:layout_widget="wrap_content" android:layout_height="wrap_content" app:rippleColor="@color/ripple"&gt; 图标对于改变FloatActionButton的图标使用android:src属性 1234&lt;android.support.design.widget.FloatActionButton android:layout_widget="wrap_content" android:layout_height="wrap_content" android:src="@drawable/ic_myicon"&gt; 大小对于改变FloatActionButton图标的大小使用app:fabSize属性，使用一个预先系统设置的常量mini或者normal 12345&lt;android.support.design.widget.FloatActionButton android:layout_widget="wrap_content" android:layout_height="wrap_content" android:src="@drawable/ic_mini" app:fabSize="mini"&gt; Raised Button 如何添加？1、在你的builde.gradle文件中，添加最新版的appcompat依赖库. 123dependencies &#123; compile 'com.android.support:appcompat-v7:X.X.X' //这里的X.X.X代表版本&#125; 2、确保你的Activity继承了android.support.v7.app.AppCompatActivity. 123public class MainActivity extends AppCompatActivity&#123; ...&#125; 3、在layout.xml文件里的任意位置定义你的Button. 1234&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button"/&gt; 如何设置Style?1、在你的values/style.xml中自定义style. 1234&lt;style name="MyButton" parent="Theme.AppCompat.Light"&gt; &lt;item name="colorControlHighlight"&gt;@color/indigo&lt;/item&gt; &lt;item name="colorButtonNormal"&gt;@color/pink&lt;/item&gt;&lt;/style&gt; 2、使用android:theme应用这个style到Button 12345&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button" android:theme="@style/MyButton"/&gt; 兼容性问题1、你能够使用colorControlHighlight这个属性去改变Button在按压时候的颜色，然后它将只有Android版本至少是Lolipop才会生效。2、Androidelevation属性只有在Lolipop的设备才会可以用，在Lolipop之前的设备你将看不到Button四周的shadow(阴影) Flat Button 如何添加？1、在你的builde.gradle文件中，添加最新版的appcompat依赖库. 123dependencies &#123; compile 'com.android.support:appcompat-v7:X.X.X' //这里的X.X.X代表版本&#125; 2、确保你的Activity继承了android.support.v7.app.AppCompatActivity. 123public class MainActivity extends AppCompatActivity&#123; ...&#125; 3、在layout.xml文件里的任意位置定义你的Button,并使用Borderless的style. 12345&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button" style="@style/Widget.AppCompat.Button.Borderless"/&gt; 如何设置Style? 1、在你的values/style.xml中自定义style. 123&lt;style name="MyButton" parent="Theme.AppCompat.Light"&gt; &lt;item name="colorControlHighlight"&gt;@color/indigo&lt;/item&gt;&lt;/style&gt; 2、使用android:theme应用这个style到Button 123456&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button" android:theme="@style/MyButton" style="@style/Widget.AppCompat.Button.Borderless"&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>Material Design</category>
      </categories>
      <tags>
        <tag>Floating Action Button</tag>
        <tag>Raised Button</tag>
        <tag>Flat Button</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中使用兼容库创建Vector Drawable]]></title>
    <url>%2F2016%2F07%2F31%2Fandroid-vector-drawable-example-using-appcompat-support-library%2F</url>
    <content type="text"><![CDATA[随着Android应用程序兼容性支持库v23.2的新版本到来，它的一些特性也向后兼容并且增加了一些新功能。随着Android Lolipop（API 21）的发布，一个新的组件被包括进来，它被叫做矢量绘制对象。但是这个组件仅仅能在API21+上使用，现在的Androidy应用程序兼容性支持库v23.2矢量绘制对象的到来，可以为可绘制性提供强大的向后兼容性，可兼容API7+设备。 什么是 Vector Drawable ？正如它的名字所暗示的那样，Vector Drawable基于矢量图像。相对于光栅图形，矢量图形是描述使用几何形状图形元素的一种方式，它类似于SVG文件。在Vector Drawable中它是利用XML文件被创建出来。在Vector Drawable添加到Android SDK之前，开发者对于不同的显示分辨率必须创建多个版本的图像，这需要花费时间创建额外的asstes，并且消耗更多的空间，以致于增大apk文件的大小。如今这里不需要为mdpi,hdpi,xhdpi等等设计不同大小的图像，利用Vector Drawable你只需要创建图像仅仅一次作为一个XML文件，你将能够对于所有显示分辨率和不同的设备进行缩放。 如何使用Vector Drawable ？升级builde.gradle 文件在你项目中能够使用Vector Drawable之前，你需要添加兼容行代码到你的build.gradle文件下Gradle depencies模块中(以下版本必须满足v23.2+)然后重新编译一下项目 1234dependencies &#123; ... compile 'com.android.support:appcompat-v7:23.2.1'&#125; 如果你是使用的Gradle plugin插件版本在2.0或者及其以上，请添加以下代码： 123456// Gradle Plugin 2.0+ android &#123; defaultConfig &#123; vectorDrawables.useSupportLibrary = true &#125; &#125; 如果你是使用的Gradle plugin插件版本在1.5或者及其以下，请添加以下代码： 12345678910// Gradle Plugin 1.5 android &#123; defaultConfig &#123; generatedDensities = [] &#125; // This is handled for you by the 2.0+ Gradle Plugin aaptOptions &#123; additionalParameters "--no-version-vectors" &#125; 我当前的Android Studio是 2.2 priview 6: 创建Vector Drawable创建Vector Assets目录在你的Android Studio中选中drawable文件夹&gt;右键点击&gt;new&gt;Vector Assets Vector Asset Studio Tool现在Vector Asset Studio 工具窗口会出现 创建Vector drawable xml创建Vector drawable xml 文件有两种方式:默认的Material 图标、加载本地SVG文件 Material 图标选择Material图标选项，然后点击icon,它将会出现一个选择icon的窗口，在这里你可以选择任意一个你期望的图标。我这里选择了一个定位的图标，点击OK 这个窗口显示了刚刚选择的图标进行预览，我默认设置它的size为24x24dp,现在点击下一步 这个窗口运行你设置目标Module和Res目录(可以选择debug或者release其中一种)，配置完成后点击Finish完成 以下就是上面过程的结果，将会在drawable文件夹中生成Vector drawable ic_location_on_black_24dp.xml 加载本地SVG文件选择Local SVG File，然后点击下面的path，弹出一个新的窗口，选择本地svg 文件。 这个窗口显示了刚刚导入的SVG图标进行预览，我默认设置它的size为24x24dp,现在点击下一步 这个窗口运行你设置目标Module和Res目录(可以选择debug或者release其中一种)，配置完成后点击Finish完成 以下就是上面过程的结果，将会在drawable文件夹中生成Vector drawable ic_dollar.xml 修改strings.xml添加以下string values到res =&gt; values =&gt; strings.xml 12345&lt;resources&gt; &lt;string name="material_icon"&gt;Material Icon&lt;/string&gt; &lt;string name="svg_file_icon"&gt;Local SVG File Icon&lt;/string&gt; &lt;string name="dynamic_icon"&gt;Vector Image Dynamic Icon&lt;/string&gt;&lt;/resources&gt; 修改layout.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.shoewann.myapplication.MainActivity"&gt; &lt;TextView android:id="@+id/tv_material_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:gravity="center_vertical" android:text="@string/material_icon" android:textColor="@android:color/black" android:textSize="25sp" app:layout_constraintLeft_toLeftOf="@+id/activity_main" app:layout_constraintRight_toRightOf="@+id/activity_main" app:layout_constraintTop_toTopOf="@+id/activity_main" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" /&gt; &lt;ImageView android:id="@+id/ic_location" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:contentDescription="" android:gravity="center_vertical" app:layout_constraintLeft_toLeftOf="@+id/tv_material_icon" app:layout_constraintRight_toRightOf="@+id/tv_material_icon" app:layout_constraintTop_toBottomOf="@+id/tv_material_icon" app:srcCompat="@drawable/ic_location_on_black_24dp" tools:ignore="ContentDescription" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" /&gt; &lt;TextView android:id="@+id/tv_svg_file_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:gravity="center_vertical" android:text="@string/svg_file_icon" android:textColor="@android:color/black" android:textSize="25sp" app:layout_constraintLeft_toLeftOf="@+id/activity_main" app:layout_constraintRight_toRightOf="@+id/activity_main" app:layout_constraintTop_toBottomOf="@+id/ic_location" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" /&gt; &lt;ImageView android:id="@+id/ic_dollar" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:contentDescription="" android:gravity="center_vertical" app:layout_constraintLeft_toLeftOf="@+id/ic_location" app:layout_constraintRight_toRightOf="@+id/ic_location" app:layout_constraintTop_toBottomOf="@+id/tv_svg_file_icon" app:srcCompat="@drawable/ic_dollar" tools:ignore="ContentDescription" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" /&gt; &lt;TextView android:id="@+id/tv_dynamic_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:gravity="center_vertical" android:text="@string/dynamic_icon" android:textColor="@android:color/black" android:textSize="25sp" app:layout_constraintLeft_toLeftOf="@+id/activity_main" app:layout_constraintRight_toRightOf="@+id/activity_main" app:layout_constraintTop_toBottomOf="@+id/ic_dollar" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" /&gt; &lt;ImageView android:id="@+id/dynamic_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:gravity="center_vertical" app:layout_constraintLeft_toLeftOf="@+id/tv_dynamic_icon" app:layout_constraintRight_toRightOf="@+id/tv_dynamic_icon" app:layout_constraintTop_toBottomOf="@+id/tv_dynamic_icon" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" tools:ignore="ContentDescription" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 修改 MainActivity.java 123456789101112131415161718package com.example.shoewann.myapplication;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.widget.ImageView;public class MainActivity extends AppCompatActivity &#123; private android.widget.ImageView dynamicicon; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); this.dynamicicon = (ImageView) findViewById(R.id.dynamic_icon); this.dynamicicon.setImageResource(R.drawable.ic_dollar); &#125;&#125; 运行效果]]></content>
      <categories>
        <category>Android</category>
        <category>Android Developer</category>
        <category>Vector Drawable</category>
      </categories>
      <tags>
        <tag>Vector Drawable</tag>
        <tag>Android Support Library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化之Traceview]]></title>
    <url>%2F2016%2F07%2F30%2FAndroid-Performance-Part-Of-Traceview%2F</url>
    <content type="text"><![CDATA[上次学习总结了《Android性能优化之渲染篇》，间隔两个月了，今天抽空先简要的学习总结下第二篇部分内容，好了，废话不多说了。 为了优化你的代码，你需要理解系统如何运行代码。 缓慢的性能缓慢的函数执行通常是由于两方面的问题造成的：1、执行速度很慢的函数，这种函数很容易被发现，你的某些函数所花费的时间超过你的预期2倍、10倍数，甚至50倍。这种情况只要找到那些运行很慢的函数,查看代码，找到问题的所在，然后想办法解决就可以了。 2、更难发现的是第二种类型，想方设法都难以发现，每个函数所用的时间都额外增加了一毫秒，从而导致整个程序执行速度变慢数百毫秒。而且更难以解决，需要对每段细小的地方进行分析，这样可能会导致进度缓慢，影响效率。不过SDK有一些很不错的工具，帮助你找到这些有问题的代码部分。 Traceview 演练工具:Traceview 首先连接设备，然后启动想要分析的应用程序，然后回到Android Studio,启动Android Device Monitor(菜单栏Tools&gt;Android&gt;Android Device Monitor) 在左边的Devices窗格下，找到已经连接好的设备。 选择需要分析的应用活动。然后会在顶部有一些图标会亮，尤其是看上去像是三面的箭头，上面有一个红色的圆点。点击这个会提示开始进行方法分析，这就是Traceview的启动方法。 我们点击它会出现一个弹出窗口，提示会有两种方法来分析你的应用程序，你可以记录每个方法的输入和输出，它们对资源的要求很高，或者，你也利用示例代码进行一些分析。默认情况下分析程序将会没毫秒侦测一次你的应用程序，以发现和记录实际上在运行的功能，我们默认继续开始侦测，然后回到应用进行交互。 我们在对应用进行交互好了之后，同样再次点击刚刚带红点的三面箭头图标，只不过它现在不是红色的点，而是黑色的图标或者黑色的小方块，点击它停止Traceview侦测，然后再右边你将会看到跟踪记录的视图。 跟踪视图有两个主要的组成部分： 上方的窗体名称是typeline面板， 下方内有很多的信息，成为profile面板，这个时间线能够很好的现实代码的执行情况。 上边的每一行实际对应你一个线程，显示的每一个颜色，对应一个正在运行的特定方法。可以查看一个线程的开始时间和结束时间，还可以支持放大的功能，找到特定的方法，了解它们是如何执行的，条形的宽度表示方法执行所用的时间。我我们选择一个方法，跳转到跟踪视图窗口的底部: 这里，我们看到下方profile面板一些分析数据显示出来了，我们可以看到哪些方法调用了我们选定的方法，可以通过这些信息找到哪些地方耗时了。另外一个十分有用的信息是，方法被调用了多少次，或者递归调用本身多少次，我们可以看到下方的profile面板有一列名为“calls and recursion”，此列显示方法被调用了多少次，最底部有个搜索栏，可以搜索需要的东西。 以上就是个人对《Android 性能优化》的主要内容进行的总结,如有不足，欢迎指正。]]></content>
      <categories>
        <category>Android 性能优化</category>
      </categories>
      <tags>
        <tag>Android Performance</tag>
        <tag>Android 性能优化</tag>
        <tag>Traceview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用更多的Linux内核防御保护Android]]></title>
    <url>%2F2016%2F07%2F28%2Fprotecting-android-with-more-linux%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Protecting Android with more Linux kernel defenses Android主要依赖于Linux内核的安全​​模式执行。为了更好的保护好内核，我们在Android内启用了一系列的机制，在较高的等级下这些保护在一个组中被划分为两类——内存保护和减少攻击面。 内存保护通过内核提供的主要安全功能之一，是对于用户空间进程在地址空间分离的形式进行内存保护。不像用户空间进程，内核的各种任务生活在一个地址空间，并且一个漏洞无论在内核的任意位置，可以潜在的影响到系统存储器的无关部分。内核内存保护是保持内核的完整性，不管漏洞而被设计。 标记内存为只读/不执行这个功能细分内核内存到逻辑部分，并设置在每一个部分的限制页面访问权限。代码标记为只读+执行。数据片段被标记为不执行，并且进一步分段成只读和读写片段。这个功能特性利用配置选项CONFIG_DEBUG_RODATA进行启用。它是通过Kees Cook一起输入，是基于由Brad Spengler的Grsecurity的KENRNEXE功能的一个子集和Larry Bassel和Laura Abbott的高通的CONFIG_STRICT_MEMORY_RWX feature功能。CONFIG_DEBUG_RODATA在内核上游登陆对于arm/arm64,并且已经回迁到Android的3.18+arm/arm64常见的内核。 RESTRICT内核访问到用户空间这个功能通过防止它直接访问用户空间内存来提高内核的保护。它能够使一系列的攻击变得更加困难，因为攻击者在内核内存有显著较少的控制可以去执行，尤其是利用CONFIG_DEBUG_RODATA启用。类似的功能已经存在，最早存在的是Grsecurity的UDEREF。这个功能可以利用配置选项CONFIG_CPU_SW_DOMAIN_PAN被启用，并且对于ARMv7是通过Russell King被实施，回迁到Android的4.1内核通过Kees Cook. 加强保护防止堆栈缓冲区溢出就像它的前身,堆栈保护器.加强堆栈保护防止堆栈缓冲区溢出。但另外提供覆盖对于更多数组类型,因为原来只有保护的字符数组,加强堆栈保护是由Han Shan被实施，并加入到GCC编译器4.9。 减少攻击面减少攻击面，试图揭露较少的入口点到内核，而不会打破合法的功能。减少攻击面能够包括移除代码，移除访问入口点，或者选择性地曝光功能。 移除默认的调试访问功能内核的perf系统对于性能测试提供基础设施，可用于分析内核和用户空间的应用程序。Perf是一个为开发人员提供了有价值的工具，但是对于绝大多数的Andr​​oid用户添加了不必要的攻击面。在Android牛轧糖，访问perf将会默认被阻止。开发者仍可以通过启用开发者选项和使用adb设置一个配置:”adb shell setprop security.perf_harden 0”进行启用访问。 为阻止访问perf的补丁集可被分解成内核和用户空间部分。内核补丁是通过Ben Hutchings并且是从Grsecurity的CONFIG_GRKERNSEC_PERF_HARDEN通过Brad Spengler被派生。用户控件是由Daniel Micay作出了贡献。感谢Wish Wu和其他对于在perf里负责任披露安全漏洞的其他人。 限制应用程序访问ioctl命令很多Android安全模型是由SELinux进行描述和强制执行的。ioctl()系统调用代表了一大空白在强制粒度来源于SELinux。ioctl命令白名单和SELinux被添加作为一种手段来通过SELinux提供在ioctl系统命令控制. 在Android上，大多数内核漏洞报告发生在驱动程序和ioctl系统调用使用均达到。例如CVE-2016-0820.一些ioctl命令是需要通过第三方应用，但大多数都没有和访问能够不破坏合法的功能会受到限制。在Android牛轧糖，仅仅一小白名单套接字ioctl命令对于应用是可用的。对于选择的设备，应用的访问到GPU(图形处理器)的ioctl访问已经被受到类似的限制。 需要SECCOMP-BPFSeccomp提供了一个额外的沙箱机制，允许一个进程使用可配在的过滤器来限制可用的系统调用和系统调用参数。限制系统调用的可用性可以显著的降低内核的攻击暴露的表面。自从Seccomp首次在棒棒糖的Nexus设备上被介绍，其整个Android生态系统的可用性稳步提高。Android牛轧糖，seccomp支持所有设备的请求。在Android牛轧糖上，我们正在使用seccomp在mediaextractor和mediacodec过程作为媒体硬化努力的一部分。 不断努力这儿有其他一些针对于保护内核正在进行的项目： 内核自身的保护项目是开发运行时和编译防御的上游内核。 正在AOSP中进行对SELinux进一步的沙箱收紧和减少攻击面的操作。 Minijail提供了一个方便的机制，将内核提供的众多遏制和沙箱功能，包括过滤器的seccomp和命名空间。 像kasan和kcov帮助模糊器发现崩溃的根本原因，并智能地构建测试用例增加代码覆盖率，最终导致更有效的缺陷跟踪过程。 由于这些努力和其他人，我们预计内核的安全​​性继续改善。在我们的工作上我们赞赏反馈，对于我们如何提高Android欢迎提出建议，在security@android.com和我们联系。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Developer</category>
        <category>Security</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接你的应用程序到一个Wi-Fi设备]]></title>
    <url>%2F2016%2F07%2F21%2Fconnecting-your-app-to-wifi-device%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Connecting your App to a Wi-Fi Device 随着物联网的逐步成长，Android应用能够连接到Wi-Fi设备也越来越普遍。无论你是在创建一个远程取景器的应用，去设置连接到灯泡,或者是去控制一个四轴飞行器。如果它是依靠Wi-Fi你将需要连接到一个热点，或许这个热点不需要有internet网络连接访问。 从棒棒糖版本开始往前的系统变得更加智能了，允许多重网络连接且不会讲数据路由到一个不具有internet连接的网络。那样对用户来说非常有用，因为当他们附近的WIFI接近阳台的时候不会丢失连接。为开发者已经添加了数据路由接口文档（Data routing APIs），因此，你能够确保只有适当的应用程序的流量路由通过Wi-Fi连接到已经存在的设备上。 对于使用这个接口文档，理解起来也是非常简单的。这儿有3中网络设置对于开发者可以使用，知道这些就好了： WiFiManager#开始扫描(startScan)返回一个可用Wi-Fi网络列表清单，它们是通过是私有的SSID来确定的。 WiFiManager#获取网络配置(getConfiguredNetworks)在设备上返回一个Wi-Fi网络配置列表清单，同时通过SSID来作为索引，但是它们不一定当前可以使用。 ConnectivityManager#获取所有的网络(getAllNetworks)返回一个通过手机正在互动的网络列表，从棒棒糖版本开始往前这是必要的，一个设备一次或去连接到了多重网络，Wi-FI、LTE、Bluetooth等等，通过调用ConnectivityManager#getNetworkInfo和一个网络ID是可以确认每个的当前状态是可用的。 你可以在所有的Android版本中通过使用WiFiManager#startScan去扫描可用的Wi-Fi网络，遍历ScanResults去查找你外部Wi-Fi设备的SSID。一旦你发现了它，你能够检查，如果它已经利用WiFiManager#getConfiguredNetworks配置了一个网络，并通过WifiConfigrations遍历返回，和SSID进行匹配。那些SSIDs配置的网络是用双引号括起来的就需要值得去注意了，而所述的SSID在ScanResults中返回的不是。 如果你的网络配置了，你能够从WifiConfiguration对象里面去获取这个网络的ID，除此之外，你能够使用WifiManager#addNetwork配置它，保持网络id追踪，那样可以返回。 对于连接到Wi-Fi网络，注册一个对于WifiManager.NETWORK_STATE_CHANGED_ACTION的BroadcastReceiver的监听,并且然后调用WifiManager.enableNetwork(int netId,boolean disableOthers),通过在你的网络ID。对于下一次的扫描，该enableNetwork禁用了所有其他访问点，定位到你所请求的那一个，然后连接它。当你收到了网络广播的时候，你可以使用WifiManager#getConnectionInfo检查,你将成功的连接到正确的网络。但是，在棒棒糖及其以上，如果那个网络没有internet网络连接，请求将不会被路由到它上面。 路由网络请求 从你的应用程序到一个已存在的Wi-Fi设备，面对所有网络的请求，在棒棒糖设备上调用ConnectivityManager#setProcessDefaultNetwork，在棉花糖设备上调用ConnectivityManager#bindProcessToNetwork代替，这是一个直接的API替代。注意这里调用需要请求android.permission.INTERNET，否则它们将会返回false。 另外，如果你喜欢你的应用程序传输到Wi-Fi设备和一些Internet网络通过移动数据路由： 对于Http请求你能够使用Network#openConnection(java.net.URL),直接路由你的请求到这个网络。 对于低等级的Socket套接字交互，打开一个socket套接字，然后调用Network#bindSoket(java.net.Socket),或者另外使用Network#getSocketFactory。 现在你能够保持你的用户连接，让他们从创新的Wi-Fi功能产品中受益。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
        <category>Wifi</category>
      </categories>
      <tags>
        <tag>Wifi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Google意识API创建智能，环境感知应用程序]]></title>
    <url>%2F2016%2F06%2F28%2Fcreate-intelligent-context-aware-apps%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Create Intelligent, Context-Aware Apps with the Google Awareness APIs 在上个月的2016 Google I/O大会上宣布的全新的Google意识API。启用你的应用程序感知用户上下文响应，使用快照和围栏对系统资源的影响微乎其微。 今天我们骄傲的宣布通过Google Play服务对于所有的开发者都能够使用Google意识API。 利用7种不同类型的上下文——包括位置、天气、用户活动和附近的信标——你的应用程序能够更好的理解你这个用户当前的状况，并且使用这些信息提供优化和定制经验。 意识API提供两种方式在你的应用程序中提供信标： 快照API，让你的应用程序能够简易的请求有关用户当前的上下文信息，比如，“给我用户当前的位置和当前的天气情况”。 围栏API，让你的应用程序能够响应用户的上下文变化，—— 当它匹配到了一组特定的条件，比如，“当用户在步行和耳机是插入状态时告诉我”，类似于地理围栏API，一旦意识围栏被注册，它可以发送回调信息给你的应用程序，即使它没有运行。 在全新的方式里,作为一个单一的，简面化，意识API结合优化处理上下文信标。以前是不可能的，提供更准确和深刻的上下文线索，同时还管理着系统资源，以节省电池和减少带宽。 我们将会于我们的一些合作伙伴密切合作，我们已经发现了惊人的方式集成到他们的应用程序中去感知上下文： Trulia,一个网上住宅房地产网站，利用我们围栏API去建议打开房间。当天气是非常棒的时候，用户能够在它们的房子周围散步，它们会觉得很有意思。Trulia发送一个通知栏消息去提醒它们停止。这种量身定制的通知能够帮助用户在完美的时间打开房间经营。 SuperPlayer Music,在另一个方面，用户利用我们的快照API和围栏API去建议完美的音乐和你当前的心情匹配，无论你是刚刚完成了一项跑步并开始舒展、是坐长途车起来、还是刚刚离开健身房，它们的助理能够理解你的上下文并建议正确的播放列表给你。 我们最初设置的信标，我们的合作者真棒，我们才刚刚开始使用意识API，加入我们的旅程去构建量身定制的体验到你的应用中，通过使用Google Awareness API developer documentation(Google意识API开发者文档)获得开始，同时可以通过观看我们的Google I/O专题学习更多. 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Featured</tag>
        <tag>Apps</tag>
        <tag>Google I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 恢复移动视觉操作并添加文本API]]></title>
    <url>%2F2016%2F06%2F28%2Fandroid-mobile-vision-text-api%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Android Mobile Vision restores operation and adds Text API 在图片和视频中查找对象作为一个重要的核心，对于Android设备，在Google Play服务9.2版本上已经恢复了移动视觉操作。 在Google Play服务9.2这个新版本上，修复了一个在之前版本上存在的下载问题，导致了一个服务停止运行。 我们也高兴的宣布了文本API，对于移动视觉操作的一个新的组件。 这个文本API的光学字符识别技术，在图片中读取拉丁字符的文本（如：英语、西班牙语、德语、法语等等），返回文本以及组织结构(段落、行、字)。移动视觉操作现在能够： 组织包含文本的照片 自动化处理烦琐的数据录入，对于信用卡、数据和名片。 翻译文档（跟随Cloud Translate API(云端翻译API)） 跟踪真实的物体，比如在地铁列车内读取一些数字 提供无障碍特性 如果你想快速的开始，你可以尝试我们的codelab(代码实验室)，利用这儿的应用程序，将会在一个小时内获得Android 开发者阅读文本。 喜欢移动视觉面部识别操作和条码组件，对于实时应用，在设备上运行文本API是适宜的。对于更多的信息，在Mobile Vision Developer site(移动视觉开发者站点)检出。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>mobile vision APIs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android N对安全加密提供者已弃用]]></title>
    <url>%2F2016%2F06%2F10%2Fsecurity-crypto-provider-deprecated-in-android-n%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Security “Crypto” provider deprecated in Android N 如果你的安卓应用程序使用的是SHA1PRNG算法从加密提供者那里取得的密钥，你必须开始使用一个真正的密钥导出函数,然后可能需要重新加密你的数据。 Java加密体系结构允许开发者创建像密码一样的一个类的实例，或者是生成伪随机数，像这样去调用它: 1SomeClass.getInstance("SomeAlgorithm", "SomeProvider"); 或者更简单通熟些: 1SomeClass.getInstance("SomeAlgorithm"); 对于这个实例， 12Cipher.getInstance(“AES/CBC/PKCS5PADDING”); SecureRandom.getInstance(“SHA1PRNG”); 在Android上，我们不建议指定提供者。一般来说,任意调用Java加密扩展(JCE)API指定一个提供者，如果这个提供者是包括在应用程序里，或者说这个应用程序能够处理可能出现的ProviderNotException异常，也应该仅仅能完成这些。 不幸的是，很多应用程序都依赖于现在已经被移除了的”加密”提供者，对于一个密钥派生出来的反模式 这个提供者只能被提供一些为SecureRandom实例去实现的“SHA1PRNG”算法接口，问题是SHA1PRNG算法不是强加密，在使用基于PHP和Debian OpenSSL的伪随机序列和实验的统计距离的测试,8.1那部分，Yongge Want 和 Tony Nicol，指出该”随机”数列,以二进制形式考虑,朝0偏移返回，而且该偏移恶化的程度取决于种子。 结果是，在Android N中我们干脆弃用依赖于以“SHA1PRNG”算法去实现的接口和该加密提供者。我们在几年前使用加密安全存储凭据预先去覆盖使用SecureRandom派生出来的密钥产生的那些问题。然而，鉴于要继续使用它，我们将在这里重温一下。 该提供者有一个常见但是不正确的使用方法，就是通过使用密码作为种子来推导出加密密钥。SHA1PRNG接口有一个漏洞缺陷，如果setSeed()在获得输出之前被调用，那么就使他正确了。这个漏洞缺陷已经被用于密码作为种子派生加密密钥的关键，然后使用“随机”输出关键的密钥（其中,”随机”在这句话里的意思是“可以预测和若加密”），然后这种密钥可以用于加密和解密数据。 接下来，我们解释如何正确的导出密钥，以及如何解密已经进行不安全密钥加密的数据。这儿也有一个完整的例子,包括了一个帮助类去使用已经弃用SHA1PRNG功能，解密数据的唯一目的将不可用。 密钥可以通过以下方式得到： 如果你是通过从磁盘上读取一个AES的密钥，只是存储实际的密钥，你可以从通过使用执行字节AES生成SecretKey密钥： 1SecretKey key = new SecretKeySpec(keyBytes, "AES"); 如果您使用密码来获得一个密钥，参照Nikolay Elenkovd的这篇优秀教程，一个好的经验法制是腌制的大小应该和密钥输出的大小一致，它看上去就像是这样: 12345678910111213141516171819202122/* User types in their password: */ String password = "password"; /* Store these things on disk used to derive key later: */ int iterationCount = 1000; int saltLength = 32; // bytes; should be the same size as the output (256 / 8 = 32) int keyLength = 256; // 256-bits for AES-256, 128-bits for AES-128, etc byte[] salt; // Should be of saltLength /* When first creating the key, obtain a salt with this: */ SecureRandom random = new SecureRandom(); byte[] salt = new byte[saltLength]; random.nextBytes(salt); /* Use this to derive the key from the password: */ KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, iterationCount, keyLength); SecretKeyFactory keyFactory = SecretKeyFactory .getInstance("PBKDF2WithHmacSHA1"); byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();SecretKey key = new SecretKeySpec(keyBytes, "AES"); 就是这样，你也不需要做其他的任何事情。 为了使过渡数据更容易，我们覆盖开发者的情况，有一个不安全的密钥加密的数据，它是每次从一个密码那里派生出来的。你可以在示例应用程序中使用帮助类InsecureSHA1PRNGKeyDerivator去派生出密钥: 12345678private static SecretKey deriveKeyInsecurely(String password, intkeySizeInBytes) &#123; byte[] passwordBytes = password.getBytes(StandardCharsets.US_ASCII); return new SecretKeySpec( InsecureSHA1PRNGKeyDerivator.deriveInsecureKey( passwordBytes, keySizeInBytes), "AES"); &#125; 然后，你可以使用安全的派生出的密钥按照上面的所述的重新加密数据，并从此过上幸福的生活。 注意1:作为一个临时的措施去维持应用重新工作，我们决定了在目标SDK版本为Mashmallow(API23)及其低版本还是为应用程序创建示例，请不要在Android SDK中存在依赖加密提供者，我们的计划是在未来会将其完全删除。注意2:因为该系统很多部分都承担了SHA1PRNG算法的存在，当一个SHA1PRNG实例请求和提供者没有指定，我们将返回一个OpenSSLRandom的实例，这是从OpenSSL的衍生出随机数的一个强有力的来源。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android N</category>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>Android N</tag>
        <tag>Security</tag>
        <tag>encrypt</tag>
        <tag>加密解密</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android N 中的 Notification 通知]]></title>
    <url>%2F2016%2F06%2F09%2FNotifications-In-Android-N%2F</url>
    <content type="text"><![CDATA[原文来自: Android Developers Blog —— Notifications in Android N Android 通知往往是在你的Android应用和用户之间制造或打破而相互作用。为了提供更好的用户体验，Android N上的通知已经接收到视觉的更新，对于自定义视图更好的支持，以及直接回复形式的扩展功能，一个全新的消息风格，和捆绑通知 相同的通知，新的面貌首先最明显的变化就是通知的默认外观已经显著变化，许多被周围的通知扩散区域已经折叠到了一个新的标题里面，和你的应用的应用图标以及名字固定通知。这个变化确保了标题、文本和大图标被给予最大量的空间的可能性，并且其结果就是，现在的通知通常稍大了，更容易阅读。 鉴于单行标题，这是比以往的信息的有用性更重要，当你的目标是Android N 的时候，默认的情况下时间会被隐藏，不会显示出来—— 如果你有一个时间危机的通知，比如说是一个消息应用程序，你能够使用setShowWhen(true)重新开启它。此外，内容下面一小行的文字将会优先于你设置的任何内容信息:只有当你指定Android N 之前的早期版本才会同时出现。在所有的情况下，确保内容下面一小行的文字是符合标题且有用的——比如说，如果用户仅仅只有一个账户，不要添加一个账户邮箱地址作为你的内容下面一小行的文字。 通知操作也得到了重新的设计，现在以下的通知条条目在视觉上是不同的。 你会注意到，图标都没有出现在新的通知;而是提供了标签本身在通知栏有限的空间里更多的空间。然而，通知操作图标仍然需要请求并继续在Android旧版本设备上使用，比如说Android Wear. 如果你将利用NotificationCompat.Builder构建一个你的通知，你可以在那儿使用标准样式风格，你将会得到全新面貌和感觉，默认的情况下，不需要进行更改代码的请求。 对于自定义视图提供更好的支持如果你不是从自定义RemoteViews来代替构建你的通知，适配任何全新风格就已经成为挑战了。从一个通知正文+标题，利用全新的标题、伸缩特性、动作、和大图标定位作为一个独立元素，我们将介绍一个全新的DecoratedCustomViewStyle和DecoratedMediaCustomViewStyle去提供所有的这些元素，允许你用新的setCustomContentView()方法只关注内容。 这也确保了未来的外观和感觉应该被显著简单的适配，在应用那边不需要修改任何代码这些样式将平台一起进行更新。 直接回复当通知已经有了可以启动一个Activity或者在使用一个Sevice或者BroadcastReciver在后台工作的操作，直接回复（Direct Reply）允许你构建一个动作，利用通知操作直接接受通知单行文本输入。 直接回复使用了相同的RemoteInputAPI——最初是在Android Wear里引人的——对于标记一个能够接受让用户直接输入。标记一个动作(Action)作为能够直接接收来自用户的输入。 该RemoteInput本身包含像将被用于以后检索的输入，和用户开始输入之前所显示的提示文本的关键信息。 12345678// Where should direct replies be put in the intent bundle (can be any string)private static final String KEY_TEXT_REPLY = "key_text_reply";// Create the RemoteInput specifying this keyString replyLabel = getString(R.string.reply_label);RemoteInput remoteInput = new RemoteInput.Builder(KEY_TEXT_REPLY) .setLabel(replyLabel) .build(); 一旦你已经构建了RemoteInput,它可以通过适当命名的addRemoteInput()方法连接到你的Action操作。你可能会考虑调用setAllowGeneratedReplies(true)方法去开启Android Wear 2.0产生Smart Reply(智能回复)的选择，当它可用的时候,能使用户更容易迅速作出反应。 123456// Add to your action, enabling Direct Reply for itNotificationCompat.Action action = new NotificationCompat.Action.Builder(R.drawable.reply, replyLabel, pendingIntent) .addRemoteInput(remoteInput) .setAllowGeneratedReplies(true) .build(); 请记住，pendingIntent被传递到你的Action动作应该是一个Activity，在Marshmallow以及更低版本的设备上是不支持直接回复功能(你将希望锁屏,开启一个Activity,有一个焦点输入框让用户可以直接在里面输入回复)，应该是一个Service（如果你需要这样做需要在一个另外的线程）或者是BroadcastReceiver（它运行在UI主线程）在Android N 设备上，因此，甚至从锁屏背景下的文本输入这么一个流程（这儿是一个另外的用户从系统设置中去控制一个被锁的设备直接回复启用/禁用） 在你的Service或者BroadcastReceiver里提取文本输入，可以使用到的帮助:RemoteInput.getResultsFromIntent() 方法 1234567private CharSequence getMessageText(Intent intent) &#123; Bundle remoteInput = RemoteInput.getResultsFromIntent(intent); if (remoteInput != null) &#123; return remoteInput.getCharSequence(KEY_TEXT_REPLY); &#125; return null; &#125; 之后你将处理文本，你必须更新通知，这个是隐藏UI直接回复，应该作为一种技术来确认用户他们答复接收和正确处理的触发。 对于多数模板，这都应该涉及使用追加答复到通知的底部新的setRemoteInputHistory()方法，直到主要内容被更新的其他答复被追加到历史(比如说其他人回复) 然而，如果你将构建一个消息类型的应用程序，预计来回交流对话，你应该使用MessagingStyle并使附加消息追加到它上面。 MessagingStyle 我们已经对正在进行对话进行了优化，并使用了新的MessagingStyle进行直接回复的体验 这个样式风格提供了内置的通过addMessage()返回添加多个消息格式的方法。每一个条消息支持传入文本本身，时间戳和消息的发送者（因此很容易支持群组对话） 123456builder.setStyle(new NotificationCompat.MessagingStyle("Me") .setConversationTitle("Team lunch") .addMessage("Hi", timestampMillis1, null) // Pass in null for user. .addMessage("What's up?", timestampMillis2, "Coworker") .addMessage("Not much", timestampMillis3, null) .addMessage("How about lunch?", timestampMillis4, "Coworker")); 你将会注意到，这种风格对于具体的消息表示一流的支持从用户和他们填写的名字(使用”我”这种情况)，并设置一个可选的对话标题。当这个可以手动的使用一个BigTextStyle，通过Android Wear 2.0 使用这种风格的用户，将会获得直接内嵌的行来响应，抛弃了踢出来扩展通知来看，制造了一个无缝体验，而无须构建一个完整的可穿戴的应用程序。 捆绑通知一旦你使用了一个全新的视觉设计去构建一个伟大的通知，直接回复、信息风格、和我们以前所有的最佳实践,考虑整体的通知体验是非常重要的,特别是如果你发布多个通知(说，每个正在进行会话或者每个新的电子邮件线程之间) 捆绑通知(Bundled notificaiton)提供了两全其美：当用户正在寻找其他通知一个单条的摘要通知或者希望在所有的通知上同时操作展开组操作个体通知（包括使用操作和直接回复） 如果你将要构建Android Wear通知栈，和这里的API使用方法完全相同，只需要添加setGroup())到每一个通知就能将这些通知捆绑在一起了。你不局限于一组，所以捆绑通知恰如其分。对于电子邮件应用程序，你可以考虑每个帐户一个捆绑的实例。 创建一个摘要通知(summary notification)也是重要的，这个摘要通知，通过 setGroupSummary(true)，它仅仅是通知出现在Mashmallow及其低版本设备上，应该(你猜对了)总结所有个人通知。这是一个使用InboxStyle最合适的时候。虽然使用它不是一个要求。在Android N及其更高版本的设备上，一些信息(比如说subText，subtext, content intent, and delete intent)是从摘要的通知中提取生产倒塌通知捆绑的通知，所以你应该继续产生的所有API级别的摘要通知。 为了提高在Android N个器件的整体用户体验，发布4个或者更多通知没有组的通知，这些通知将会被自动捆绑在一起 N是为了通知通知在Android上已经渐进增强的稳定区了。从Gingerbread时代的一个敲击目标到可以展开的通知、操作动作、媒体风格，以及现在的特性，比如直接回复和捆绑通知,通知在Android上所有用户体验中扮演了一个重要的部分。 利用现在许多新的工具去使用（NotificationCompat帮助向后兼容）,我很高兴地看到你如何来使用它们去#构建更好的应用程序 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android N</category>
        <category>Notiification</category>
      </categories>
      <tags>
        <tag>Notification</tag>
        <tag>通知</tag>
        <tag>Android N</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Wear 真机调试&创建第一个应用]]></title>
    <url>%2F2016%2F06%2F08%2FAndroid-Wear-create-first-demo%2F</url>
    <content type="text"><![CDATA[两年前，Android Wear刚出来的时候，我耐不住性子折腾新技术，就开始去把玩Android Wear。我当时还买不起真机，就用模拟器测试，2014年的那天也是端午佳节，我写了Android Wear第一个小例子。去年Moto 360 1 Gen 降价了，于是就入手了一台，准备开始来做Android Wear的App测试，然后呢，事实上就一直没有时间去做相关的开发测试，（是懒了？还是真的没时间？）好了，现在决定开始来着手，就从下面的例子开始吧。 调试前的准备 操作系统：Ubuntu 16.04 LTS开发环境：Android Studio 2.2 preview 2 (version:Linux)手持设备：Google Nexus 5手表设备：Moto 360 1 Gen手持系统：Android 6.0.1(MOB30M)手表系统：Android Wear 1.4.0.2580363 (Android 6.0.1) 创建项目1、启动Android Studio，新建一个项目工程AndroidWearApp 2、复选框选中手机和手表两个选项:选中Phone and Tablet 并且 Minimum SDK 选择 API15:Android 4.0.3(IceCreamSandwich)选中Wear并且Minimum SDK 选择 API20:Android 4.4(KitKat Wear) 3、Add an Activity to Mobile,我们选择添加默认的Empty Activity显示空Activity 4、Add an Activity to Wear 我们选择添加Blank Wear Activity显示通知 5、成功创建项目完成，打开Wear模块下的布局文件 开启设备调试开启手机端USB调试开关打开系统设置，查看是否有开发者选项，如果有直接进去打开开发者选项，开启USB调试开关；如果没有，在设置最下面的关于手机中，点击底部系统版本信息7次，会弹出打开成功的提示。按返回键回到上一级，可以看到开发者选项,打开开发者选项，开启USB调试开关。 开启手表端Bluetooth调试开关按右侧的物理键点亮屏幕，屏幕向左滑动唤出菜单，上下滚动找到设置选项点击它，然后滚动到底部看是否有开发者选项,如果有，进去开启USB调试开关。；如果没有，点击设置底部的关于，然后点击系统版本信息7次，就会出现开发者选项。进入开发者选项,开启USB调试开关。 开启调试会话连接手机USB数据线连接到电脑，在手机端打开蓝牙，运行Android Wear应用（确保你的手机手表已经连接）。点击Android Wear右上角的齿轮图标进入设置（Settings） 开启通过蓝牙调试打开设置（Settings）底部的通过蓝牙调试（Debugging over Bluetooth）切换按钮。你可以看到连接状态: Host: disconnected Target: connected 确保手机已经链接到电脑，并执行adb命令： 1adb forward tcp:4444 localabstract:/adb-hub; adb connect localhost:4444 你就可以看到刚才连接状态变成了 Host: connected Target: connected 调试应用我们回到Android Studio，我们可以看到 Android Monitor下面已经连接上了两个设备，一个是我的手持设备LGE Nexus 5 Android 6.0.1,API 23,另一个是我的手表设备Motorola Moto 360 Android 6.0.1,API 23,标志着我的手表手机和Android Studio三者之间都互通了。 下面需要到wear模块下Java代码进行修改: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MainActivity extends Activity &#123; private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final WatchViewStub stub = (WatchViewStub) findViewById(R.id.watch_view_stub); stub.setOnLayoutInflatedListener(new WatchViewStub.OnLayoutInflatedListener() &#123; @Override public void onLayoutInflated(WatchViewStub stub) &#123; mTextView = (TextView) stub.findViewById(R.id.text); mTextView.setText("点我创建通知"); mTextView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int notificationId = 001; String eventTitle = "端午将至"; String eventLocation = "祝大家端午节快乐！\n生活“粽”快乐！\n样样“粽”美好！"; // Build intent for notification content Intent viewIntent = new Intent(MainActivity.this, MainActivity.class); PendingIntent viewPendingIntent = PendingIntent.getActivity(MainActivity.this, 0, viewIntent, 0); NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(MainActivity.this) .setSmallIcon(R.mipmap.googledev) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.googledev)) .setContentTitle(eventTitle) .setContentText(eventLocation) .setContentIntent(viewPendingIntent); // Get an instance of the NotificationManager service NotificationManagerCompat notificationManager = NotificationManagerCompat.from(MainActivity.this); // Build the notification and issues it with notification manager. notificationManager.notify(notificationId, notificationBuilder.build()); &#125; &#125;); &#125; &#125;); &#125;&#125; 点击Android Monitor下的设备，选中手表Motorola Moto 360 Android 6.0.1,API 23，点击Android Studio上的运行，App即可会自动安装到手表上，稍微有点慢耐心等下就好。 点击Activity上的TextView创建通知，回到主界面，往上滑动就能看到，刚刚创建的手表通知消息 卸载调试的应用执行命令 “adb -s localhost:4444 uninstall 包名” 即可，如： 1adb -s localhost:4444 uninstall com.example.shoewann.androidwearapp 这样，再看手表上就没有那个调试程序了。 以上简单的介绍了如何在使用真机创建调试Android Wear可穿戴设备，后续继续总结。如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android Wear</category>
      </categories>
      <tags>
        <tag>Android Wear</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Firebase特性之崩溃报告]]></title>
    <url>%2F2016%2F06%2F06%2FCrash-reporting-in-Firebase%2F</url>
    <content type="text"><![CDATA[在2016年的Google IO大会上，Google 公布了若干有关Firebase有意思的新特性。全新的Firebase添加了全新的工具，将成为统一移动应用开发的平台，帮助开发者快速开发，提高应用的开发质量，吸引用户和从应用中盈利。你可以从Firebase新官网和YouTube视频查看更多。 在Firebase更新的一些新特性包括: Firebase 分析 Firebase 云信息 Firebase 测试实验室和崩溃报告 Firebase 通知、动态链接、App 索引、广告、邀请等等 在这里文章中，我们来共同学习一下如何在Androids上使用Firebase的崩溃报告。 如何使用？ Firebase 3.0 需要运行在Google服务9.0或者更高的环境上，需要将Firebase添加到Android Studio中，你需要执行一下的操作步骤: 请求前的准备确保你的开发环境已经满足于以下的这些前提条件: 需要运行在一个支持Google服务是9.0.0或者更高的Android设备上 需要Android SDK 管理器中已经安装了Google 服务的相关插件文件，且是3.0.0或者更高版本。 需要Android Studio 的版本是1.5或者更高版本。 需要有一个Android项目，可以是已存在的或者新项目，同时拿到它的包名备用。 添加Firebase到应用这一步，需要添加Firebase到你的应用中，你需要到Firebase console上去创建一个Firebase的项目。 点击Create New Project（如果你开始一个新的项目）或者import Google Project（如果你导入一个已经存在的项目），我这里创建一个新的项目。 Firebase支持多平台，Android、IOS、Web.我们这里是以Android为例 现在，在你的APP应用里面，点击Add Firebase to your Android app 将会弹出一个对话框让你输入: 包名和SHAI SHAI的获取办法： keytool -exportcert -list -v -alias androiddebugkey -keystore %USERPROFILE%.android\debug.keystore (Windows) keytool -exportcert -list -v -alias androiddebugkey -keystore ~/.android/debug.keystore （mac/linux） 我的系统环境是linux，故使用后者命令，在终端执行并获得SHAI： 将包名和SHAI填入输入框内,点击ADD APP，随后你将会下载一个google-services.json的配置文件，根据页面提示，放到项目里指定位置。 将google-services.json文件放到project层级下的app目录下: 添加SDK到应用你的应用中要使用Firebase,你需要添加和设置SDK到你的应用中去，首先，添加以下行到你的项目根下的builde.gradle文件中去: 123456buildscript &#123; dependencies &#123; // Add this line classpath 'com.google.gms:google-services:3.0.0' &#125;&#125; 然后在你的app模块的build.gradle文件中，在文件的底部应用这个Google服务的插件你的builde.gradle应该是这个样子的： 123456789apply plugin: 'com.android.application' android &#123; // ... &#125; dependencies &#123; // ... &#125; // ADD THIS AT THE BOTTOM apply plugin: 'com.google.gms.google-services' 然后点击Sync now同步一下文件 设置崩溃报告现在，到了设置崩溃报告了，你需要添加Firebase崩溃报告依赖，你需要到你模块的build.gradle文件中去添加如下行: 1compile 'com.google.firebase:firebase-crash:9.0.1' 那么你的build.gradle文件大概就是这个样子: apply plugin: 'com.android.application' android { // ... } dependencies { // ... compile 'com.google.firebase:firebase-crash:9.0.1' } // ADD THIS AT THE BOTTOM apply plugin: 'com.google.gms.google-services' 然后点击Sync now同步一下文件 创建一个崩溃报告以上的操作已经完成了所有的配置，现在我们来创建一个崩溃报告。 我在项目的MainActivity中这样定义，模拟测试一个java.lang.NullPointerException的崩溃异常的情况: 定义一个TextView，但是不给它实例化对象,此时Textview对象为null，然后给它赋值一个字符串显示，给一个为空的对象赋值就会抛出java.lang.NullPointerException异常，以下是测试代码 当程序运行后，log中抛出了异常，但是程序没有崩溃退出,以下是本地log: 回到Firebase控制台查看，点击左侧的crash,大于20分钟左右，就能看到上传的java.lang.NullPointerException崩溃报告 点击上图异常日志中的超链接，可以跳转到以下界面,在这里可以看到java.lang.NullPointerException相关的详细数据等 这里可以看到测试的java.lang.NullPointerException具体行数在MainActivity.onCreate(MainActivity.java:18) 以上简单的介绍了如何在App应用中使用Firebase崩溃日志报告的相关内容，有关Firebase的其他特性，后续总结。如果不足，欢迎指正，谢谢。]]></content>
      <categories>
        <category>Android</category>
        <category>Firebase</category>
        <category>Google cloud</category>
      </categories>
      <tags>
        <tag>Firebase</tag>
        <tag>Android</tag>
        <tag>Google Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网络通信之——Socket]]></title>
    <url>%2F2016%2F06%2F02%2FAndroid-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8B%E2%80%94%E2%80%94Socket%2F</url>
    <content type="text"><![CDATA[Socket,又称“套接字”，是网络上运行的两个程序间双向通讯的一端，它既可以接受请求，也可以发送请求，利用它可以较为方便的编写网络上的数据的传递。在java中，有专门的socket类来处理用户的请求和响应。利用SOCKET类的方法，就可以实现两台计算机之间的通讯。Java中能够接受其他通信实体连接请求的类是ServerSocket类，该对象用于监听来自客户端Socket的连接。如果没有连接，它将一直处于等待的状态。 TCP的使用 TCP协议被称着一种端对端的协议，这是因为它为两台计算机之间的连接起了重要作用。当一台计算机需要与另外一台远程计算机连接时，TCP协议会让它们建立一个链接，用于发送和接收数据的虚拟链接。 客户端（client）: 发送数据和接收数据 ——&gt;Socket服务端（server）: 负责去分发以处理相关数据 ——&gt;ServerSocket 如何建立一个服务端123456789//创建一个ServerSocket,用于监听客户端Socket的连接请求ServerSocket serverSocket = new ServerSocket(8080);//采用循环不断的接受来自客户端的请求while(true)&#123; //每当接受的客户端Socket的请求，服务端也对应产生一个 Socket socket = serverSocket.accept(); //下面就可以进行Socket通信了 .........&#125; 如何建立一个客户端1234//创建连接到本机、8080端口的Socket Socket socket = new Socket("192.168.1.1", 8080);//下面就可以进行Socket通信了 ......... 简单通信示例 一个简单的示例，客户端界面上一个文本编辑框、一个按钮和一个文本显示。客户端输入内容在文本编辑框，然后点击按钮发送到服务器，服务器然后再返回给客户端，显示到文本显示控件上，完成客户端与服务器的通信。 服务器 SocketServer.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class SocketServer implements Runnable &#123; //创建一个ServerSocket对象 private ServerSocket serverSocket; //创建一个Socket对象 private Socket client; public void run() &#123; try &#123; //实例化ServerSocket对象,设置服务端端口8080 serverSocket = new ServerSocket(8080); System.out.println("服务器已启动，等待客户端连接..."); while (true) &#123; //不断循环，接受客户端的访问 client = serverSocket.accept(); System.out.println("客户端已连接"); System.out.println("============"); try &#123; // 接收客户端信息 BufferedReader in = new BufferedReader( new InputStreamReader(client.getInputStream())); String str = in.readLine(); System.out.println("客户端:" + str); // 向客户端发送信息 PrintWriter out = new PrintWriter(new BufferedWriter( new OutputStreamWriter(client.getOutputStream())), true); System.out.println("服务器发送:" + str); out.println("服务器：" + str); //本次会话完成,关闭输入输入出流 in.close(); out.close(); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; finally &#123; //关闭输入Socket对象 client.close(); System.out.println("============"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * * @param args */ public static void main(String[] args) &#123; //创建线程 Thread thread = new Thread(new SocketServer()); //开启线程 thread.start(); &#125;&#125; 客户端XML文件 activity_main.xml Java 代码 MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.example.shoewann.socketclient;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.Socket;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = "MainActivity"; private android.widget.EditText editText; private android.widget.Button button; private android.widget.TextView textView; private static final String IP_ADDRESS = "192.168.1.189"; private static final int IP_PORT = 8080; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initData() &#123; this.button.setOnClickListener(this); &#125; private void initView() &#123; this.textView = (TextView) findViewById(R.id.textView); this.button = (Button) findViewById(R.id.button); this.editText = (EditText) findViewById(R.id.editText); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: final String message = editText.getText().toString(); editText.getText().clear(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Socket socket = new Socket(IP_ADDRESS, IP_PORT); //客户端=&gt;向服务器=&gt;发送信息 PrintWriter out = new PrintWriter(new BufferedWriter( new OutputStreamWriter(socket.getOutputStream())), true); Log.e(TAG, "Socket send Message:==&gt;" + message); out.println(message); //客户端=&gt;接收=&gt;服务器=&gt;返回信息 BufferedReader br = new BufferedReader( new InputStreamReader(socket.getInputStream())); String msg = br.readLine(); Log.e(TAG, "Socket receiver Message:==&gt;" + message); //实例化Handler类和Message发送消息给主线程更新UI MyHandler handler = new MyHandler(getMainLooper()); Message mMessage = handler.obtainMessage(); mMessage.what = 0x123; mMessage.obj = msg; handler.sendMessage(mMessage); //注意最后要关闭输入输出流 out.close(); br.close(); //关闭socket对象 socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); Log.w(TAG, e.toString()); &#125; &#125; &#125;).start(); break; default: break; &#125; &#125; class MyHandler extends Handler &#123; public MyHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 0x123: //获得消息中服务器返回的数据,显示到UI上 if (msg.obj != null) &#123; textView.setText(msg.obj.toString()); &#125; else &#123; textView.setText("服务器返回数据错误"); &#125; break; default: break; &#125; &#125; &#125;&#125; 效果图 客户端发送前： 服务端收到信息并返回： 客户端收到服务器返回的信息： 简易聊天室示例 以下的示例简单的实现你一个简易的聊天室效果 服务器 SocketThread.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class SocketThread implements Runnable &#123; //定义处理当前线程的Socket Socket socket=null; //该线程处理Socket所对应的输入流 BufferedReader bf=null; public SocketThread(Socket s)&#123; this.socket=s; try &#123; //初始化该socket对应的输入流 bf=new BufferedReader(new InputStreamReader(s.getInputStream(),"utf-8")); &#125;catch(UnsupportedEncodingException e)&#123; e.printStackTrace(); System.out.println("SocketThread UnsupportedEncodingException :===&gt;"+e.getMessage()); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); System.out.println("SocketThread Exception :====&gt;"+e.getMessage()); &#125; &#125; public void run() &#123; // TODO Auto-generated method stub try &#123; String content=null; while ((content=readMessageFromeClient())!=null) &#123; //遍历socketList中的每一个socket对象，将读取到的内容向每个socket发送一次 for (Socket socket : AndroidThreadServer.socketList) &#123; //创建输出流对象 OutputStream outputStream; outputStream=socket.getOutputStream(); System.out.println(content+"\n"); outputStream.write((content+"\n").getBytes("utf-8")); &#125; &#125; &#125; catch (IOException e) &#123; // TODO: handle exception e.printStackTrace(); System.out.println("Run IOException :===&gt;"+e.getMessage()); &#125; &#125; private String readMessageFromeClient()&#123; try &#123; return bf.readLine(); &#125; catch (IOException e) &#123; //如果发生了异常，表示客户端已近关闭，应该删掉socket AndroidThreadServer.socketList.remove(socket); e.printStackTrace(); System.out.println("readMessageFromeClient IOException :===&gt;"+e.getMessage()); &#125; return null; &#125;&#125; AndroidThreadServer.java 1234567891011121314151617181920212223242526public class AndroidThreadServer &#123; //定义保存所有socket的list对象 public static List&lt;Socket&gt; socketList=new ArrayList&lt;Socket&gt;(); public static void main(String[] args) &#123; try &#123; //创建socket对象，使用端口8080 ServerSocket serverSocket=new ServerSocket(8080); //不断的循环，接受客户端的访问 while (true) &#123; //创建Socket对象，使用accept()方法不断的创建 Socket socket=serverSocket.accept(); //将socket对象添加到list集合里 socketList.add(socket); //客户端连接成功后启启动一条SocketThread线程为该客户的服务 new Thread(new SocketThread(socket)).start(); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); System.out.println("AndroidThreadServer Exception:===&gt;"+e.getMessage()); &#125; &#125;&#125; 客户端XML 布局 activity_main.xml Java 代码 ClientThread.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ClientThread implements Runnable &#123; private static final String TAG = "ClientThread"; //声明Socket对象 private Socket mSocket = null; //声明Handler对象 private Handler mHandler = null; //声明BufferedReader对象 private BufferedReader bf = null; public ClientThread(Socket socket, Handler handler) &#123; this.mSocket = socket; this.mHandler = handler; try&#123; //获取BufferedReader 对象 bf=new BufferedReader(new InputStreamReader(socket.getInputStream())); &#125;catch (IOException e)&#123; e.printStackTrace(); Log.w(TAG, "ClientThread IOException: ====&gt;"+e.getMessage()); &#125; &#125; @Override public void run() &#123; String content=null; try &#123; //循环读取内容 while ((content=bf.readLine())!=null)&#123; //构建消息对象 Message msg=mHandler.obtainMessage(); //设置消息对象模式与内容 msg.what=0x123; msg.obj=content; mHandler.sendMessage(msg); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); Log.w(TAG, "Run IOException: ====&gt;"+e.getMessage()); &#125; &#125;&#125; MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = "MainActivity"; public android.widget.TextView tvshow; private android.widget.EditText edinput; private android.widget.Button btnsend; private static final String IP_ADDRESS = "192.168.1.189"; private static final int IP_PORT = 8080; private OutputStream output = null; private Socket mSocket = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); iniData(); &#125; private void initView() &#123; this.btnsend = (Button) findViewById(R.id.btn_send); this.edinput = (EditText) findViewById(R.id.ed_input); this.tvshow = (TextView) findViewById(R.id.tv_show); &#125; private void iniData() &#123; this.btnsend.setOnClickListener(this); SocketHandler handler = new SocketHandler(Looper.getMainLooper()); initSocket(handler); &#125; public void initSocket(final Handler handler) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; mSocket = new Socket(IP_ADDRESS, IP_PORT); //启动子线程,每一个线程处理对应的socket new Thread(new ClientThread(mSocket, handler)).start(); //实例化输出流对象 output = mSocket.getOutputStream(); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); Log.w(TAG, "initSocket tUnknownHostException : ==&gt; " + e.getMessage()); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.w(TAG, "initSocket IOException : ==&gt; " + e.getMessage()); &#125; &#125; &#125;).start(); &#125; class SocketHandler extends Handler &#123; public SocketHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); //判断是否有子线程传递过来的消息 switch (msg.what) &#123; case 0x123: //将服务器的消息追加到textview控件上进行显示 MainActivity.this.tvshow.append(msg.obj.toString()+"\n"); break; &#125; &#125; &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_send: try &#123; Date date=new Date(); DateFormat format=new SimpleDateFormat("HH:mm:ss"); String time=format.format(date); //将文本输入框的文本信息写入流 output.write((getlocalip()+"\t\t["+time+"]\n"+edinput.getText().toString() + "\n").getBytes()); //将文本输入框内容置空 edinput.getText().clear(); //edinput.setText(""); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); Log.w(TAG, "onClick UnknownHostException : ==&gt; " + e.getMessage()); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.w(TAG, "onClick IOException : ==&gt; " + e.getMessage()); &#125; break; &#125; &#125; private String getlocalip()&#123; WifiManager wifiManager = (WifiManager)getSystemService(Context.WIFI_SERVICE); WifiInfo wifiInfo = wifiManager.getConnectionInfo(); int ipAddress = wifiInfo.getIpAddress(); Log.d(TAG, "int ip "+ipAddress); if(ipAddress==0)return null; return ((ipAddress &amp; 0xff)+"."+(ipAddress&gt;&gt;8 &amp; 0xff)+"." +(ipAddress&gt;&gt;16 &amp; 0xff)+"."+(ipAddress&gt;&gt;24 &amp; 0xff)); &#125;&#125; 效果图 客户端 A： 客户端 B： 服务端： 以上简单的介绍了Socket网络通信相关内容，如果不足，欢迎指正。]]></content>
      <categories>
        <category>Android</category>
        <category>Java</category>
        <category>网络通信</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>java</tag>
        <tag>网络通信</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity多级跳转带返回值]]></title>
    <url>%2F2016%2F05%2F31%2FActivity%E5%A4%9A%E7%BA%A7%E8%B7%B3%E8%BD%AC%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[我们最常用的就是A、B两个activity跳转传值，有时还会遇到A、B、C三个页面传值，如果A——&gt;B——&gt;C,如何将C页面的数据直接返回给A？ 针对这个问题，以前遇到你多次了。为此，觉得有必要记录下来，好了，来用下面的例子说明具体操作 首先新建一个项目，创建A、B、C三个Activity，每个Activity上有一个TextView和一个Button，点击A界面的按钮传值到B界面，点击B界面的按钮传值到C界面，点击C界面的按钮返回值到A界面，最终完成测试（在下面的示例中，暂时只考虑A——&gt;B——&gt;C——&gt;A这样的情况） MainActivity.javapackage com.example.shoewann.activityintent; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity implements View.OnClickListener { private static final String TAG = "MainActivity"; private android.widget.Button button; private android.widget.TextView textView; private final int MAINACTIVITY_REQUEST_CODE=1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); } private void initData() { this.button.setOnClickListener(this); this.textView.setText("我是MainActivity的数据"); } private void initView() { this.textView = (TextView) findViewById(R.id.textView); this.button = (Button) findViewById(R.id.button); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.button: starter(); break; default: break; } } private void starter() { Intent starter = new Intent(this, SecondActivity.class); starter.putExtra("first","我是来自MainActivity的数据"); startActivityForResult(starter,MAINACTIVITY_REQUEST_CODE); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode==Activity.RESULT_FIRST_USER){ if (requestCode==MAINACTIVITY_REQUEST_CODE){ if (data!=null){ textView.append("\n"+data.getStringExtra("threeth")); } } } } } SecondActivity.javapackage com.example.shoewann.activityintent; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.TextView; public class SecondActivity extends AppCompatActivity implements View.OnClickListener{ private static final String TAG = "SecondActivity"; private android.widget.Button button2; private android.widget.TextView textView2; private final int SECONDACTIVITY_REQUEST_CODE=2; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); initView(); initData(); } private void initView() { this.textView2 = (TextView) findViewById(R.id.textView2); this.button2 = (Button) findViewById(R.id.button2); } public void initData(){ if (getIntent()!=null){ textView2.setText(getIntent().getStringExtra("first")); } this.button2.setOnClickListener(this); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.button2: starter(); break; default: break; } } private void starter() { Intent starter = new Intent(this, ThreethActivity.class); starter.putExtra("second","我是来自SecondActivity的数据"); startActivityForResult(starter,SECONDACTIVITY_REQUEST_CODE); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode==Activity.RESULT_FIRST_USER){ if (requestCode==SECONDACTIVITY_REQUEST_CODE){ if (data!=null){ setResult(Activity.RESULT_FIRST_USER,data); finish(); } } } } } ThreethActivity.javapackage com.example.shoewann.activityintent; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.TextView; public class ThreethActivity extends AppCompatActivity implements View.OnClickListener{ private static final String TAG = "ThreethActivity"; private android.widget.Button button3; private android.widget.TextView textView3; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_threeth); initView(); initData(); } private void initView() { this.textView3 = (TextView) findViewById(R.id.textView3); this.button3 = (Button) findViewById(R.id.button3); } public void initData(){ if (getIntent()!=null){ textView3.setText(getIntent().getStringExtra("second")); } this.button3.setOnClickListener(this); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.button3: starter(); break; default: break; } } private void starter() { Intent starter = new Intent(); starter.putExtra("threeth","我是来自ThreethActivity的数据"); setResult(Activity.RESULT_FIRST_USER,starter); finish(); } } C —&gt; A 以上简单的介绍了Activity多级跳转带返回值的具体方法，如果不足，欢迎指正。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity</tag>
        <tag>Intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下adb出现no permissions问题]]></title>
    <url>%2F2016%2F05%2F31%2FLinux%E4%B8%8Badb%E5%87%BA%E7%8E%B0no%20permissions%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在linux下开发安卓的时候，有时候在连接USB调试的时候，系统出现adb no permissions 的问题，导致没有权限去调试程序？这种情况该如何处理呢？ 解决办法其实很简单，就是在终端执行下面几句adb命令即可 打开终端Linux下用Ctrl+Alt+T,打开Temimal终端 执行sudo1$ sudo su 然后回车，输入root下的密码，此时输入的密码是看不见的（退格键也属于一个密码字符），只管输入，输入完成后，回车键，如果成功的情况下就会输出下一条提示，以root@开头且以#结尾，否则就会提示你root下的密码输入错误，请重试。 执行 adb kill-server1# adb kill-server 执行 adb start-server1# adb start-server 然后下面会输出: 12* daemon not running. starting it now on port 5037 ** daemon started successfully * 以上简单的介绍了如何处理Linux下adb出现no permissions问题的具体方法，如果不足，欢迎指正。]]></content>
      <categories>
        <category>Linux</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>adb</tag>
        <tag>adb no permissions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 使用自定义Font]]></title>
    <url>%2F2016%2F05%2F30%2FAndroid-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Font%2F</url>
    <content type="text"><![CDATA[Android系统为我们提供的一些字体的同时，我们也可以自定义字体。 让我们来看一下是如何使用自定义字体的具体方法 创建一个assets文件夹如果你没有，就需要创建一个 在你的Android Studio里，选中文件 ==&gt; 项目右键 ==&gt; New ==&gt; Folder ==&gt; Asstes Folder 默认继续，==&gt; Finish 创建一个font字体文件夹 asstes ==&gt; 右键 ==&gt; new ==&gt; Directory ==&gt; 名称填入“fonts” 创建fonts文件夹完成 复制字体到fonts文件夹下 比如Material Design需要用到的Roboto字体到这里下载,下载完成后解压,复制*.ttf自定义字体到fonts文件夹下 Java 方式你可以使用Java方式来自定义字体 TextView textView=(TextView) findViewById(R.id.tv_custom_font); Typeface tf=Typeface.createFromAsset(getAssets(),"fonts/Roboto-Black.ttf"); textView.setTypeface(tf); XML 方式你也可以使用XML的方式来自定义字体 创建一个自定义的TextView类/** * Created by shoewann on 5/30/16. */ public class MyCTextView extends TextView { public MyCTextView(Context context, AttributeSet attrs) { super(context, attrs); this.setTypeface(Typeface.createFromAsset(context.getAssets(),"fonts/Roboto-Black.ttf")); } } 这个构造方法接受两个参数： Context 上下文 一个设置XML属性，这儿将会被应用到一个全新的TextView上 定义一个自定义的XML&lt;com.example.shoewann.customfont.MyCTextView android:id="@+id/tv_custom_font" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="This is Custom font TextView" android:textSize="18sp" app:layout_constraintBottom_toBottomOf="@+id/activity_main" app:layout_constraintLeft_toLeftOf="@+id/activity_main" app:layout_constraintRight_toRightOf="@+id/activity_main" app:layout_constraintTop_toTopOf="@+id/activity_main" /&gt; 默认字体在哪儿呢？打开SDK下面的platforms文件夹，在下面你会看到你安装的Android API不同平台 任意打开一个平台的版本，比如android-19文件夹（你会在android-19/data/fonts下发现): 以上简单的介绍了两种方式实现使用自定义字体的具体方法，如果不足，欢迎指正。]]></content>
      <categories>
        <category>Android 自定义</category>
      </categories>
      <tags>
        <tag>Android Customview</tag>
        <tag>Android 自定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化之——渲染篇]]></title>
    <url>%2F2016%2F05%2F29%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E7%AF%87%2F</url>
    <content type="text"><![CDATA[《Android 性能优化》学习课程是Google发布在Udacity(优城学院)的专题课程,它分别从渲染，运算与内存，电量几个方面介绍了如何去优化性能，在这之前国内腾讯的Android大牛——胡凯，对其翻译整理了一份专题博客。但是之前我一直没有博客，但是现在有了，我打算自己去学习课程，自己在他的基础上去完善总结一下相关的课程笔记，毕竟每个人获取知识的重点可能不一样。 今天就从性能优化——渲染篇，开始… 说到Android性能，不得不说一下光头哥Colt McAnlis这位大神，Colt McAnlis是在Google主要从事Android中性能相关工作的，我每次很喜欢看他讲，幽默诙谐，对Android性能方面有很深入的研究，也是我敬仰的Google大神之一 应用性能优化的步骤 获取信息 分析数据 采取行动 设计 vs 性能现在众多开发APP的公司，为了让App达到很炫丽的视觉冲击效果，会需要在界面上层叠很多的视图组件，很多开发者在开发中注重的基本上都是达到这样的功能效果仅此而已，大多数可能都不会去关心性能是如何的？ 只要App功能正常不出异常，那么这款App差不多就OK了，但是往往这样缺乏性能优化的App在用户的手上使用时，回出现各种卡顿、黑屏的情况，致使用户最终不得不卸载你的这款应用。所以我们在开发一款应用的时候，不仅要实现它的功能，性能也不要忽视。 系统会每隔16s重新绘制一次activity，1000ms/60hz=16.666ms/frame 如果在1000/60=16.67ms内没有办法把这一帧的任务执行完毕，就会发生丢帧的现象。丢帧越多，用户感受到的卡顿情况就越严重。 Android CPU 和 GPU导致卡顿的第一个原因就是：渲染 渲染操作通常依赖于两个核心组件：CPU 和 GPU CPU方面的因素：不必要的布局和失效 ，这些内容必须在视图层次结构中进行测量、清除并重新创建。一方面，重建显示列表的次数太多，另一方面花费太多的时间在作废视图层并进行不必要的重绘，使更新显示列表或者其他缓存资源时导致cpu工作过度，出现了卡顿。 GPU方面的因素：像素着色过程中，通过其他工具进行后去着色时浪费里GPU处理时间。 Activity的显示？ colt 说： 要想开发一款性能优越的应用，你必须了解底层是如何运行的。 Activity是如何绘制到屏幕上的？复杂的XML布局文件和标记语言是如何转化成用户能看懂的图像的？ 答案是：‘格栅化’操作 格栅化：将字符串、按钮、路径或者形状等拆分到不同的像素上在屏幕上进行显示。==&gt; GPU 完成这一操作 GPU使用一些指令的基础指令集，主要是多边形和纹理，也就是图片 CPU在屏幕上绘制图像前，会向GPU输入这些指令，这一过程通常使用的API就是Android的OpengGL ES UI对象 =&gt; CPU转换为多边形或者纹理 ==&gt; GPU格栅化 在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。当然随着UI组件的越来越丰富，有了更多演变的形态。例如显示图片的时候，需要先经过CPU的计算加载到内存中，然后传递给GPU进行渲染。文字的显示比较复杂，需要先经过CPU换算成纹理，然后交给GPU进行渲染，返回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。动画则存在一个更加复杂的操作流程。 为了能够使得App流畅，我们需要在每帧16ms以内处理完所有的CPU与GPU的计算，绘制，渲染等等操作。 渲染性能优化就是：尽可能地上传数据到GPU，然后尽可能长的在不修改的条件下保存数据 GPU性能问题瓶颈：过度绘制 过度绘制 定义：指的是屏幕上的某个像素点在同一帧的时间里被绘制里多次 工具：开发者选项 =&gt; “Debug GPU overdraw” ==&gt; show （1x （这个像素点被绘制了2次） 是蓝色，然后还有2x 3x 4x） 蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况，我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。 两种清除过度绘制的方法： 要从视图中清除哪些不必要的背景和图片，它们不会在最终渲染的图像中显示 对视图中重叠的屏幕区域进行定义，从而降低CPU和GPU的消耗 剪辑 剪辑：Android 设法避免绘制哪些最终界面中不显示的UI组件，你能确定某个对象会被完全阻挡，那就没必要去绘制它,这时候就需要剪辑 剪辑无法应对复杂的自定义View (比如纸牌层叠), 这时候就需要使用 Canvas.clipRect （ClipRect API 帮助系统识别出无需绘制的区域） DisplayList 定义： Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的，持有所有要交给GPU绘制到屏幕上的数据信息列表 请注意：任何时候View的绘制内容发生了变化，都需要重新执行DisplayList，并重新执行指令更新到屏幕上，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。 Hierarchy Viewer 打开步骤：Android Studio =&gt; Tools =&gt; Android =&gt; Android Devices Monitor Hierarchy的好用之处：它能帮助你从Android的角度去理解你的用户界面的结构，同时可以帮助你确定哪些视图是多余的 Venn图形图标,绿黄红三种颜色的圆点表示了渲染速度的快慢,最左边的圆点代表渲染管道的测量阶段，中间的表示布局阶段，最右边的表示渲染管道的绘制阶段 层级扁平化提升布局性能的关键点是尽量保持布局层级的扁平化，避免出现重复的嵌套布局。 以上就是个人对《Android 性能优化之——渲染篇》的主要内容进行的总结，后面有空继续总结下一篇性能优化的笔记]]></content>
      <categories>
        <category>Android 性能优化</category>
      </categories>
      <tags>
        <tag>Android Performance</tag>
        <tag>Android 性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android官方UI自动化测试框架——Espresso]]></title>
    <url>%2F2016%2F05%2F24%2FAndroid%E5%AE%98%E6%96%B9UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94Espresso%2F</url>
    <content type="text"><![CDATA[上周在美国山景城的Google公司，举办了一年一度的Google IO 大会，主要是发布一些新的产品和开发工具，以及接下来一年的发展方向。在其中也推出了Android Studio 2.2 预览版1，对其进行了强化，内置了部分新工具，比如Firebase、Espresso 测试记录器 、APK 分析器等等。正好无意中看到Espresso这部分，自己也没有使用过，那今天就来说说: Espresso ，也作为笔记记录一下 简介Espresso 测试工具，相对于其他工具，API更加精确。并且规模更小、更简洁并且容易学习。它最初是2013年GTAC大会上推出的，目标是让开发者写出更简洁的针对APP的UI测试代码。虽然针对的是开发者（Developer），但是对于测试人员来说也是可以用的。 官方文档网址： https://google.github.io/android-testing-support-library/docs/espresso/index.html 官方示例地址： https://github.com/googlesamples/android-testing 兼容性Espresso 支持以下API版本: Froyo (API 8)Gingerbread (API 10)Ice Cream Sandwich (API 15)Jelly Bean (API 16, 17 ,18)KitKat (API 19)Lollipop (API 21) 设置测试环境为你避免对测试效果的影响，需要关闭虚拟机或者物理设备上的系统动画的使用: 在你的设备上，设置 -&gt; 开发者选项 下关闭以下3个选项设置： 窗口动画缩放 -&gt; 关闭动画 过渡动画缩放 -&gt; 关闭动画 动画程序时长缩放 -&gt; 关闭动画 下载Espresso 确保你在SDK里面的Extra下已经安装了最新版本的Android Support Repository 打开你app的build.gradle文件，它通常不是位于第一个build.gradle文件，但是是app/build.gradle 添加如下行到dependencies里面: 12androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'androidTestCompile 'com.android.support.test:runner:0.5' 设置 instrumentation runner 在相同的build.gradle文件里，添加如下行到android.defaultConfig里面: 1testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" build.gradle 文件示例123456789101112131415161718192021222324252627282930313233343536apply plugin: 'com.android.application'android &#123; compileSdkVersion 23 buildToolsVersion "23.0.3" defaultConfig &#123; applicationId "com.example.shoewann.espressouiautomation" minSdkVersion 15 targetSdkVersion 23 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.4.0' compile 'com.android.support.constraint:constraint-layout:1.0.0-alpha1' testCompile 'junit:junit:4.12' // Testing-only dependencies androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2' androidTestCompile 'com.android.support.test:runner:0.5' // App's dependencies, including test androidTestCompile 'com.android.support:support-annotations:23.4.0'&#125; Espresso 基本使用方法 Espresso – 与视图（views）交互的入口，并暴露了一些视图（views）无关的API（例如回退按钮）。 ViewMatchers – 实现匹配器的一组对象。允许可以通过多次的onView方法，在层次图中找到目标视图（views）。 ViewActions – 对视图触发动作（例如点击）。 ViewAssertions – 用于插入测试关键点的一组断言，可用于判断某视图（view）的状态。 示例: 123onView(withId(R.id.my_view)) // withId(R.id.my_view) is a ViewMatcher .perform(click()) // click() is a ViewAction .check(matches(isDisplayed())); // matches(isDisplayed()) is a ViewAssertion ViewMatcher : 寻找View 根据ID找View : 1withId(R.id.my_view) 根据View的文本内容找View: 1withText("my_view_text") withText 內还可以使用其他过滤字串的方法,withContentDescription、startsWith、endsWith、equalToIgnoringCase、equalToIgnoringWhiteSpace、containsString、allOf、anyOf等等,在过滤中，也可以用 hasSibling() 、is() 、instanceOf() 等等来判断条件。如： 1withText(startsWith("MY_VIEW_TEXT") ViewAction : 操作View使用 perform() 进行想要的 ViewAction，参数可带多个，常见的有: Click（）点击操作 1onView(...).perform(click()) typeText() 、clearText() 键盘开关的操作 1onView(...).perform(typeText("I'm shoewann;"),closeSoftKeyboard()) perform(clearText()) scrollTo() Scroll View 时，此 View 必须是继承 ScrollView 且 Visibilty 为 true 的控件,若为 listView 另有方法。 swiftLeft()、swiftRight() 向左右滑动 pressKey() 键盘事件操作 如:pressBack();可单独使用，或是用 EspressoKey Builder 创建 pressKey 连续顺序键盘操作。 12345678EspressoKey.Builder builder = new EspressoKey.Builder();builder.withKeyCode(KeyEvent.KEYCODE_VOLUME_UP);builder.withKeyCode(KeyEvent.KEYCODE_MUTE);builder.withKeyCode(KeyEvent.KEYCODE_POWER);builder.withKeyCode(KeyEvent.KEYCODE_BACK);pressKey(builder.build()); ViewAssertion : 验证 View matches()：指定 View 为存在 doesNotExist ()：指定 View 为不存在 selectedDescendantsMatch()：指定 View 的 Parent View 存在 方法內依然都是传人 ViewMatcher 來找到指定的 View，若 Assert 失敗，则会跳出 Exception 并結束 Test。 示例: 12onView(withId(R.id.test_view)) .check(matches(withText("hello espresso !!"))); 用onData处理列表view示例:有一个Spinner,当item选中后，将其值显示显示在TextView上 1.点击Spinner打开选项列表 1onView(withId(R.id.spinner_simple)).perform(click()); 2.点击在item “Americano” 1onData(allOf(is(instanceOf(String.class)), is("Americano"))).perform(click()); 3.验证TextView显示的是否为点击的item 12onView(withId(R.id.spinnertext_simple)) .check(matches(withText(containsString("Americano")))); (espresso-cheat-sheet-2.1.0) 添加Espresso的TestRunner.1) 点击顶栏菜单Run-&gt;Edit Configurations; 2) 出现如下的窗口后,点击左上角绿色的“+”,选择“Android Tests”; 3) 修改新Configuration的名字,选中App Module,输入Runner,选择“Show chooer dialog”. 点击“OK”完成! 新建测试用例类.Android Studio 在创建新项目的同时会默认的创建一个android test的测试用例类在app/androidTest/java下，你可以删除了自己创建一个新的，或者修改这个存在的测试类的类名和里面的内容。 开始编写——布局文件我在这里创建了一个登录界面，来自动测试登录效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.shoewann.espressouiautomation.MainActivity" tools:layout_editor_absoluteX="0dp" tools:layout_editor_absoluteY="81dp"&gt; &lt;EditText android:layout_width="0dp" android:layout_height="wrap_content" android:inputType="textEmailAddress" android:ems="10" tools:layout_editor_absoluteX="8dp" tools:layout_editor_absoluteY="16dp" android:id="@+id/editText" android:hint="请输入邮箱号" app:layout_constraintLeft_toLeftOf="@+id/activity_main" android:layout_marginLeft="8dp" android:layout_marginStart="8dp" tools:layout_constraintLeft_creator="1" app:layout_constraintTop_toTopOf="@+id/activity_main" android:layout_marginTop="16dp" tools:layout_constraintTop_creator="1" app:layout_constraintRight_toRightOf="@+id/activity_main" android:layout_marginRight="8dp" android:layout_marginEnd="8dp" tools:layout_constraintRight_creator="1" /&gt; &lt;EditText android:layout_width="0dp" android:layout_height="wrap_content" android:inputType="numberSigned" android:ems="10" tools:layout_editor_absoluteX="8dp" tools:layout_editor_absoluteY="66dp" android:id="@+id/editText2" android:layout_margin="8dp" android:hint="请输入密码" app:layout_constraintLeft_toLeftOf="@+id/activity_main" android:layout_marginLeft="8dp" android:layout_marginStart="8dp" tools:layout_constraintLeft_creator="1" app:layout_constraintTop_toBottomOf="@+id/editText" android:layout_marginTop="8dp" tools:layout_constraintTop_creator="1" app:layout_constraintRight_toRightOf="@+id/activity_main" android:layout_marginRight="8dp" android:layout_marginEnd="8dp" tools:layout_constraintRight_creator="1" /&gt; &lt;Button android:text="登录" android:layout_width="wrap_content" android:layout_height="wrap_content" tools:layout_editor_absoluteX="16dp" tools:layout_editor_absoluteY="123dp" android:id="@+id/button" android:layout_margin="8dp" app:layout_constraintLeft_toLeftOf="@+id/activity_main" android:layout_marginLeft="16dp" android:layout_marginStart="16dp" tools:layout_constraintLeft_creator="1" app:layout_constraintTop_toBottomOf="@+id/editText2" android:layout_marginTop="15dp" tools:layout_constraintTop_creator="1" /&gt; &lt;TextView android:text="状态：未登录" android:layout_width="wrap_content" android:layout_height="wrap_content" tools:layout_editor_absoluteX="8dp" tools:layout_editor_absoluteY="187dp" android:id="@+id/textView" app:layout_constraintLeft_toLeftOf="@+id/activity_main" android:layout_marginLeft="8dp" android:layout_marginStart="8dp" tools:layout_constraintLeft_creator="1" app:layout_constraintTop_toBottomOf="@+id/button" android:layout_marginTop="16dp" tools:layout_constraintTop_creator="1" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 开始编写——代码源文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private EditText et_email,et_pwd; private Button btn_login; private TextView tv_status; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; public void initView()&#123; et_email= (EditText) findViewById(R.id.editText); et_pwd= (EditText) findViewById(R.id.editText2); btn_login=(Button) findViewById(R.id.button); tv_status=(TextView)findViewById(R.id.textView); &#125; public void initData()&#123; btn_login.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.button: String getEmail=et_email.getText().toString(); String getPwd=et_pwd.getText().toString(); if(TextUtils.isEmpty(getEmail) || TextUtils.isEmpty(getPwd))&#123; ShowLoginFailed(); return; &#125;else if (!getEmail.equals("xuwang0402@gmail.com")|| !getPwd.equals("1234567890"))&#123; ShowLoginFailed(); &#125;else &#123; ShowLoginSuccessful(); &#125; break; default: break; &#125; &#125; public void ShowLoginSuccessful()&#123; tv_status.setText("登录状态:登录成功,欢迎回来~"); &#125; public void ShowLoginFailed()&#123; tv_status.setText("登录状态:登录失败,帐号或密码不合法,请重试！"); &#125;&#125; 开始编写——测试用例1) 首先创建一个@Rule,ActivityTestRule用来指明被测试的Activity;2) 测试用例的方法都是@Test的Annotation注解的,方法名字可以随意. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import android.support.test.filters.MediumTest;import android.support.test.rule.ActivityTestRule;import android.support.test.runner.AndroidJUnit4;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.runner.RunWith;import static android.support.test.espresso.Espresso.onView;import static android.support.test.espresso.action.ViewActions.clearText;import static android.support.test.espresso.action.ViewActions.click;import static android.support.test.espresso.action.ViewActions.closeSoftKeyboard;import static android.support.test.espresso.action.ViewActions.typeText;import static android.support.test.espresso.assertion.ViewAssertions.matches;import static android.support.test.espresso.matcher.ViewMatchers.withId;import static android.support.test.espresso.matcher.ViewMatchers.withText;/** * Instrumentation test, which will execute on an Android device. * * @see &lt;a href="http://d.android.com/tools/testing"&gt;Testing documentation&lt;/a&gt; */@MediumTest@RunWith(AndroidJUnit4.class)public class MainActivityUITest &#123; private String testEmail_correct,testPwd_correct,tv_status_incorrect; private String testEmail_incorrect,testPwd_incorrect,tv_status_correct; @Rule public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(MainActivity.class); @Before public void initLogInAccountInfo()&#123; //incorrect testEmail_incorrect="zhangsan@gmail.com"; testPwd_incorrect="123456"; tv_status_incorrect="登录状态:登录失败,帐号或密码不合法,请重试！"; //correct testEmail_correct="xuwang0402@gmail.com"; testPwd_correct="1234567890"; tv_status_correct="登录状态:登录成功,欢迎回来~"; &#125; @Test public void testLogInMethod()&#123; //incorrect onView(withId(R.id.editText)).perform(typeText(testEmail_incorrect), closeSoftKeyboard()); onView(withId(R.id.editText2)).perform(typeText(testPwd_incorrect), closeSoftKeyboard()); onView(withId(R.id.button)).perform(click()); onView(withId(R.id.textView)).check(matches(withText(tv_status_incorrect))); //clearEditText onView(withId(R.id.editText)).perform(clearText()); onView(withId(R.id.editText2)).perform(clearText()); //correct onView(withId(R.id.editText)).perform(typeText(testEmail_correct), closeSoftKeyboard()); onView(withId(R.id.editText2)).perform(typeText(testPwd_correct), closeSoftKeyboard()); onView(withId(R.id.button)).perform(click()); onView(withId(R.id.textView)).check(matches(withText(tv_status_correct))); &#125;&#125; 在这里我用了一个正确的帐号和一个错误的帐号来自动化模拟登录效果，系统会先自动输入错误的邮箱号码和密码，然后自动点击登录,然后自动获取到显示文本上的内容判断是否和我预期定义的一致，然后自动清除账号和密码输入框，重新自动输入正确的帐号密码，然后自动点击登录,然后自动获取到显示文本上的内容判断是否和我预期定义的一致，达到自动化测试的效果。 Espress推荐写测试用例的时候使用static import来简化代码.在Android Studio中,static import的快捷键是,当你输入了”onView”,然后按键盘的Alt+Enter会出现一个菜单选static import那个就OK了的! 运行测试用例,查看运行结果.展开下拉列表，选择我们刚刚创建的测试类的对应模块的名字 “appTest” 可以看到所有测试已通过]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android UI Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Studio-2-2-预览版-——-新的UI设计器和约束布局]]></title>
    <url>%2F2016%2F05%2F20%2FAndroid-Studio-2-2-%E9%A2%84%E8%A7%88%E7%89%88-%E2%80%94%E2%80%94-%E6%96%B0%E7%9A%84UI%E8%AE%BE%E8%AE%A1%E5%99%A8%E5%92%8C%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[原文来自：ByJamal Eason, Product Manager, Android ———— Android Studio 2.2 Preview - New UI Designer &amp; Constraint Layout 在这周的2016 Google I/O大会上我们已经启动了Android Studio 2.2 预览版.这次公布了一个重大的升级，就是我们重点关注于打造一个快速和高效的Android集成开发环境（IDE）。同步了Android开发平台，Android Studio允许你利用最新版本的Android API和新特性去开发。从3年前的Google I/O上启动了Android Studio，针对于每个人想要什么样的功能特性，我们收到了很棒的反馈。如今在Google Play上排在前面的125个应用和游戏，92%的开发者，数百万的开发者，都是使用的Android Studio。我们要继续为Android加强功能特性，并将继续让你更有效率，更富有成效的开发。 Android Studio 2.2预览版包括了一个伴随着范围开发的组合新特性, 对于你的应用程序利用全新的方法，分类从用户界面设计到构建再到调试，对于预览版本包括了以下的一些新功能特性的分类： 设计 布局编辑器：一个全新的用户界面设计器，能帮助你在你的应用程序里直观的设计布局。功能特性像蓝图模式和全新的属性配置面板允许你更加快速的编辑布局和小部件. 约束布局：一个全新的强大灵活的Android布局允许你展现出没有嵌套多个布局的复杂的用户界面。 审查布局：一个在你的Android模拟器或者真机设备上运行你的应用程序布局的调试快照，审查视图结构和相应的代码属性。 开发 Firebase 插件：通过Firebase提供的资源套装组合并内置在Android Studdio里面，添加像Analytics分析服务、认证、通知和广告仅仅只需要点击几下。 增强的代码分析：Android Studio 检查你的Android应用程序代码质量，这里除了260个Android Lint和代码检查，还包括公布的为了Java 8语言全新代码的检查，使用和更多的跨文件分析的新的检查基础的设施。 浏览器示例：引用Android 示例代码如今是很便利的了，内置了代码编辑窗口，在谷歌安卓代码示例上去寻找你应用程序需要的代码片段，帮助你在开发你的应用程序中有一个好的跨越。 提升对C++的支持：Android Studio 2.2提高了C++开发的编辑、构建、调试现有Android项目的能力,利用的是ndk-build或者CMake，而不是Gradle。另外，现有的lldb C++ 调试器是如今最好的项目类型自动识别器，在java语言里察觉C++,让你使用一个单一的调试器进程就可以连同java和C++语言运行时一起检查 Intellij 2016.1：Android Studio 2.2 包括了JetBrains的Intellij平台从底层最新版本的所有东西。 构建 Jack编译器的改进：这里使用全的Jack编译器，Android Studio 2.2添加了对注释处理的支持，以及增量编译以降低编译时间。 合并清单的查看器：通过你的项目构建变种，利用你的应用程序依赖来诊断你的AndroidManifest.xml合并。 测试 Espresso 测试记录：作为一个普通人来使用你的应用程序只是简单的使用Espresso 用户界面测试来记录。作为你点击了你的应用程序用户界面，然后为你生成可以重复使用的和可以编辑的测试代码，你可以在本地运行生成来测试，在你连续不断的集成环境中，或者在Firebase 测试实验室 APK分析器：钻进你的APK应用重新中去帮助你降低APK应用程序的大小，调试64K方法的限制问题，查看Dex文件或者其他更多的。 更加深入地了解了新功能设计布局编辑器Android Studio 2.2的功能特性——新的用户界面设计器，有很多的改进，但是一些亮点包括： 从设计图面或者组件树视图拖放控件到你的应用程序 对于检查你的布局的间距和排版，设计面有了一个蓝图模式 属性配置面板现在能够显示属性配置组，对于快速编辑控件利用一个完整的配置表点击即可 UI生成器能够编辑菜单和系统偏好文件. (Android Studio 2.2 Preview 里新的布局编辑器) (新布局编辑器里的菜单编辑) 约束布局这种全新的布局对于你的应用来说是一个灵活的布局管理器，它允许你动态创建多个无嵌套的用户界面。它作为一个支持库分布在Android Studio中, 且支持API 9向后兼容。 乍一看，约束有点内类似于RelativeLayout. 然后，约束布局被设计在Studio中使用，它能够有效的表现出你的应用程序的设计，因此依靠较少的去使用像LinearLayout, FrameLayout, TableLayout,或者GridLayout的布局。最后，它还内置了自动约束引擎。你可以根据你直接的偏好去随时设计你的用户界面,让Android Studio努力工作起来 为了帮助你开始，在Android Studio 2.2 预览版中，新建项目向导的时候，现在内置模板能生成一个约束布局。或者，你可以在一个新的布局编辑器里右键任意布局，然后选择Convert to ConstraintLayout 选项。 这是一个早期预览版的UI设计器和约束布局，我们将加大速度在即将发布的版本中增加附件的东西，在Android Studio 工具站点查看更多。 (约束布局) 审查布局对于一个新的和已经存在的布局，很多时间你或许想要调试你的应用程序用户界面，以确定是否按照预期的布局呈现出来.利用新的布局审查工具，你能够深入到你的应用程序的视图层级下，分析屏幕上UI的每一个组件的属性。 (开始一个布局的审查) (布局审查) 开发Firebase 插件firebase是一个开发者服务新套装，能够帮助你开发高质量的应用程序 ，让你的用户数据库增长，并且赚更多的钱。在Android Studio里面，你利用新的助理窗口添加了Firebase到一个全新的或者已经存在的Android应用程序中。对于访问Firebase功能特征在点击菜单Tools然后选择Firebase.你会希望先设置好全新的Firebase分析,为你探索其他Firebase服务像Firebase云消息或者Firebase崩溃报告添加到你的应用重新作为基础。学习更多有关Android Studio整合Firebase的信息看这里 (为Android Studio 整合的Firebase插件) 代码示例浏览器除了导入Android Studio 是示例代码，代码示例浏览器在Androdi Studio 2.2 Preview里面是一个菜单选项，允许你依靠高质量，Google 提供的Android 代码样本示例中高亮的代码片段添加到你的项目中去。对于使用这个功能特性,高亮的变量、类型和方法在你的代码中，然后右键显示一个菜单去查找示例代码。 (代码样本浏览器) 构建CMake 和 NDK-Build对于那写使用过NDK的，现在Android Studio通过现有的Gradle支持CMake和NDK-Build Android应用程序项目在你存在的构建文件，一旦你添加了你的CMake或者NDK-Build项目到你的Gradle,Android Studio将会自动的打开你的Android相关代码在Studio里面进行编辑和调试。 对于CMake用户，仅仅是在你的Gradle文件的externalNativeBuild部分添加你的CMList.txt文件路径: (在Android Studio中的CMake) 对于NDK-Build用户，仅仅是在你的Gradle文件externalNativeBuild部分添加你的*.mk文件路径: (在Android Studio中的CMake) Jack 工具的增强新的Jack编译器编译你的Java语言源文件到Android dex字节码.Jack 编译器允许一些Java 8 语言的特性，像lanmbdas,在Android所有版本中都能够使用.此版本增加了增量构建和完全支持注释处理，所以你能够使用Java 8 语言特性到你已经存在的项目资源中 如下在你的build.gradle文件中使用Jack增量编译: (启用Jack增量编译选项) Jack 将会自动应用注解处理器在类路径中，要使用在编译时注释处理器，而无需在APK捆绑它，利用全新的注解处理器依赖范围: (启用Jack注解处理器) Manifest 合并查看器弄清楚你的项目依赖基于编译类型等是如何合入AndroidManifest，现在利用Android Studio就很简单了，导航到你AndroidManifest.xml，然后点击合并后的新的清单底部标签，探索你AndroidManifest上的解析每一个节点如何与不同项目依赖 (清单合并查看器) 测试Espresso 测试记录器有的时候写一个用户界面测试是很乏味的，利用Espresso UI 测试记录功能，创建测试现在和使用你的应用程序一样简单了，Android Studio 将会捕获你所有的UI交互，并将其转换为一个完全可以重用的Espresso测试，你可以在本地或者甚至在Firebase 测试实验室上去运行它们，要使用记录器，转到Run菜单，选择Record Espresso Test (Espresso 测试记录器) APK 分析器新的APK分析器可以帮助您了解您的APK内容、不同组件的大小。你也可以用它来避免你的Dex文件64K参考方法的限制的问题，诊断ProGuard的配置问题，鉴于合并AndroidManifest.xml文件，并检查编译资源文件（resources.arsc）。这可以帮助你减少你的APK大小，并确保您的APK包含的东西，正是你期待的事情。 该APK分析器显示你的原始文件的大小以及在下载你的APK后各种组成部分的大小。预计当用户下载存放APK在Google Play服务器上的大小，这些信息可以帮助你优先考虑哪些地方需要集中去减少占用量。 要使用这项新功能，单击Build菜单上，选择分析Analyze APK…然后，选择要分析的APK。 (APK分析器) Java-察觉 C++ 调试器当你运行在N或者更高的目标版本上调试C++代码，你现在可以使用一个单一的调试器，Java语言能够感知lldb实例.这个调试器继续大大的支持lldb功能，如快速的步骤和内存观测点，也允许你停止对Java语言的断点，并查看你的Java语言内存上的内容 自动调试选择Android Studio 现在能够使用 “自动” 调试器调试应用，这里将会自动的启动相应的调试器,如果启用了其他C++项目混合调试器，Java语言是能够感知C++调试器的。 (为C++启用自动调试器) 接下来做什么下载如果你是用的之前上一个版本的Android Studio，你可以在菜单导航栏Canary通道使用检查更新(Help–&gt;Check for Update(Windows/Linux)，Android Studio–&gt;Check for Updates(OSX))，这个升级将会下载一个全新的版本，没有增量更新到你已经存在的Android Studio中，你也可以从Canary发布站点下载Android Studio 2.2 Preview 对于Android Studio 2.2 Preview，我们建议你在运行新的Canary版本的同时，也运行一个Stable稳定版本的Android Studio ,到工具站点检出如何在同一时间运行两个版本的Android Studio 我们很欣赏你们反馈的任何你们遇到问题、觉得看到喜欢的新特性，联系我们 —— Android Studio 开发团队—— 我们在Google+ 或者 Twitter上]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO-2016-Android-更新了什么？]]></title>
    <url>%2F2016%2F05%2F19%2FIO-2016-Android-%E6%9B%B4%E6%96%B0%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文来自：Google Android developer Blog —— What’s new in Android: the N-Release, Virtual Reality, Android Studio 2.2 and more 在过去的一年中,在Google Play上像你一样通过安装开发者构建的应用程序的Android用户，全球安装量已经超过了650亿。在Android排在前面的应用帮助里开发者继续去构建卓越的经历。今天在Google I/O上，我们宣布了一系列新的东西，我们在这些平台上去做，包括Android N下一个版本的开发者预览版，一个Android系统集成虚拟现实的延伸，一个Android Studio的更新升级 以及更多！ Android N : 性能、效率和安全性利用Android N,我们想实现一个全新级别的Android产品挑战，因此对于平台我们将搬出一些十分深度的技术，重写和重新设计一些系统如何工作的基本方面，对于Android N ,我们主要集中在三大关键主题上:性能、效率以及安全.第一个Android开发者预览版包括了一个全新的品牌JIT编译器，对于提高软件性能、使应用程序安装的更加快，并且占用更少的存储空间。第二个Android N 的开发者预览版包括了Vulkan,一个全新的3D渲染API帮助游戏开发者在手持设备上传递高性能图像。这两次的预览版也给Android带来了提高效率有用的东西，包括了多窗口支持和直接回复 Android N也添加了一些新的特性去帮助用户保持最快和更安全，通过如何在Chromebooks上应用更新的方法受到了启发，我们采用无缝升级，因此新的Android设备在N上面构建将在后台执行安装系统升级。这将意味着下一个时间用户开机他们的设备，新的设备能够自动无缝切换到新的更新后的系统映像。 今天公布的Android N 预览版3是我们第一个beta测试版本,在你的常用手机或者平板上可用来进行测试，你可以选择到Android测试程序在android.com/beta，然后在你的Nexus6,9,5X,6P,Nexus Player,Pixel C,和Android One（一般的移动4G）.通过邀请更多的人去尝试这个公布的测试，开发者能够期望看到你的应用程序在Android N上的用法去提升。如果你有一个Android应用程序,你应该去测试，看它在Android N上是如何工作的，并且也能从用户那儿得到反馈信息。 Android中的虚拟现实模式Android 为了当今的多屏世界而构建；事实上，Android工作在你的手持设备，你的平板，在你的手腕上看，它甚至工作在你的汽车里和你的市内。同时帮助你在所有设备中每个之间个无缝移动，当我们展望下一部是什么的时候，我们相信你的手机能够成为很厉害看世界和新虚拟内容体验，更逼真的方式的新道路，但是，直到此时，高品质的移动VR贯穿整个Android生态系统是不可能的。那是因为我们将在Android N的任务中去完成所有的级别任务——从操作系统如何读取传感器数据，如何发送像素去显示——利用Android中的VR虚拟现实模式，提供高质量的移动VR虚拟现实体验，使它特别内置。这儿有专门为开发人员性能增强设计，包括一个单缓冲渲染和访问一个独有的CPU核心的VR虚拟显示应用程序，在你的应用程序里面，你能利用流畅的头部跟踪和立体声通知进行工作对于虚拟现实。最重要的是，Android N 提供了一个非常低的图形延迟；事实上，在Nexus 6P上运行开发者预览版3光子运动延迟小于20毫秒，建立必要的速度沉浸，然用户能够感觉到他们其实在另外一个地方，我们将在明天上午9点开始,从Google IO 直播的谷歌虚拟现实专题里升级覆盖所有全新的VR虚拟现实。 Android瞬间应用程序:真实的应用程序，没有安装我们想让用户发现和使用的应用程序变得更加的简单，你的应用程序轻轻一按会怎样？如果用户没有所有都安装呢？今天，我们介绍Android瞬间应用程序作为我们努力发展方式的一部分，我们想想应用，是否有人发现从搜索，社交媒体，短信或其他深层链接您的应用程序，他们将能够体验到快速和强大的原生Android应用程序，而无需停下来先安装您的应用程序或重新认证。最好的，Android瞬间应用程序它利用Google服务并能兼容运行在果冻豆（Android 4.1+）或者更高的所有Android 设备上。Android瞬间应用程序功能是升级到您现有的Andr​​oid应用程序，而不是一个新的，独立的应用程序;你可以早些登录请求访问这篇文档 Android可穿戴设备2.0：UI改变和应用重新独立今天早上在google IO大会上，我们也公布了Android可穿戴设备上自从启动了两年以来的大多数重大更新Android 可穿戴设备2.0，根据我们已经从用户和开发人员了解到，我们正在不断发展的平台，提高关键腕表体验：表盘、信息和健康，我们也制作了大量的UI改变和升级我们的设计指南，让你的应用程序更加一致、直观，美观。利用可穿戴设备2.0，应用程序可以是独立的，并且具有通过蓝牙，Wi-Fi或蜂窝连接直接网络接入到云中。由于您的应用程序将不必依赖于数据层的API，它可以继续提供，即使配对的电话是远或关闭的全部功能。你可以在这里在今天的预览版阅读所有可用的新特性 Android Studio 2.2 预览版: 全新的布局设计，布局约束，以及更多 速度: 全新的布局设计和布局约束，即时测试记录，编译速度更快 能干：Apk应用重新分析、布局审查，扩大Android的代码分析和IntelliJ 2016.1 平台支持：增强Jack编译/Java 8 的支持,利用CMake和NDK-Build扩大C++的支持,Firebase支持和无障碍的支持]]></content>
      <categories>
        <category>Google IO</category>
      </categories>
      <tags>
        <tag>google io</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android浅谈任务和返回栈]]></title>
    <url>%2F2016%2F05%2F17%2FAndroid%E6%B5%85%E8%B0%88%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E6%A0%88%2F</url>
    <content type="text"><![CDATA[(…..咳咳, 别点了，上面这个只是一个截图而已. @_@! ) 原文来自：Google Android developer by lan Lake —— Tasks and the Back Stack 当我们点击了launcher桌面上App应用程序实际上发生了什么呢？如果你说“我的应用程序启动起来了”，你在技术上是正确的，也是在所有回答类别中最佳的一个.如果我们在深入一点，我们利用返回这件小事情去看看，它对我们理解什么是任务以及它是如何去交互的会有帮助的 任务一个任务是围绕着一个活动栈元数据和信息的集合（你可以查看RecentTaskInfo类获取更准确的数据）。 所以当你点击了launcher桌面上你的App应用程序，系统其实会开始去上一个已经存在的任务（通过Intent意图和Activity活动来指向确定) 去恢复—— 然你回到你该回到的地方.如果任务中没有存在可以被发现，然后利用最新启动的Activity作为基类Activity，一个新的任务就在任务的返回栈里被创建了。 返回栈你或许会想象，返回键一个任务的返回栈是捆绑在一起的，但是它是双向的，当你开始利用startActivity()启动一个新的activity,将会（默认情况下）推送出一个新的activity在你的任务之上，原因是上一个Activity 已经被暂停了（如果这个新的activity完全掩盖了上一个activity，就被停止了）。 当操作返回键时（默认情况下）然后会‘抛出’任务，在最顶端的activity将会调用finish(),销毁它并且从返回栈中移除，同时带你返回上一个activity。重复这样操作直到在返回栈中不会留下任何东西了，你也就将回到launcher桌面上了。 返回栈和Fragments返回栈不是仅仅用于activity上：它也应用于fragments。当你提供一个fragment transaction从你的用户界面去添加，替换，或者移除一个fragment，你能够使用addToBackStack()去有效添加FragmentTransaction到你的返回栈 当你使用这种方式，返回键被点击中，FragmentTransaction 将会被反向（一个添加的fragment被移除，一个替换的fragment被还原，或者一个被移除掉的fragment被重新添加）。每一个事务被添加到返回栈是被反向翻转的，直到默认的activity被finish结束的那个时候，它们所有才会被移除，再次放进来将会重复表现。 返回不是唯一的导航键当然，在一个现代化的Android设备里（我们不去过多的讨论有关menu button相关的东西）返回键不是唯一的导航键。 home 键可能是最简单的，它是单焦点：它放置当前任务到后台，然后带着你回到你的launcher桌面上。 笔记:移动你的任务到后台，不会杀死你的任务（虽然最顶端的activity肯定被暂停+被停止）: 它将一直存活直到Process(进程)被杀死。在‘Who lives and who dies ?(谁活着，谁灭亡？)这篇博客优先学习更多有关进程和什么时候你的app应用会被杀死。 overview 键(最近任务)，带领你，你或许会想象，对于Overview screen,这是在Android世界里的’应用程序切换器’—— 在这儿你将会看到你最近的任务，也能够选择其中的一个带它返回到前台。 ##好了，就是它们这些了，没有更多可以看的了梳理一下，startActivity()或addToBackStack()返回键默认的特性。这儿没有什么特别的，但没有任何混淆 —— 这些对称，一致的行为作为默认。在多数情况下，你应该使用这些默认的特性 在你直接运行和复写onBackPressd()之前，这儿有一些特殊的情况你或许要去是考虑一下： 防止返回键疲劳过度当然，当你需要按10+次走出你在哪里，返回按钮会失去了一些光泽，另一种情况，当你启动的是当前同一个activity，这是很容易避免的， 创建一个任务多个复制相同Activity,（无论是从内存压力还是返回键疲劳过度都一起减少了）你的Activity能够在AndroidManifest使用launchMode=”singleTop”或者你能够在你的Intent意图里添加Intent.FLAG_ACTIVITY_SINGLE_TOP 在顶部返回栈防止同一个activity拷贝多个副本，利用new Intent 和任意的extras你将会在onNewIntent()中得到一个回调。 笔记:在读onNewIntent()文档时小心：getIntent()将一直返回原始的Intent除非你使用setIntent()去重写它 返回栈和通知如果你将在你的应用里构建一个通知指定一个Activity，这里有一种情况要避免:点击返回键直接回到launcher桌面上。当你利用一个基本的activity提供一个PendingIntent开启一个新的任务会出现这种情况，除非你的通知是打开你的启动activity,这不是你想要的。如果它们作为导航到应用本身重新的那一部分，用户应该是明确目标地点的，你的通知仅仅是保存了它们的中间步骤。 对于某些事情是如此的重要，有一个类它将会为你完成所有的任务这将是非常好的。进入TaskStackBuilder: 一个处理标志和返回栈的特殊类，对于你对于这种情况： // Construct the Intent you want to end up at Intent detailActivity = new Intent(this, DetailActivity.this); // Construct the PendingIntent for your Notification TaskStackBuilder stackBuilder = TaskStackBuilder.create(this); // This uses android:parentActivityName and // android.support.PARENT_ACTIVITY meta-data by default stackBuilder.addNextIntentWithParentStack(detailActivity); PendingIntent pendingIntent = stackBuilder .getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT); 你将在使用addNextIntentWithParentStack()方法时注意 —— 这个方法在正常Intent意图，你将创建了一个PendingIntent去构建一个完整的任务栈刚好通过的捷径。虽然它有一个要求：每一个activity需要有一个它的父activity定义在Androidmanifest(从这篇文档中看示例代码)。 如果在你情况下默认不工作，你不需要抛出TaskStackBuilder:editIntentAt()允许你回收一个特殊的Intent意图并设置action动作，设置data URL数据地址，或者add extras传一个值。如果你需要甚至更多的定制，你可以放弃使用*ParentStack()方法完全直接使用 addNextIntent()添加确切你需要的Intent到你的具体情况 笔记:如上所述在文档里,对于其他类型的activity你或许从一个特殊的notification通知(i.e，没有在你正常的应用重新流程下的一个通知)去启动。这个或许是一个例子，环聊的（Hangout’s）直接回复像一个activity在Android N之前。这些acitivities是通常半透明 —— 你能看到其他的app应用程序在你的activity下面 —— 同时一般没有任何返回栈合成或者新的任务和它们关联。 任务和返回栈，一起工作记住这个部分已经被预测很重要，如果将是使用你的返回栈乱搞，请确保测试非常彻底，以确保最佳的用户体验。 翻译有限，不足之处，欢迎指正]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>task</tag>
        <tag>stack</tag>
        <tag>任务</tag>
        <tag>返回栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google官方Android开源库--FlexboxLayout]]></title>
    <url>%2F2016%2F05%2F16%2FGoogle%E5%AE%98%E6%96%B9Android%E5%BC%80%E6%BA%90%E5%BA%93-FlexboxLayout%2F</url>
    <content type="text"><![CDATA[原文来自： Flexbox-layout 什么是Flexbox？Flexbox 布局模型宗旨是对于在一个flex容器平铺出flex项提供更多高效的方法，即使flex项的大小未知.因此，它提供了更有效的方法,利用已存在的布局去实现响应式用户界面. 布局模型 安装Gradle依赖1234dependencies &#123; compile 'com.google.android:flexbox:0.1.2'&#125; 用法FlexboxLayout像LinearLayout和RelativeLayout一样继承了ViewGroup，你可以在一个XML中像这样指定属性: 123456789101112131415161718192021222324252627282930&lt;com.google.android.flexbox.FlexboxLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" app:flexWrap="wrap" app:alignItems="stretch" app:alignContent="stretch" &gt; &lt;TextView android:id="@+id/textview1" android:layout_width="120dp" android:layout_height="80dp" app:layout_flexBasisPercent="50%" /&gt; &lt;TextView android:id="@+id/textview2" android:layout_width="80dp" android:layout_height="80dp" app:layout_alignSelf="center" /&gt; &lt;TextView android:id="@+id/textview3" android:layout_width="160dp" android:layout_height="80dp" app:layout_alignSelf="flex_end" /&gt;&lt;/com.google.android.flexbox.FlexboxLayout&gt; 或者在代码中，像这样： FlexboxLayout flexboxLayout = (FlexboxLayout) findViewById(R.id.flexbox_layout); flexboxLayout.setFlexDirection(FlexboxLayout.FLEX_DIRECTION_COLUMN); View view = flexboxLayout.getChildAt(0); FlexboxLayout.LayoutParams lp = (FlexboxLayout.LayoutParams) view.getLayoutParams(); lp.order = -1; lp.flexGrow = 2; view.setLayoutParams(lp); 支持的属性对于一个FlexboxLayout，你能指定以下的属性： 1.flexDirection 子项的方向是摆放在Flexbox布局里面的，它决定里主轴线的方向（和十字交叉轴，垂直于主轴线），可能的值是： row (default) 主轴为水平方向，起点在左端 row_reverse 主轴为水平方向，起点在右端 column 主轴为垂直方向，起点在上沿 column_reverse 主轴为垂直方向，起点在下沿。 2.flexWrap 这个属性控制着flex容器是单行还是多行，方向是十字交叉轴可能的值是： nowrap (default) 不换行 wrap 按正常方向换行 wrap_reverse 按反方向换行 3.justifyContent 这个属性控制着主轴线的边缘对齐方式，可能的值是： flex_start (default) 左对齐 flex_end 右对齐 center 居中 space_between 两端对齐 space_around 每个子项两侧间的间距离相等 4.alignItems 这个属性控制着十字轴的边缘对齐方式，可能的值是： stretch (default) 如果子项没有设置高度或者设为auto，将占满整个容器的高度 flex_start 交叉轴的起点中对齐 flex_end 交叉轴的终点对齐 center 交叉轴的中点对齐 baseline 项目的第一行文字的基线对其 5.alignContent 这个属性控制着flex行和flex容器的边缘对齐方式，可能的值是： stretch (default) 轴线占满整个交叉轴 flex_start 与交叉轴的起点对齐 flex_end 与交叉轴的终点对齐 center 与交叉轴的终点对齐 space_between 与交叉轴两端对齐，轴线之间的间隔平均分配 space_around 每根轴线两侧的间隔相等 你也可以在FlexboxLayout中指定以下的属性： 1.layout_order 这个属性是能够改变子视图如何平铺的顺序. 默认你情况下，子视图显示和平铺顺序在布局XML文件中呈现的是相同的，如果不是指定情况下，1是它默认设置的值 2.layout_flexGrow 这个属性定义项目的放大比例，即如果存在剩余空间，也不放大，0是它默认设置的值 3.layout_flexShrink 这个属性定义了项目的缩小比例，即如果空间不足，该项目将缩小，0是它默认设置的值负值对该属性无效。 4.layout_alignSelf 这个属性确定（垂直于主轴线）沿着横轴的对齐。在同一方向上的对准可由父视图的alignItems确定，但是如果这是设置为auto以外的值，对于这个子视图来说十字轴对准是要被重写。可能的值有： auto (default) (自动) flex_start （与交叉轴的起点对齐） flex_end（与交叉轴的终点对齐） center（与交叉轴的中点对齐） baseline（与第一行文字的基线对齐） stretch （如果子项没有设置高度或者设为auto，将占满整个容器的高度） 5.layout_flexBasisPercent 在一个分数格式中初始化flex项的长度，相对于父视图.该子视图的初始大小主要是试图扩大作为对父视图主要尺寸为指定的分数.如果这个值设置了，通过layout_width (或者 layout_height)这个属性计算值重写来指定长度.这个属性仅仅当它的父视图长度定义了(MeasureSpec 模式是MeasureSpec.EXACTLY）时才有效.默认值是-1，意味着没有设置 跟传统已知的CSS的区别 没有flex-flow属性 没有flex属性 layout_flexBasisPercent代替 flexBasis 最小宽度和最小高度不能被指定]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>library</tag>
        <tag>flexbox-layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的进程与线程]]></title>
    <url>%2F2016%2F05%2F15%2FAndroid%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[节选来自：Android 官方文档- Process And Thread 当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。 如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。 但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。 本文档介绍进程和线程在 Android 应用中的工作方式。 进程（Process）默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。 但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。 各类组件元素的清单文件条目— activity 、service、receiver和provider—均支持android:process属性，此属性可以指定该组件应在哪个进程运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外，您还可以设置 android:process，使不同应用的组件在相同的进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。 此外，application 元素还支持 android:process 属性，以设置适用于所有组件的默认值。 如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。 决定终止哪个进程时，Android系统将权衡它们对用户的相对重要程度。例如，相对于托管可见 Activity 的进程而言，它更有可能关闭托管屏幕上不再可见的 Activity 进程。 因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。 下面，我们介绍决定终止进程所用的规则。 进程生命周期（Process Lifecycle）Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要清除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。 重要性层次结构一共有 5级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）： 1.前台进程 用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程： 托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法） 托管某个 Service，后者绑定到用户正在交互的 Activity 托管正在“前台”运行的 Service（服务已调用 [startForeground()](https://developer.android.com/reference/android/app/Service.html#startForeground(int, android.app.Notification))） 托管正执行一个生命周期回调的 Service（onCreate()、[onStart()](https://developer.android.com/reference/android/app/Service.html#onStart(android.content.Intent, int)) 或 onDestroy()） 托管正执行其 [onReceive()](https://developer.android.com/reference/android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent)) 方法的 BroadcastReceiver 通常，在任意给定时间前台进程都为数不多。只有在内在不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。 2.可见进程 没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程： 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况 托管绑定到可见（或前台）Activity 的 Service 可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。 3.服务进程 正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。 4.后台进程 包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅Activity文档。 5.空进程 不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。 根据进程中当前活动组件的重要程度，Android会将进程评定为它可能达到的最高级别。例如，如果某进程托管着服务和可见Activity，则会将此进程评定为可见进程，而不是服务进程。 此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。 由于运行服务的进程其级别高于托管后台 Activity 的进程，因此启动长时间运行操作的 Activity 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 Activity 更加持久时尤要如此。例如，正在将图片上传到网站的 Activity 应该启动服务来执行上传，这样一来，即使用户退出 Activity，仍可在后台继续执行上传操作。使用服务可以保证，无论 Activity 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。 线程 （Thread） 应用启动时，系统会为应用创建一个名为“主线程”的执行线程。 此线程非常重要，因为它负责将事件分派给相应的用户界面小工具，其中包括绘图事件。 此外，它也是应用与 Android UI 工具包组件（来自 android.widget 和 android.view 软件包的组件）进行交互的线程。因此，主线程有时也称为 UI 线程。 系统绝对不会为每个组件实例创建单独的线程。运行于同一进程的所有组件均在 UI线程中实例化，并且对每个组件的系统调用均由该线程进行分派。因此，响应系统回调的方法（例如，报告用户操作的 [onKeyDown()](https://developer.android.com/reference/android/view/View.html#onKeyDown(int, android.view.KeyEvent)) 或生命周期回调方法）始终在进程的 UI 线程中运行。 例如，当用户触摸屏幕上的按钮时，应用的 UI 线程会将触摸事件分派给小工具，而小工具反过来又设置其按下状态，并将无效请求发布到事件队列中。UI 线程从队列中取消该请求并通知小工具应该重绘自身。 在应用执行繁重的任务以响应用户交互时，除非正确实施应用，否则这种单线程模式可能会导致性能低下。 特别地，如果 UI 线程需要处理所有任务，则执行耗时很长的操作（例如，网络访问或数据库查询）将会阻塞整个 UI。一旦线程被阻塞，将无法分派任何事件，包括绘图事件。从用户的角度来看，应用显示为挂起。 更糟糕的是，如果 UI 线程被阻塞超过几秒钟时间（目前大约是 5 秒钟），用户就会看到一个让人厌烦的“应用无响应”(ANR) 对话框。如果引起用户不满，他们可能就会决定退出并卸载此应用。 此外，Android UI 工具包并非线程安全工具包。因此，您不得通过工作线程操纵 UI，而只能通过 UI 线程操纵用户界面。因此，Android 的单线程模式必须遵守两条规则： 1. 不要阻塞 UI 线程 2. 不要在 UI 线程之外访问 Android UI 工具包 工作线程 （Worker Thread）根据上述单线程模式，要保证应用 UI 的响应能力，关键是不能阻塞 UI 线程。如果执行的操作不能很快完成，则应确保它们在单独的线程（“后台”或“工作”线程）中运行。 例如，以下代码演示了一个点击侦听器从单独的线程下载图像并将其显示在 ImageView 中： 12345678910111213public void onClick(View v) &#123; new Thread(new Runnable() &#123; public void run() &#123; Bitmap b = loadImageFromNetwork("http://example.com/image.png"); mImageView.setImageBitmap(b); &#125; &#125;).start();&#125; 乍看起来，这段代码似乎运行良好，因为它创建了一个新线程来处理网络操作。 但是，它违反了单线程模式的第二条规则：不要在 UI 线程之外访问 Android UI 工具包—此示例从工作线程（而不是 UI 线程）修改了 ImageView。这可能导致出现不明确、不可预见的行为，但要跟踪此行为困难而又费时。 为解决此问题，Android 提供了几种途径来从其他线程访问 UI 线程。以下列出了几种有用的方法： Activity.runOnUiThread(Runnable) View.post(Runnable) [View.postDelayed(Runnable, long)](https://developer.android.com/reference/android/view/View.html#postDelayed(java.lang.Runnable, long))例如，您可以通过使用 View.post(Runnable) 方法修复上述代码： 1234567891011121314151617181920212223public void onClick(View v) &#123; new Thread(new Runnable() &#123; public void run() &#123; final Bitmap bitmap = loadImageFromNetwork("http://example.com/image.png"); mImageView.post(new Runnable() &#123; public void run() &#123; mImageView.setImageBitmap(bitmap); &#125; &#125;); &#125; &#125;).start();&#125; 现在，上述实现属于线程安全型：在单独的线程中完成网络操作，而在 UI 线程中操纵 ImageView。 但是，随着操作日趋复杂，这类代码也会变得复杂且难以维护。 要通过工作线程处理更复杂的交互，可以考虑在工作线程中使用 Handler 处理来自 UI 线程的消息。当然，最好的解决方案或许是扩展 AsyncTask类，此类简化了与 UI 进行交互所需执行的工作线程任务。 使用 AsyncTask AsyncTask 允许对用户界面执行异步操作。它会先阻塞工作线程中的操作，然后在 UI 线程中发布结果，而无需您亲自处理线程和/或处理程序。 要使用它，必须创建 AsyncTask 子类并实现 doInBackground() 回调方法，该方法将在后台线程池中运行。要更新 UI，必须实现 onPostExecute() 以传递 doInBackground() 返回的结果并在 UI 线程中运行，这样，您即可安全更新 UI。稍后，您可以通过从 UI 线程调用 execute() 来运行任务。 例如，您可以通过以下方式使用 AsyncTask 来实现上述示例： 1234567891011121314151617181920212223242526public void onClick(View v) &#123; new DownloadImageTask().execute("http://example.com/image.png");&#125;private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap&gt; &#123; /** The system calls this to perform work in a worker thread and * delivers it the parameters given to AsyncTask.execute() */ protected Bitmap doInBackground(String... urls) &#123; return loadImageFromNetwork(urls[0]); &#125; /** The system calls this to perform work in the UI thread and delivers * the result from doInBackground() */ protected void onPostExecute(Bitmap result) &#123; mImageView.setImageBitmap(result); &#125;&#125; 现在 UI 是安全的，代码也得到简化，因为任务分解成了两部分：一部分应在工作线程内完成，另一部分应在 UI 线程内完成。 下面简要概述了 AsyncTask 的工作方法，但要全面了解如何使用此类，您应阅读 AsyncTask 参考文档： 可以使用泛型指定参数类型、进度值和任务最终值 方法 doInBackground() 会在工作线程上自动执行 onPreExecute()、onPostExecute() 和 onProgressUpdate() 均在 UI 线程中调用 doInBackground()返回的值将发送到 onPostExecute() 您可以随时在 doInBackground() 中调用publishProgress()，以在 UI 线程中执行 onProgressUpdate() 您可以随时取消任何线程中的任务 注意：使用工作线程时可能会遇到另一个问题，即：运行时配置变更（例如，用户更改了屏幕方向）导致 Activity 意外重启，这可能会销毁工作线程。 要了解如何在这种重启情况下坚持执行任务，以及如何在 Activity 被销毁时正确地取消任务，请参阅书架示例应用的源代码。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>Process</tag>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Dex In Process 使Android Studio 编译更快]]></title>
    <url>%2F2016%2F05%2F13%2F%E5%88%A9%E7%94%A8Dex-In-Process-%E4%BD%BFAndroid-Studio-%E7%BC%96%E8%AF%91%E6%9B%B4%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[(…..咳咳, 别点了，上面这个只是一个截图而已. @_@! ) Reto Meier - Faster Android Studio Builds with Dex In Process Android Studio 2.1 开启了一个新的特性： Dex In Process, 它能极大地提高全面清理的速度构建以及改善Instant Run(瞬间运行)的性能 要使用Dex In Process，你需要修改你的gradle.properties文件并且通过增加分配的内存量1GB到Gradle Daemon 虚拟机，对于一个最低额度为2GB的,使用org.gradle.jvmargs配置： 1org.gradle.jvmargs=-Xmx2048m 对于 Gradle Daemon 虚拟机内存 默认分配1GB —— 这样的情况不足以支持起dexInProcess，因此你将需要设置至少2GB才能利用它 Dex in process 通过运行多个DEX 进程运行在一个单一的虚拟机中共享着Gradle，这也是为什么你需要分配额外的内存才能使用它—— 内存将会被共享给Gradle和多个DEX进程 如果你将要增加javaMaxHeapSize到你module级别的build.gradle文件中，超过默认1GB，你需要增加相应的内存分配到Gradle Daemon 当默认情况下，有足够的内存分配Dex in process 是可用的，提高总体编译性能，同时移除启动多个并行虚拟机开销的实例。其结果就是在总体耗时、包括Instant Run、增量和全编都起到了显著改善 最佳值的变化依赖于不同的硬件设备，因此升级你的Android Studio到2.1 利用你的jvmargs值试验一下，看看什么才是最适合你的值。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Notification 通知样式总结]]></title>
    <url>%2F2016%2F05%2F12%2FAndroid-Notification-%E9%80%9A%E7%9F%A5%E6%A0%B7%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Notification 通知系统可让用户随时了解应用中的相关和即时事件，例如来自好友的新聊天信息或日历事件。可将通知视作新闻频道，在重要的事件发生时提醒用户注意，或者当作日志，在用户未注意时记录事件—可在用户的所有 Android 设备上按需同步。随着系统版本的更新，通知栏的风格种类得到扩展，从2.x、4.x、5.x、6.x，以至于最新版本的7.x(Android N)都有相当大的变化，那么现在来总结一下在Android 5.x（Lollipop）- Android 6.x(Mashmallow)上的通知栏样式，对于Android N 上的通知栏风格，我们后面在谈。 12345public static classNotification.Builderextends Objectjava.lang.Object ↳ android.app.Notification.Builder 在项目初始化的时候会，创建好通知栏管理对象—— NotificationManager 1NotificationManager manger = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); NormalStyle12345678910111213141516171819202122232425//为了版本兼容 选择V7包下的NotificationCompat进行构造NotificationCompat.Builder builder = new NotificationCompat.Builder(this);//setTicker 在5.0以上不显示Ticker属性信息builder.setTicker("状态栏显示的提示");//setContentTitle 通知栏通知的标题builder.setContentTitle("内容标题");//setContentText 通知栏通知的详细内容builder.setContentText("内容文本信息");//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）builder.setAutoCancel(true);//setLargeIcon 通知消息上的大图标builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));//setSmallIcon 通知上面的小图标builder.setSmallIcon(R.mipmap.ic_launcher);//小图标//创建一个意图Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com"));PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0);//setContentIntent 将意图设置到通知上builder.setContentIntent(pIntent);//通知默认的声音 震动 呼吸灯builder.setDefaults(NotificationCompat.DEFAULT_ALL);//构建通知Notification notification = builder.build();//将构建好的通知添加到通知管理器中，执行通知manger.notify(0, notification); DownloadStyle123456789101112131415161718192021222324252627282930313233//为了版本兼容 选择V7包下的NotificationCompat进行构造final NotificationCompat.Builder builder = new NotificationCompat.Builder(this);//setSmallIcon 通知上面的小图标builder.setSmallIcon(R.mipmap.ic_launcher);//setLargeIcon 通知消息上的大图标builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）builder.setAutoCancel(true);builder.setContentTitle("微信");builder.setContentText("下载中");new Thread( new Runnable() &#123; @Override public void run() &#123; int incr; for (incr = 0; incr &lt;= 100; incr += 5) &#123; builder.setProgress(100, incr, false); builder.setContentInfo(incr + "%"); manger.notify(1, builder.build()); try &#123; Thread.sleep(1 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; builder.setContentText("下载完成") // 移除进度条 .setProgress(0, 0, false).setContentInfo(""); Notification notification = builder.build(); manger.notify(1, notification); &#125; &#125;).start(); 1234567891011121314151617181920212223242526272829303132//为了版本兼容 选择V7包下的NotificationCompat进行构造final NotificationCompat.Builder builder = new NotificationCompat.Builder(this);//setSmallIcon 通知上面的小图标builder.setSmallIcon(R.mipmap.ic_launcher);//setLargeIcon 通知消息上的大图标builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）builder.setAutoCancel(true);builder.setContentTitle("微信");builder.setContentText("下载中");new Thread( new Runnable() &#123; @Override public void run() &#123; int incr; for (incr = 0; incr &lt;= 100; incr += 5) &#123; builder.setProgress(0, 0, true); manger.notify(2, builder.build()); try &#123; Thread.sleep(1 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; builder.setContentText("下载完成") // 移除进度条 .setProgress(0, 0, false).setContentInfo(""); Notification notification = builder.build(); manger.notify(2, notification); &#125; &#125;).start(); BigTextStyle123456789101112131415161718192021NotificationCompat.Builder builder = new NotificationCompat.Builder(this);builder.setContentTitle("BigTextStyle");builder.setContentText("BigTextStyle演示示例");builder.setSmallIcon(R.mipmap.ic_launcher);builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));android.support.v4.app.NotificationCompat.BigTextStyle style = new android.support.v4.app.NotificationCompat.BigTextStyle();//bigText 给样式设置大文本内容style.bigText("这里是点击通知后要显示的正文，正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字");//setBigContentTitle 给样式设置大文本的标题style.setBigContentTitle("点击后的标题");//SummaryText没什么用 可以不设置style.setSummaryText("末尾只一行的文字内容");//setStyle 将样式添加到通知builder.setStyle(style);builder.setAutoCancel(true);Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com"));PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0);builder.setContentIntent(pIntent);builder.setDefaults(NotificationCompat.DEFAULT_ALL);Notification notification = builder.build();manger.notify(3, notification); InBoxStyleNotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setContentTitle("InboxStyle"); builder.setContentText("InboxStyle演示示例"); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); android.support.v4.app.NotificationCompat.InboxStyle style = new android.support.v4.app.NotificationCompat.InboxStyle(); style.setBigContentTitle("BigContentTitle") .addLine("啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦") .addLine("哈哈哈哈哈") .addLine("嘻嘻嘻嘻") .addLine("嘿嘿嘿") .addLine("咦咦咦咦") .setSummaryText("SummaryText"); builder.setStyle(style); builder.setAutoCancel(true); Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com")); PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0); builder.setContentIntent(pIntent); builder.setDefaults(NotificationCompat.DEFAULT_ALL); Notification notification = builder.build(); manger.notify(4, notification); BigPictureStyleNotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setContentTitle("BigPictureStyle"); builder.setContentText("BigPicture演示示例"); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setDefaults(NotificationCompat.DEFAULT_ALL); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); android.support.v4.app.NotificationCompat.BigPictureStyle style = new android.support.v4.app.NotificationCompat.BigPictureStyle(); style.setBigContentTitle("BigContentTitle"); style.setSummaryText("SummaryText"); style.bigPicture(BitmapFactory.decodeResource(getResources(), R.drawable.head)); builder.setStyle(style); builder.setAutoCancel(true); Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com")); PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0); builder.setContentIntent(pIntent); builder.setDefaults(NotificationCompat.DEFAULT_ALL); Notification notification = builder.build(); manger.notify(5, notification); HungUpStyleNotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setContentTitle("横幅通知"); builder.setContentText("请在设置通知管理中开启消息横幅提醒权限"); builder.setDefaults(NotificationCompat.DEFAULT_ALL); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com")); PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0); builder.setContentIntent(pIntent); builder.setFullScreenIntent(pIntent, true); builder.setAutoCancel(true); Notification notification = builder.build(); manger.notify(6, notification); MediaStyleNotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setContentTitle("You Are Not Alone"); builder.setContentText("Michael Jackson"); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); builder.setDefaults(NotificationCompat.DEFAULT_ALL); //在锁定屏幕上显示控制，即使用户隐藏敏感内容(API&gt;=21) builder.setVisibility(Notification.VISIBILITY_PUBLIC); Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com")); PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0); builder.setContentIntent(pIntent); //addAction： 3个参数 图标、图标的标题、图标的动作 builder.addAction(android.R.drawable.ic_media_previous, "上一曲", null); builder.addAction(android.R.drawable.ic_media_pause, "暂停", null); builder.addAction(android.R.drawable.ic_media_play, "播放", pIntent); builder.addAction(android.R.drawable.ic_media_next, "下一曲", null); NotificationCompat.MediaStyle style = new NotificationCompat.MediaStyle(); style.setMediaSession(new MediaSessionCompat(this, "MediaSession", new ComponentName(MainActivity.this, Intent.ACTION_MEDIA_BUTTON), null).getSessionToken()); //CancelButton在5.0以下的机器有效 style.setCancelButtonIntent(pIntent); style.setShowCancelButton(true); //设置要现实在通知右方的图标 最多三个 style.setShowActionsInCompactView(2, 3); builder.setStyle(style); builder.setShowWhen(false); Notification notification = builder.build(); manger.notify(7, notification); RemoteViewsStyleNotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher);//小图标 RemoteViews remoteViews = new RemoteViews(this.getPackageName(), R.layout.remoteview_main); String title="Android Developer"; String content="developer.android.com"; remoteViews.setTextViewText(R.id.tv_title, title); remoteViews.setTextViewText(R.id.tv_content, content); builder.setContent(remoteViews); Notification notification = builder.build(); manger.notify(8, notification);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>notification</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Material Design —— Snackbar]]></title>
    <url>%2F2016%2F05%2F11%2FAndroid-Material-Design-%E2%80%94Snackbar%2F</url>
    <content type="text"><![CDATA[本节介绍在Material Design中有趣的组件之一的Snackbar Snackbar对于一个反馈提供了一个轻量级的操作。它显示了一个简短的消息在移动设备屏幕的底部，或者大型设备的左下方。Snackbar出现在屏幕上所有的元素之上，并且同一时间有且只能让一个被显示。除了能像Toast消息之外还提供了action动作来相互作用。以下就对Snackbar几种不同的场景进行示例说明 1234Snackbarextends Objectjava.lang.Object ↳ android.support.design.widget.Snackbar 简易的Snackbar下面的语法是一个简易的snackbar make方法的作用接受3个参数，视图、显示的消息和消息显示的间隔时间。 间隔时间应该是LENGTH_SHORT, LENGTH_LONG 或者 LENGTH_INDEFINITE，当LENGTH_INDEFINITE 被使用，snackbar将会显示时间不定，除非手动滑动关闭或者有其他新的snackbar显示 1234Snackbar snackbar = Snackbar .make(linearLayout, "This is a simple snackbar", Snackbar.LENGTH_LONG); snackbar.show(); Snackbar动作回调您也可以使用的setAction（）方法作用于回调。当用户使用snackbar的时候，它允许我们执行某几个动作。 1234567891011Snackbar snackbar = Snackbar .make(coordinatorLayout, "Message is deleted", Snackbar.LENGTH_LONG) .setAction("UNDO", new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar snackbar1 = Snackbar.make(coordinatorLayout, "Message is restored!", Snackbar.LENGTH_SHORT); snackbar1.show(); &#125; &#125;); snackbar.show(); 自定义SnackbarSnackbar 默认为白色文本颜色和#323232的背景颜色，你能够重写这些颜色 12345678910111213141516Snackbar snackbar = Snackbar .make(coordinatorLayout, "No internet connection!", Snackbar.LENGTH_LONG) .setAction("RETRY", new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; &#125; &#125;); // Changing message text colorsnackbar.setActionTextColor(Color.RED); // Changing action button text colorView sbView = snackbar.getView();TextView textView = (TextView) sbView.findViewById(android.support.design.R.id.snackbar_text);textView.setTextColor(Color.YELLOW);snackbar.show(); 创建新项目1、在Android Studio中 File ⇒ New Project 新建一个项目 2、打开builde.gradle文件添加design support支持依赖库 com.android.support:design:23.3.0 build.gradle 123456dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.3.0' compile 'com.android.support:design:23.3.0'&#125; activity_main.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/linearLayout" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" android:orientation="vertical" tools:context="com.example.shoewann.snackbardemo.MainActivity"&gt; &lt;Button android:id="@+id/btnSimpleSnackbar" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="30dp" android:text="Simple Snackbar" /&gt; &lt;Button android:id="@+id/btnActionCallback" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:text="With Action Callback" /&gt; &lt;Button android:id="@+id/btnCustomSnackbar" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:text="Custom Color" /&gt;&lt;/LinearLayout&gt; MainActivity.java import android.graphics.Color; import android.os.Bundle; import android.support.design.widget.Snackbar; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.LinearLayout; import android.widget.TextView; public class MainActivity extends AppCompatActivity implements View.OnClickListener { private android.widget.LinearLayout linearLayout; private android.widget.Button btnSimpleSnackbar; private android.widget.Button btnActionCallback; private android.widget.Button btnCustomSnackbar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); } private void initData() { this.btnSimpleSnackbar.setOnClickListener(this); this.btnActionCallback.setOnClickListener(this); this.btnCustomSnackbar.setOnClickListener(this); } private void initView() { this.linearLayout = (LinearLayout) findViewById(R.id.linearLayout); this.btnSimpleSnackbar = (Button) findViewById(R.id.btnSimpleSnackbar); this.btnActionCallback = (Button) findViewById(R.id.btnActionCallback); this.btnCustomSnackbar = (Button) findViewById(R.id.btnCustomSnackbar); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.btnSimpleSnackbar: Snackbar snackbar = Snackbar .make(linearLayout, "This is a simple snackbar", Snackbar.LENGTH_LONG); snackbar.show(); break; case R.id.btnActionCallback: Snackbar snackbar1 = Snackbar .make(linearLayout, "Message is deleted", Snackbar.LENGTH_LONG) .setAction("UNDO", new View.OnClickListener() { @Override public void onClick(View view) { Snackbar snackbar2 = Snackbar.make(linearLayout, "Message is restored!", Snackbar.LENGTH_SHORT); snackbar2.show(); } }); snackbar1.show(); break; case R.id.btnCustomSnackbar: Snackbar snackbar3 = Snackbar .make(linearLayout, "No internet connection!", Snackbar.LENGTH_LONG) .setAction("RETRY", new View.OnClickListener() { @Override public void onClick(View view) { } }); // Changing message text color snackbar3.setActionTextColor(Color.RED); // Changing action button text color View sbView = snackbar3.getView(); TextView textView = (TextView) sbView.findViewById(android.support.design.R.id.snackbar_text); textView.setTextColor(Color.YELLOW); snackbar3.show(); break; default: break; } } } Run and test the app.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Snackbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中自定义Seekbar分段的方法]]></title>
    <url>%2F2016%2F05%2F11%2FAndroid%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89Seekbar%E5%88%86%E6%AE%B5%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Android中自定义Seekbar分段的方法 在这里加入将一个Seekbar，平均分段为8段，每次拖动的距离相等 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243seekbar.setOnSeekBarChangeListener(new OnSeekBarChangeListener() &#123; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; // TODO Auto-generated method stub Log.i(TAG, "----onStopTrackingTouch----"); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; // TODO Auto-generated method stub Log.i(TAG, "----onStartTrackingTouch----"); &#125; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; if (fromUser) &#123; float pro = seekBar.getProgress(); float max = seekBar.getMax(); float result = (pro / max) * 100; if (result == 0) &#123; seekBar.setProgress(0); &#125; else if (result &gt; 0 &amp;&amp; result &lt;= 12.5) &#123; seekBar.setProgress(25 / 2); &#125; else if (result &gt; 12.5 &amp;&amp; result &lt;= 25) &#123; seekBar.setProgress(25); &#125; else if (result &gt; 25 &amp;&amp; result &lt;= 37.5) &#123; seekBar.setProgress(25 + (25 / 2)); &#125; else if (result &gt; 37.5 &amp;&amp; result &lt;= 50) &#123; seekBar.setProgress(50); &#125; else if (result &gt; 50 &amp;&amp; result &lt;= 62.5) &#123; seekBar.setProgress(50 + (25 / 2)); &#125; else if (result &gt; 62.5 &amp;&amp; result &lt;= 75) &#123; seekBar.setProgress(75); &#125; else if (result &gt; 75 &amp;&amp; result &lt;= 87.5) &#123; seekBar.setProgress(75 + (25 / 2)); &#125; else if (result &gt; 87.5 &amp;&amp; result &lt;= 100) &#123; seekBar.setProgress(100); &#125; &#125; &#125; &#125;);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Seekbar</tag>
      </tags>
  </entry>
</search>
